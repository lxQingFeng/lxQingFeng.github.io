<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>//post/hello-world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-3lz69ilqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-3lz69ilqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></div></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-khxunylqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-khxunylqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></div></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-1zn2mhlqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-1zn2mhlqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></div></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-s7wwuxlqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-s7wwuxlqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></div></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>开始</tag>
      </tags>
  </entry>
  <entry>
    <title>imgTP图床测试</title>
    <url>//post/imgTP%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95.html</url>
    <content><![CDATA[<h1 id="使用URL外链插入图片"><a href="#使用URL外链插入图片" class="headerlink" title="使用URL外链插入图片"></a>使用URL外链插入图片</h1><p>以下是一张二次元油墨画</p>
<p><img src="/post/imgTP%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95/EOFNREpH.jpg" alt="二次元图片"></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>地毯模组（Carpet）的使用教程</title>
    <url>//post/%E5%9C%B0%E6%AF%AF%E6%A8%A1%E7%BB%84%EF%BC%88Carpet%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html</url>
    <content><![CDATA[<p>Carpet中文百科</p>
<p><a href="https://www.mcmod.cn/class/2361.html">Carpet - MC百科|最大的Minecraft中文MOD百科 (mcmod.cn)</a></p>
<p>本文仅从以上链接中的教程总结出较为常用的命令</p>
<h1 id="player"><a href="#player" class="headerlink" title="&#x2F;player"></a>&#x2F;player</h1><p>&#x2F;player命令可以控制在线玩家或者假玩家。</p>
<h2 id="生成与清除"><a href="#生成与清除" class="headerlink" title="生成与清除"></a>生成与清除</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-mhv32jlqj6epxh"></i><span>MC-CMD</span><div class="collapse show" id="collapse-mhv32jlqj6epxh"><table><tr><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; spawn<br></code></pre></td></tr></table></div></figure>

<p>该命令会在玩家所在位置生成一个名为<target>的玩家，无论是否真实存在，并且保持与执行者一样的视角和游戏模式。</target></p>
<p>如果生成的玩家真实存在，则该玩家上线时将顶替掉生成的假玩家，并恢复原先的游戏模式。</p>
<figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-unv6gnlqj6epxh"></i><span>MC-CMD</span><div class="collapse show" id="collapse-unv6gnlqj6epxh"><table><tr><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; kill<br></code></pre></td></tr></table></div></figure>

<p>该命令会使假玩家退出当前存档或者服务器，同时保留他身上的物品。</p>
<p>该命令只对假玩家有效。</p>
<p>如果原版游戏规则keepInventory设为false，击杀生存模式的假玩家会使该玩家掉落身上的所有物品。</p>
<figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-3o345dlqj6epxh"></i><span>MC-CMD</span><div class="collapse show" id="collapse-3o345dlqj6epxh"><table><tr><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; shadow<br></code></pre></td></tr></table></div></figure>

<p>该命令会将目标玩家踢出存档或服务器，并在他的相同位置生成一个名称相同的假玩家。</p>
<p>该命令只对当前正在游玩的真玩家有效。</p>
<h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-3rtyiqlqj6epxh"></i><span>MC-CMD</span><div class="collapse show" id="collapse-3rtyiqlqj6epxh"><table><tr><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; look &lt;direction&gt;<br></code></pre></td></tr></table></div></figure>

<p>该命令会让玩家看向一定的方向。&lt;direction&gt;可以是：</p>
<ul>
<li>north（北）、south（南）、west（西）、east（东）、up（上）、down（下）；</li>
<li>at：让玩家看向某个位置。后面还需要跟玩家要看向的位置的坐标。</li>
</ul>
<figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-20t38jlqj6epxh"></i><span>MC-CMD</span><div class="collapse show" id="collapse-20t38jlqj6epxh"><table><tr><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; move &lt;direction&gt;<br></code></pre></td></tr></table></div></figure>

<p>该命令会让玩家按照指定的方向持续移动。&lt;direction&gt;可以是backward（后），forward（前），left（左），right（右）。</p>
<figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ejo3yblqj6epxh"></i><span>MC-CMD</span><div class="collapse show" id="collapse-ejo3yblqj6epxh"><table><tr><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; jump [&lt;option&gt;]<br></code></pre></td></tr></table></div></figure>

<p>该命令会让玩家跳跃一次。</p>
<p>可以使用[&lt;option&gt;]参数指定跳跃模式。[&lt;option&gt;]可以是：</p>
<ul>
<li>continuous：让玩家连续跳跃。</li>
<li>interval：让玩家每隔一定游戏刻跳跃一次。该参数要求后面再跟一个参数，指定跳跃间隔的游戏刻数。</li>
<li>once：让玩家跳跃一次，与默认情况相同。</li>
</ul>
<figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-2m8xntlqj6epxh"></i><span>MC-CMD</span><div class="collapse show" id="collapse-2m8xntlqj6epxh"><table><tr><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; sneak<br>/player &lt;target&gt; unsneak<br></code></pre></td></tr></table></div></figure>

<p>这两个命令可以分别让玩家潜行和取消潜行。</p>
<figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-hc4minlqj6epxh"></i><span>MC-CMD</span><div class="collapse show" id="collapse-hc4minlqj6epxh"><table><tr><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; sprint<br>/player &lt;target&gt; unsprint<br></code></pre></td></tr></table></div></figure>

<p>这两个命令可以分别让玩家疾跑和停止疾跑。</p>
<figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-gq5mm2lqj6epxh"></i><span>MC-CMD</span><div class="collapse show" id="collapse-gq5mm2lqj6epxh"><table><tr><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; turn &lt;option&gt;<br></code></pre></td></tr></table></div></figure>

<p>该命令可以让玩家的视角旋转。&lt;option&gt;可以是：</p>
<ul>
<li>back（转向身后），left（左转90°），right（右转90°）。</li>
<li>两个浮点数：具体控制旋转的角度。第一个数字控制视角的俯仰（正为俯视，负为仰视），第二个数字控制视角的水平角度（正为右转，负为左转）。例如， &#x2F;player &lt;target&gt; turn -45 90 会让玩家的视角上扬45°并右转90°。</li>
</ul>
<p>更多教程看</p>
<p><a href="https://www.mcmod.cn/item/list/2361-10.html">游戏设定 - Carpet - MC百科|最大的Minecraft中文MOD百科 (mcmod.cn)</a></p>
]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>我的世界mod教程</tag>
      </tags>
  </entry>
  <entry>
    <title>华为交换机基础配置</title>
    <url>//post/%E5%8D%8E%E4%B8%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<h1 id="基础配置命令"><a href="#基础配置命令" class="headerlink" title="基础配置命令"></a>基础配置命令</h1><p>启动后进入交换机</p>
<h2 id="设置中文提示"><a href="#设置中文提示" class="headerlink" title="设置中文提示"></a>设置中文提示</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-u54nqilqj6epxh"></i><span>switch</span><div class="collapse show" id="collapse-u54nqilqj6epxh"><table><tr><td class="code"><pre><code class="hljs switch">language-mode Chinese<br></code></pre></td></tr></table></div></figure>
<h2 id="进入系统视图"><a href="#进入系统视图" class="headerlink" title="进入系统视图"></a>进入系统视图</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-il5uynlqj6epxh"></i><span>switch</span><div class="collapse show" id="collapse-il5uynlqj6epxh"><table><tr><td class="code"><pre><code class="hljs switch">system-view<br></code></pre></td></tr></table></div></figure>
<h2 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-aulhkklqj6epxh"></i><span>switch</span><div class="collapse show" id="collapse-aulhkklqj6epxh"><table><tr><td class="code"><pre><code class="hljs switch">user privilege level 15<br></code></pre></td></tr></table></div></figure>
<h2 id="进入console配置"><a href="#进入console配置" class="headerlink" title="进入console配置"></a>进入console配置</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-nbr167lqj6epxh"></i><span>switch</span><div class="collapse show" id="collapse-nbr167lqj6epxh"><table><tr><td class="code"><pre><code class="hljs switch">user-interface console 0<br></code></pre></td></tr></table></div></figure>
<h2 id="设置console密码"><a href="#设置console密码" class="headerlink" title="设置console密码"></a>设置console密码</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-h35owolqj6epxh"></i><span>switch</span><div class="collapse show" id="collapse-h35owolqj6epxh"><table><tr><td class="code"><pre><code class="hljs switch">authentication-mode password<br>set authentication password simple Huawei<br></code></pre></td></tr></table></div></figure>
<h2 id="设置登录前后标语"><a href="#设置登录前后标语" class="headerlink" title="设置登录前后标语"></a>设置登录前后标语</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-fgkziflqj6epxh"></i><span>switch</span><div class="collapse show" id="collapse-fgkziflqj6epxh"><table><tr><td class="code"><pre><code class="hljs switch">header login information &quot;This is SW1&quot;<br>header shell information &quot;login succeed&quot;<br></code></pre></td></tr></table></div></figure>

<h2 id="创建与划分vlan"><a href="#创建与划分vlan" class="headerlink" title="创建与划分vlan"></a>创建与划分vlan</h2><h3 id="创建vlan"><a href="#创建vlan" class="headerlink" title="创建vlan"></a>创建vlan</h3><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-g5rmv6lqj6epxh"></i><span>switch</span><div class="collapse show" id="collapse-g5rmv6lqj6epxh"><table><tr><td class="code"><pre><code class="hljs switch">vlan batch 10 20<br></code></pre></td></tr></table></div></figure>

<h3 id="进入端口并划分vlan"><a href="#进入端口并划分vlan" class="headerlink" title="进入端口并划分vlan"></a>进入端口并划分vlan</h3><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-nxp3iblqj6epxh"></i><span>switch</span><div class="collapse show" id="collapse-nxp3iblqj6epxh"><table><tr><td class="code"><pre><code class="hljs switch">interface GigabitEthernet 0/0/1<br>port link-type access<br>port default vlan 10<br></code></pre></td></tr></table></div></figure>

<h2 id="设置vlan-IP"><a href="#设置vlan-IP" class="headerlink" title="设置vlan IP"></a>设置vlan IP</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ua3s1slqj6epxh"></i><span>switch</span><div class="collapse show" id="collapse-ua3s1slqj6epxh"><table><tr><td class="code"><pre><code class="hljs switch">interface vlanif 10<br>ip address 192.168.10.1 24<br></code></pre></td></tr></table></div></figure>

<h2 id="查看配置结果"><a href="#查看配置结果" class="headerlink" title="查看配置结果"></a>查看配置结果</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ryhictlqj6epxh"></i><span>switch</span><div class="collapse show" id="collapse-ryhictlqj6epxh"><table><tr><td class="code"><pre><code class="hljs switch">display current-configuration<br></code></pre></td></tr></table></div></figure>
]]></content>
      <categories>
        <category>网络设备</category>
      </categories>
      <tags>
        <tag>eNSP</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用tmux（终端工具）</title>
    <url>//post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tmux%EF%BC%88%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%EF%BC%89.html</url>
    <content><![CDATA[<h1 id="什么是tmux"><a href="#什么是tmux" class="headerlink" title="什么是tmux"></a>什么是tmux</h1><p>Tmux 是一个终端复用器（terminal multiplexer）</p>
<p>tmux 有主要两个用途：</p>
<ol>
<li>分屏。既可以同时使用多个命令行；</li>
<li>会话与窗口解绑。当窗口意外关闭时，会话并不会终止，后面需要的时候，会话可以再次绑定窗口。尤其当使用SSH远程登录计算机时，可以不受断网的影响。</li>
</ol>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="安装tmux"><a href="#安装tmux" class="headerlink" title="安装tmux"></a>安装tmux</h2><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-kz94h8lqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-kz94h8lqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ubantu or Debian</span><br>sudo apt-get install tmux<br><br><span class="hljs-comment"># Centos or Fedora</span><br>sudo yum install tmux<br><br><span class="hljs-comment"># Mac</span><br>brew install tmux<br></code></pre></td></tr></table></div></figure>

<h2 id="启动、退出"><a href="#启动、退出" class="headerlink" title="启动、退出"></a>启动、退出</h2><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ozgxyilqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-ozgxyilqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">tmux<br></code></pre></td></tr></table></div></figure>

<p>在终端输入以上命令即可启动tmux，启动后终端底部会显示一个状态栏。</p>
<p>左侧是窗口信息（编号和名称），右侧是系统信息。</p>
<p><img src="/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tmux%EF%BC%88%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%EF%BC%89/image-20230606181115946.png" alt="image-20230606181115946"></p>
<p>按下<code>Ctrl + d</code>或者在终端输入<code>exit</code>即可退出tmux。</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-hz40z1lqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-hz40z1lqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></div></figure>

<h2 id="tmux术语"><a href="#tmux术语" class="headerlink" title="tmux术语"></a>tmux术语</h2><p>tmux 采用 client&#x2F;server模型，主要有四个模块：</p>
<ul>
<li>server：服务。tmux运行的基础服务，以下模块均依赖于此服务；</li>
<li>session：会话。一个服务可以包含多个会话；</li>
<li>window：窗口。一个会话可以包含多个窗口；</li>
<li>panel：窗格&#x2F;面板。一个窗口可以包含多个窗格。</li>
</ul>
<p>执行 tmux 命令时，即开启了一个服务，并创建了一个会话、窗口和窗格。</p>
<h2 id="前缀键"><a href="#前缀键" class="headerlink" title="前缀键"></a>前缀键</h2><p>Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是<code>Ctrl+b</code>，即先按下<code>Ctrl+b</code>，快捷键才会生效。</p>
<p>举例来说，帮助命令的快捷键是<code>Ctrl+b ?</code>。它的用法是，在 Tmux 窗口中，先按下<code>Ctrl+b</code>，再按下<code>?</code>，就会显示帮助信息。</p>
<p>然后，按下 ESC 键或<code>q</code>键，就可以退出帮助。</p>
<h1 id="Tmux会话管理"><a href="#Tmux会话管理" class="headerlink" title="Tmux会话管理"></a>Tmux会话管理</h1><h2 id="新建会话"><a href="#新建会话" class="headerlink" title="新建会话"></a>新建会话</h2><p>第一个启动的 Tmux 窗口，编号是 <code>0</code>，第二个窗口的编号是 <code>1</code>，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</p>
<p>使用编号区分会话，不太直观，更好的方法是为会话起名。</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-zd47lclqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-zd47lclqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">tmux new -s &lt;your-session-name&gt;<br></code></pre></td></tr></table></div></figure>

<p>上面命令新建一个指定名称的会话。</p>
<h2 id="分离会话"><a href="#分离会话" class="headerlink" title="分离会话"></a>分离会话</h2><p>在 Tmux 窗口中，按下 <code>Ctrl+b d</code> 或者输入 <code>tmux detach</code> 命令，就会将当前会话与窗口分离。</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-pxej12lqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-pxej12lqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">tmux detach<br></code></pre></td></tr></table></div></figure>

<p>上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。</p>
<p><code>tmux ls</code> 命令可以查看当前所有的 Tmux 会话。</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-v1l8jclqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-v1l8jclqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">tmux <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># or</span><br>tmux list-session<br></code></pre></td></tr></table></div></figure>

<p><img src="/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tmux%EF%BC%88%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%EF%BC%89/image-20230606182214934.png" alt="image-20230606182214934"></p>
<h2 id="接入会话"><a href="#接入会话" class="headerlink" title="接入会话"></a>接入会话</h2><p>在终端输入<code>tmux attach</code>用于重新接入某个已存在的会话。</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-04u35alqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-04u35alqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用会话编号接入会话</span><br>tmux attach -t 0<br><br><span class="hljs-comment"># 使用会话名称接入会话</span><br>tmux attach -t &lt;your-session-name&gt;<br></code></pre></td></tr></table></div></figure>

<h2 id="kill会话"><a href="#kill会话" class="headerlink" title="kill会话"></a>kill会话</h2><p>在终端输入<code>tmux kill-session</code>用于杀死某个已存在的会话。</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-m7ga8elqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-m7ga8elqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用会话编号结束会话</span><br>tmux kill-sesion -t 0<br><br><span class="hljs-comment"># 使用会话名称结束会话</span><br>tmux kill-sesion -t &lt;your-session-name&gt;<br></code></pre></td></tr></table></div></figure>

<h2 id="切换会话"><a href="#切换会话" class="headerlink" title="切换会话"></a>切换会话</h2><p>在终端输入<code>tmux switch</code>以切换会话。</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ss3zrylqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-ss3zrylqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用会话编号切换会话</span><br>tmux switch -t 0<br><br><span class="hljs-comment"># 使用会话名称切换会话</span><br>tmux switch -t &lt;session-name&gt;<br></code></pre></td></tr></table></div></figure>

<h2 id="重命名会话"><a href="#重命名会话" class="headerlink" title="重命名会话"></a>重命名会话</h2><p>在终端输入<code>tmux rename-session</code>以重命名会话。</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-m6sertlqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-m6sertlqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">tmux rename-session -t 0 &lt;new-name&gt;<br></code></pre></td></tr></table></div></figure>

<p>以上命令会将<code>0</code>号会话重命名。</p>
<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>tmux大部分操作都可以用快捷键来代替。</p>
<p>使用快捷键的前提是先按下了<code>Ctrl + b</code></p>
<p>使用<code>tmux list-keys</code>可以列出所有快捷键。</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-wesc9olqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-wesc9olqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">tmux list-keys<br></code></pre></td></tr></table></div></figure>

<h2 id="会话快捷键"><a href="#会话快捷键" class="headerlink" title="会话快捷键"></a>会话快捷键</h2><ul>
<li>s ：列出所有会话，也可以在列表中用鼠标或上下键切换会话</li>
<li>d ：离开当前会话</li>
<li>$ ：重命名当前会话</li>
</ul>
<h2 id="窗口快捷键"><a href="#窗口快捷键" class="headerlink" title="窗口快捷键"></a>窗口快捷键</h2><ul>
<li>c ： 创建一个新窗口</li>
<li>n ： 切换到下一个窗口</li>
<li>w ： 从列表中选择窗口</li>
<li>&lt;0~9&gt; ： 切换到指定标号的窗口，编号显示在状态栏</li>
<li>,（这是一个英文逗号） : 将窗口重命名</li>
</ul>
<p>一个<code>session</code>中可以有很多个窗口，可以在状态栏中查看，如：</p>
<p><img src="/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tmux%EF%BC%88%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%EF%BC%89/image-20230606184635853.png" alt="image-20230606184635853"></p>
<p>其中：</p>
<p><code>[key]</code>表示的是当前会话的名称。</p>
<p><code>0：zsh-</code>表示的是0号窗口，<code>zsh</code>是窗口的名字。</p>
<p>窗口名字后的<code>*</code>号代表当前显示的窗口。</p>
<p>而右侧显示的是用户名、当前时间、当前日期。</p>
<h2 id="窗格快捷键"><a href="#窗格快捷键" class="headerlink" title="窗格快捷键"></a>窗格快捷键</h2><ul>
<li>% ： 将窗口分成<strong>左右</strong>两个窗格。</li>
<li>“（这是一个英文双引号）： 将窗口分成<strong>上下</strong>两个窗格。</li>
<li>z ： 将当前窗格<strong>全屏显示</strong>，再按一次恢复。</li>
<li>q ： 显示窗格编号。</li>
<li>t ： 再当前窗格显示时间。</li>
<li>o ： 将光标切换到下个一个窗格。</li>
<li>&lt;arrow key&gt; ： 将光标切换到其他窗格。使用<strong>上下左右方向键</strong>进行切换</li>
<li>{ ： 将当前窗格<strong>左移</strong>。</li>
<li>} ： 将当前窗格<strong>右移</strong>。</li>
<li>Ctrl + o ： 将当前窗格<strong>上移</strong>。</li>
<li>Alt + o ： 将当前窗格<strong>下移</strong>。</li>
<li>space（空格键） ： 切换窗格布局。</li>
<li>x ： 删除当前窗格。</li>
</ul>
<h1 id="配置tmux支持鼠标"><a href="#配置tmux支持鼠标" class="headerlink" title="配置tmux支持鼠标"></a>配置tmux支持鼠标</h1><p>鼠标支持的内容：</p>
<ul>
<li>用鼠标点击窗格来激活该窗格；</li>
<li>用鼠标拖动调节窗格的大小（拖动位置是窗格之间的分隔线）；</li>
<li>用鼠标点击来切换活动窗口（点击位置是状态栏的窗口名称）；</li>
<li>开启窗口&#x2F;窗格里面的鼠标支持，用鼠标回滚显示窗口内容，按下shift的同时用鼠标选取文本，使用 ctrl+shift+c、ctrl+shift+v 的方式进行复制粘贴。</li>
</ul>
<p>配置方式为在 ~&#x2F;.tmux.conf 文件中，增加：</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-enlaeslqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-enlaeslqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">set-option -g mouse on<br></code></pre></td></tr></table></div></figure>



<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol>
<li><a href="https://zhuanlan.zhihu.com/p/137715607">https://zhuanlan.zhihu.com/p/137715607</a></li>
<li><a href="https://www.cnblogs.com/niuben/p/15983908.html">https://www.cnblogs.com/niuben/p/15983908.html</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">https://www.ruanyifeng.com/blog/2019/10/tmux.html</a></li>
<li><a href="https://blog.csdn.net/CSSDCC/article/details/121231906">https://blog.csdn.net/CSSDCC/article/details/121231906</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>这是一篇用来测试的文章</title>
    <url>//post/%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E7%94%A8%E6%9D%A5%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%87%E7%AB%A0.html</url>
    <content><![CDATA[<p>此篇文章用来记录一些hexo的基本操作（纯新手）</p>
<h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h2><p><del>此时我在<strong>source</strong>文件夹下新建了一个名为 “Article_Picture” 的文件夹用来存放图片。</del><br><del>此时只需要按照以下格式在.md文件中写入即可。</del></p>
<p>不用看以上方法了，没用。</p>
<p>首先在hexo的配置文件<code>config.yaml</code>更改一下配置：</p>
<figure class="highlight yaml"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-r7w5stlqj6epxh"></i><span>yaml</span><div class="collapse show" id="collapse-r7w5stlqj6epxh"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></div></figure>

<p>随后使用命令新建一篇文章时，hexo会在<code>_posts</code>中生成相同名字的文件夹，此时将图片放在该文件夹下，而后按照以下格式进行插入即可。</p>
<figure class="highlight markdown"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-mcvey5lqj6epxh"></i><span>markdown</span><div class="collapse show" id="collapse-mcvey5lqj6epxh"><table><tr><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">图片加载失败时的描述</span>](<span class="hljs-link">图片链接</span>)<br></code></pre></td></tr></table></div></figure>
<p><img src="/post/%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E7%94%A8%E6%9D%A5%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%87%E7%AB%A0/%E6%B5%8B%E8%AF%95%E6%88%AA%E5%9B%BE2.png" alt="这其实是一张图片"></p>
<h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><p>略</p>
<h1 id="插件的查看与卸载"><a href="#插件的查看与卸载" class="headerlink" title="插件的查看与卸载"></a>插件的查看与卸载</h1><h2 id="查看已安装插件"><a href="#查看已安装插件" class="headerlink" title="查看已安装插件"></a>查看已安装插件</h2><p>在blog目录下输入以下命令即可查看已安装插件</p>
<figure class="highlight powershell"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-2de7lalqj6epxh"></i><span>powershell</span><div class="collapse show" id="collapse-2de7lalqj6epxh"><table><tr><td class="code"><pre><code class="hljs powershell">npm <span class="hljs-built_in">ls</span> <span class="hljs-literal">-dept</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></div></figure>
<p><img src="/post/%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E7%94%A8%E6%9D%A5%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%87%E7%AB%A0/mingling.png" alt="这其实是一张图片"></p>
<h2 id="卸载插件"><a href="#卸载插件" class="headerlink" title="卸载插件"></a>卸载插件</h2><p>在blog目录下输入以下命令即可卸载已安装插件</p>
<figure class="highlight powershell"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-srehfvlqj6epxh"></i><span>powershell</span><div class="collapse show" id="collapse-srehfvlqj6epxh"><table><tr><td class="code"><pre><code class="hljs powershell">npm uninstall hexo<span class="hljs-literal">-asset-image</span>@<span class="hljs-number">0.0</span>.<span class="hljs-number">5</span> <span class="hljs-literal">--save</span><br></code></pre></td></tr></table></div></figure>
<p>其中 <strong><a href="mailto:&#104;&#x65;&#120;&#x6f;&#45;&#97;&#x73;&#x73;&#101;&#116;&#45;&#x69;&#x6d;&#x61;&#x67;&#x65;&#x40;&#x30;&#x2e;&#48;&#46;&#53;">&#104;&#x65;&#120;&#x6f;&#45;&#97;&#x73;&#x73;&#101;&#116;&#45;&#x69;&#x6d;&#x61;&#x67;&#x65;&#x40;&#x30;&#x2e;&#48;&#46;&#53;</a></strong> 为要卸载的插件的名称</p>
<p>最后还需前往 <strong>node_modules</strong> 文件夹删除相关配置和文件</p>
<h1 id="插入数学公式"><a href="#插入数学公式" class="headerlink" title="插入数学公式"></a>插入数学公式</h1><h2 id="安装所需插件"><a href="#安装所需插件" class="headerlink" title="安装所需插件"></a>安装所需插件</h2><p>卸载 Hexo 自带的 renderer，安装 Pandoc renderer<br><a href="https://github.com/jgm/pandoc">下载pandoc并安装</a></p>
<figure class="highlight powershell"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ulxg4ilqj6epxh"></i><span>powershell</span><div class="collapse show" id="collapse-ulxg4ilqj6epxh"><table><tr><td class="code"><pre><code class="hljs powershell">npm uninstall hexo<span class="hljs-literal">-renderer-marked</span> <span class="hljs-literal">--save</span><br>npm install hexo<span class="hljs-literal">-renderer-pandoc</span> <span class="hljs-literal">--save</span><br></code></pre></td></tr></table></div></figure>

<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p><a href="https://corner430.github.io/2021/07/02/%E7%94%A8markdown%E4%B9%A6%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/#:~:text=%E8%A1%8C%E5%86%85%E5%85%AC%E5%BC%8F%EF%BC%9A%E5%B0%86%E5%85%AC%E5%BC%8F%E6%8F%92%E5%85%A5%E5%88%B0%E6%9C%AC%E8%A1%8C%E5%86%85%EF%BC%8C%E7%AC%A6%E5%8F%B7%EF%BC%9A%20%24%E5%85%AC%E5%BC%8F%E5%86%85%E5%AE%B9%24%20%EF%BC%8C%E5%A6%82%EF%BC%9A%20xyz,%E7%8B%AC%E8%A1%8C%E5%85%AC%E5%BC%8F%EF%BC%9A%E5%B0%86%E5%85%AC%E5%BC%8F%E6%8F%92%E5%85%A5%E5%88%B0%E6%96%B0%E7%9A%84%E4%B8%80%E8%A1%8C%E5%86%85%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%B1%85%E4%B8%AD%EF%BC%8C%E7%AC%A6%E5%8F%B7%EF%BC%9A%20%24%24%E5%85%AC%E5%BC%8F%E5%86%85%E5%AE%B9%24%24%20%EF%BC%8C%E5%A6%82%EF%BC%9A%20xyz">具体请参考这篇文章</a></p>
<p>所有公式都应该包括在一对 “$” 符号中，例如：</p>
<figure class="highlight markdown"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-8lbvsdlqj6epxh"></i><span>markdown</span><div class="collapse show" id="collapse-8lbvsdlqj6epxh"><table><tr><td class="code"><pre><code class="hljs markdown">$里面是公式内容$<br></code></pre></td></tr></table></div></figure>
<p>$5^5-ads$</p>
<h1 id="如何使用-Emoji-表情"><a href="#如何使用-Emoji-表情" class="headerlink" title="如何使用 Emoji 表情"></a>如何使用 Emoji 表情</h1><h2 id="使用表情符号简码"><a href="#使用表情符号简码" class="headerlink" title="使用表情符号简码"></a>使用表情符号简码</h2><p>一些Markdown应用程序允许您通过键入表情符号短代码来插入表情符号。这些以冒号开头和结尾，并包含表情符号的名称。</p>
<figure class="highlight markdown"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-3kbukwlqj6epxh"></i><span>markdown</span><div class="collapse show" id="collapse-3kbukwlqj6epxh"><table><tr><td class="code"><pre><code class="hljs markdown">去露营了！ :tent: 很快回来。<br>真好笑！ :joy:<br></code></pre></td></tr></table></div></figure>
<p>呈现的输出如下所示：<br>去露营了！ :tent: 很快回来。<br>真好笑！ :joy:</p>
<p><a href="https://markdown.com.cn/extended-syntax/emoji.html">请参考Markdown的官方教程</a></p>
<p><a href="https://gist.github.com/rxaviers/7360908">这是表情符号简码列表</a></p>
<h1 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h1><h2 id="Markdown默认方法"><a href="#Markdown默认方法" class="headerlink" title="Markdown默认方法"></a>Markdown默认方法</h2><p>表头内容默认居中对齐，单元格内容默认左对齐，Markdown 代码:</p>
<figure class="highlight markdown"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-dp6ajhlqj6epxh"></i><span>markdown</span><div class="collapse show" id="collapse-dp6ajhlqj6epxh"><table><tr><td class="code"><pre><code class="hljs markdown">| 标题1 | 标题2 | 标题3 |<br>| ------ | ------ | ------ |<br>| 文本好短 | 文本不短也不长 | 文本好长文本好长文本好长 |<br>| 文本好长文本好长文本好长 | 文本好短 | 文本不短也不长 |<br></code></pre></td></tr></table></div></figure>
<p>显示效果：</p>
<table>
<thead>
<tr>
<th>标题1</th>
<th>标题2</th>
<th>标题3</th>
</tr>
</thead>
<tbody><tr>
<td>123</td>
<td>123</td>
<td>123</td>
</tr>
<tr>
<td>123</td>
<td>123</td>
<td>123</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>如何正确的食用Docker</title>
    <url>//post/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%A3%9F%E7%94%A8Docker.html</url>
    <content><![CDATA[<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><h2 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h2><p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html">Go 语言</a> 并遵从 Apache2.0 协议开源。</p>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<h2 id="Docker能干嘛？"><a href="#Docker能干嘛？" class="headerlink" title="Docker能干嘛？"></a>Docker能干嘛？</h2><p>软件开发最大的麻烦事之一，就是环境配置。而Docker可以十分方便的配置它们。</p>
<p>传统的虚拟机技术启动应用服务往往需要数分钟，而 <code>Docker</code> 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>
<h2 id="Docker的三个基本概念"><a href="#Docker的三个基本概念" class="headerlink" title="Docker的三个基本概念"></a>Docker的三个基本概念</h2><p>Docker 包括三个基本概念：</p>
<ul>
<li><strong>镜像（image）</strong>：Docker 镜像（image），相当于是一个root文件系统。例如官方镜像 Ubuntu: 16.04 就包含了完整的一套 Ubuntu 16.04 最小系统的root文件系统。</li>
<li><strong>容器（Container）</strong>：容器（Container）<strong>由</strong> Docker 镜像（image）生成。一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</li>
<li><strong>仓库（Repository）</strong>：镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="https://docker-practice.github.io/zh-cn/repository/registry.html">Docker Registry</a> 就是这样的服务。</li>
</ul>
<h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p>Docker 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p>
<p><a href="https://docs.docker.com/get-docker/">Get Docker | Docker Documentation</a></p>
<h2 id="在Ubuntu安装Docker"><a href="#在Ubuntu安装Docker" class="headerlink" title="在Ubuntu安装Docker"></a>在Ubuntu安装Docker</h2><p>Docker 支持以下版本的 <a href="https://ubuntu.com/server">Ubuntu</a> 操作系统：</p>
<ul>
<li>Ubuntu Hirsute 21.04</li>
<li>Ubuntu Groovy 20.10</li>
<li>Ubuntu Focal 20.04 (LTS)</li>
<li>Ubuntu Bionic 18.04 (LTS)</li>
</ul>
<p>Docker 可以安装在 64 位的 x86 平台或 ARM 平台上。Ubuntu 发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本。</p>
<h3 id="卸载旧版本Docker"><a href="#卸载旧版本Docker" class="headerlink" title="卸载旧版本Docker"></a>卸载旧版本Docker</h3><p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本：</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ovk20nlqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-ovk20nlqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get remove docker \<br>             docker-engine \<br>             docker.io<br></code></pre></td></tr></table></div></figure>

<h3 id="使用-APT-安装"><a href="#使用-APT-安装" class="headerlink" title="使用 APT 安装"></a>使用 APT 安装</h3><p>由于 <code>apt</code> 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-yr6nbllqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-yr6nbllqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get udate<br><br>sudo apt-get install \<br>	apt-transport-https \<br>    ca-certificates \<br>    curl \<br>    gnupg \<br>    lsb-release<br></code></pre></td></tr></table></div></figure>

<p>为了确认所下载软件包的合法性，需要添加软件源的 <code>GPG</code> 密钥。</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-g3jakdlqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-g3jakdlqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br><br><span class="hljs-comment"># 官方源</span><br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br></code></pre></td></tr></table></div></figure>

<p>向<code>sources.list</code>中添加 Docker 软件源</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-2oe2m4lqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-2oe2m4lqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> \<br>  <span class="hljs-string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span><br><span class="hljs-string">  <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br><br><span class="hljs-comment"># 官方源</span><br><span class="hljs-comment"># $ echo \</span><br><span class="hljs-comment">#   &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="hljs-comment">#   $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></code></pre></td></tr></table></div></figure>

<h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p>更新 apt 软件包缓存，并安装 <code>docker-ce</code>：</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-qnay0hlqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-qnay0hlqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin<br></code></pre></td></tr></table></div></figure>

<h3 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h3><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-al64qvlqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-al64qvlqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> docker<br>sudo systemctl start docker<br></code></pre></td></tr></table></div></figure>

<h3 id="建立-Docker-用户组"><a href="#建立-Docker-用户组" class="headerlink" title="建立 Docker 用户组"></a>建立 Docker 用户组</h3><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p>
<p>建立<code>docker</code>组：</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-kjppjflqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-kjppjflqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">sudo groupadd docker<br></code></pre></td></tr></table></div></figure>

<p>将当前用户加入<code>docker</code>组：</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-xmahyklqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-xmahyklqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></div></figure>

<h2 id="在CentOS安装Docker"><a href="#在CentOS安装Docker" class="headerlink" title="在CentOS安装Docker"></a>在CentOS安装Docker</h2><p>切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker</p>
<p>Docker 支持 64 位版本 CentOS 7&#x2F;8，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定。</p>
<h3 id="卸载旧版本Docker-1"><a href="#卸载旧版本Docker-1" class="headerlink" title="卸载旧版本Docker"></a>卸载旧版本Docker</h3><p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本：</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-zhu7jzlqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-zhu7jzlqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">sudo yum remove docker \<br>                docker-client \<br>                docker-client-latest \<br>                docker-common \<br>                docker-latest \<br>                docker-latest-logrotate \<br>                docker-logrotate \<br>                docker-selinux \<br>                docker-engine-selinux \<br>                docker-engine<br></code></pre></td></tr></table></div></figure>

<h3 id="使用-yum-安装"><a href="#使用-yum-安装" class="headerlink" title="使用 yum 安装"></a>使用 yum 安装</h3><p>安装依赖包：</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-whhdgglqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-whhdgglqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">sudo yum install -y yum-utils<br></code></pre></td></tr></table></div></figure>

<p>添加<code>yum</code>软件源：</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-3hdd9flqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-3hdd9flqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">sudo yum-config-manager \<br>	--add-repp \<br>	https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br>sudo sed -i <span class="hljs-string">&#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27;</span> /etc/yum.repos.d/docker-ce.repo<br><br><span class="hljs-comment"># 官方源</span><br>sudo yum-config-manager \<br>	--add-repp<br>	https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></div></figure>

<p>如需测试版本的Docker：</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-n3fuetlqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-n3fuetlqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">sudo yum-config-manager --<span class="hljs-built_in">enable</span> docker-ce-test<br></code></pre></td></tr></table></div></figure>

<h3 id="安装-Docker-1"><a href="#安装-Docker-1" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p>更新 <code>yum</code> 软件源缓存，并安装 <code>docker-ce</code>。</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-0mzqjwlqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-0mzqjwlqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin<br></code></pre></td></tr></table></div></figure>

<h3 id="CentOS8的额外设置"><a href="#CentOS8的额外设置" class="headerlink" title="CentOS8的额外设置"></a>CentOS8的额外设置</h3><p>由于 CentOS8 防火墙使用了 <code>nftables</code>，但 Docker 尚未支持 <code>nftables</code>， 我们可以使用如下设置使用 <code>iptables</code>：</p>
<p>更改 <code>/etc/firewalld/firewalld.conf</code></p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-a25kr3lqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-a25kr3lqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># FirewallBackend=nftables</span><br>FirewallBackend=iptables<br></code></pre></td></tr></table></div></figure>

<p>或执行以下命令：</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-hazlhflqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-hazlhflqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">firewall-cmd --permanent --zone=trusted --add-interface=docker0<br>firewall-cmd --reload<br></code></pre></td></tr></table></div></figure>

<h3 id="启动-Docker-1"><a href="#启动-Docker-1" class="headerlink" title="启动 Docker"></a>启动 Docker</h3><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-zidaz8lqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-zidaz8lqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> docker<br>sudo systemctl start docker<br></code></pre></td></tr></table></div></figure>

<h3 id="建立-Docker-用户组-1"><a href="#建立-Docker-用户组-1" class="headerlink" title="建立 Docker 用户组"></a>建立 Docker 用户组</h3><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p>
<p>建立 <code>docker</code> 组：</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-77h70zlqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-77h70zlqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">sudo groupadd docker<br></code></pre></td></tr></table></div></figure>

<p>将当前用户加入<code>docker</code>组：</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-vj4eoelqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-vj4eoelqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">sudo usermod -aG docekr <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></div></figure>

<h3 id="添加内核参数"><a href="#添加内核参数" class="headerlink" title="添加内核参数"></a>添加内核参数</h3><p>如果在 CentOS 使用 Docker 看到下面的这些警告信息：</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-whlloflqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-whlloflqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">WARNING: bridge-nf-call-iptables is disabled<br>WARNING: bridge-nf-call-ip6tables is disabled<br></code></pre></td></tr></table></div></figure>

<p>添加内核配置参数以启用这些功能</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ddedjklqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-ddedjklqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">tee</span> -a /etc/sysctl.conf &lt;&lt;-<span class="hljs-string">EOF</span><br><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="hljs-string">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></div></figure>

<p>重新加载<code>sysctl.conf</code>即可</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ksq2grlqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-ksq2grlqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">sudo sysctl -p<br></code></pre></td></tr></table></div></figure>

<h1 id="Docker食用指南"><a href="#Docker食用指南" class="headerlink" title="Docker食用指南"></a>Docker食用指南</h1><h2 id="镜像使用指南"><a href="#镜像使用指南" class="headerlink" title="镜像使用指南"></a>镜像使用指南</h2><p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p>
<h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。命令格式是：</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-i6o6t9lqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-i6o6t9lqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">docker pull [OPTIONS] NAME[:TAG|@DIGEST]<br></code></pre></td></tr></table></div></figure>

<p> <strong>参数说明：</strong></p>
<ul>
<li>TAG：标签（版本）</li>
<li>DIGEST：摘要</li>
<li>OPTIONS：<ul>
<li>-a ：下载镜像仓库中所有的指定镜像；</li>
<li>–disable-content-trust：跳过镜像验证（默认值是true）；</li>
<li>–platform： 如果服务具有多平台功能，则设置平台；</li>
<li>-q：一直详细输出；</li>
</ul>
</li>
</ul>
<p>具体选项可以通过<code>docker pull --help</code>命令查看。</p>
<p><strong>例子如下：</strong></p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ek8re5lqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-ek8re5lqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">$ docker pull ubuntu:18.04<br>18.04: Pulling from library/ubuntu<br>92dc2a97ff99: Pull complete<br>be13a9d27eb8: Pull complete<br>c8299583700a: Pull complete<br>Digest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> ubuntu:18.04<br>docker.io/library/ubuntu:18.04<br></code></pre></td></tr></table></div></figure>

<p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （<code>docker.io</code>）获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。<code>docker pull</code> 命令的输出结果最后一行给出了镜像的完整名称，即： <code>docker.io/library/ubuntu:18.04</code>。</p>
<ul>
<li>Docker 镜像仓库地址：地址的格式一般是<code>域名/IP[:端口号]</code>。默认地址是 Docker Hub（<code>docker.io</code>）。</li>
<li>仓库名：仓库名是两段式名称，即<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果没有指定用户名，则默认是<code>library</code>，也就是官方镜像。</li>
</ul>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>有了镜像后，可以以这个镜像为基础启动并运行一个容器。以上面的<code>Ubuntu:18.04</code>为例，如果打算启动里面的<code>bash</code>并且进行交互式操作的话，可以执行以下命令：</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-4ijtrdlqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-4ijtrdlqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">$ docker run -it --<span class="hljs-built_in">rm</span> ubuntu:18:04 bash<br><br><span class="hljs-comment"># 以下是容器内操作</span><br>root@e7009c6ce357:/<span class="hljs-comment"># cat /etc/os-release</span><br>NAME=<span class="hljs-string">&quot;Ubuntu&quot;</span><br>VERSION=<span class="hljs-string">&quot;18.04.1 LTS (Bionic Beaver)&quot;</span><br>ID=ubuntu<br>ID_LIKE=debian<br>PRETTY_NAME=<span class="hljs-string">&quot;Ubuntu 18.04.1 LTS&quot;</span><br>VERSION_ID=<span class="hljs-string">&quot;18.04&quot;</span><br>HOME_URL=<span class="hljs-string">&quot;https://www.ubuntu.com/&quot;</span><br>SUPPORT_URL=<span class="hljs-string">&quot;https://help.ubuntu.com/&quot;</span><br>BUG_REPORT_URL=<span class="hljs-string">&quot;https://bugs.launchpad.net/ubuntu/&quot;</span><br>PRIVACY_POLICY_URL=<span class="hljs-string">&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span><br>VERSION_CODENAME=bionic<br>UBUNTU_CODENAME=bionic<br></code></pre></td></tr></table></div></figure>

<p><code>docker run</code>就是要运行容器的命令，这里简单说明一下上面用到的参数</p>
<ul>
<li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li>
<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li>
</ul>
<p>进入容器后就可以在 Shell 下操作执行任何所需的命令。例如，上面就执行了<code>cat /etc/os-release</code>，这是Linux常用的查看当前系统版本的命令，从返回的结果可以看到容器内是<code>Ubuntu 18.04.1 LTS</code>系统。</p>
<p>最后可以通过<code>exit</code>退出这个容器。</p>
<h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-yvoy15lqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-yvoy15lqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span><br>REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE<br>redis                latest              5f515359c7f8        5 days ago          183 MB<br>nginx                latest              05a60462f8ba        5 days ago          181 MB<br>mongo                3.2                 fe9198c04d62        5 days ago          342 MB<br>&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB<br>ubuntu               18.04               329ed837d508        3 days ago          63.3MB<br>ubuntu               bionic              329ed837d508        3 days ago          63.3MB<br></code></pre></td></tr></table></div></figure>

<p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p>
<p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p>
<h4 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h4><p>Docker Hub上显示的镜像体积是压缩后的体积大小，在镜像上传和下载的过程中镜像是保持压缩状态的。而使用命令<code>docker image ls</code>显示的是镜像下载到本地后展开的大小，准确说，是展开后的各层所占空间的总和。</p>
<p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。相同的层只需要保存一份即可。</p>
<p>通过<code>docker system df</code>命令来查看镜像、容器、数据卷所占用的空间。</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-pdg2amlqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-pdg2amlqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">$ docker system <span class="hljs-built_in">df</span><br>TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE<br>Images          2         1         390.2MB   390.2MB (99%)<br>Containers      1         0         0B        0B<br>Local Volumes   0         0         0B        0B<br>Build Cache     18        0         789B      789B<br></code></pre></td></tr></table></div></figure>

<h4 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h4><p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p>
<p>根据仓库名列出仓库</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-o2j0t5lqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-o2j0t5lqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span> ubuntu<br>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE<br>ubuntu       latest    ba6acccedd29   23 months ago   72.8MB<br>ubuntu       18.04     5a214d77f5d7   23 months ago   63.1MB<br></code></pre></td></tr></table></div></figure>

<p>列出特定的某个镜像，也就是说指定仓库名和标签</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-yfptiilqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-yfptiilqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span> ubuntu:18.04<br>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE<br>ubuntu       18.04     5a214d77f5d7   23 months ago   63.1MB<br></code></pre></td></tr></table></div></figure>

<h3 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h3><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p>
<figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-bxoia9lqj6epxh"></i><span>bash</span><div class="collapse show" id="collapse-bxoia9lqj6epxh"><table><tr><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">rm</span> [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]<br></code></pre></td></tr></table></div></figure>

<p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p>
<p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p>
<h2 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h2><h4 id="启动容器、"><a href="#启动容器、" class="headerlink" title="启动容器、"></a>启动容器、</h4><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p>
<p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>更多详细教程请参考 <a href="https://docker-practice.github.io/zh-cn/">前言 · Docker – 从入门到实践 (docker-practice.github.io)</a></p>
<p><a href="https://blog.csdn.net/zhuzicc/article/details/118066353">Docker “pull“命令获取镜像，讲道理你真的会吗？_docker pull_zhuzicc的博客-CSDN博客</a></p>
<p><a href="https://www.runoob.com/docker/docker-tutorial.html">Docker 教程 | 菜鸟教程 (runoob.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/435605760">全面的Docker快速入门教程 - 知乎 (zhihu.com)</a></p>
<p><a href="https://ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络练习题</title>
    <url>//post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%83%E4%B9%A0%E9%A2%98.html</url>
    <content><![CDATA[<h1 id="一、填空题"><a href="#一、填空题" class="headerlink" title="一、填空题"></a>一、填空题</h1><ol>
<li>按照网络覆盖的地理范围，计算机网络可以分为<strong>局域网</strong>、<strong>城域网</strong>和<strong>广域网</strong>。</li>
<li>广播网络传输方式有<strong>单播</strong>、<strong>广播</strong>和<strong>多播</strong>。</li>
<li>从功能上来看将计算机网路逻辑划分为<strong>客户端</strong>和<strong>服务器端</strong>。</li>
<li>从组网的层次角度来看，网络的组成结构是一个典型的三层网络机构，最上层称为<strong>核心层</strong>，中间层称为<strong>汇聚层</strong>，最下层称为<strong>接入层</strong>。</li>
<li>影响网络的因素有<strong>带宽</strong>、<strong>延迟</strong>、<strong>抖动</strong>和<strong>丢包</strong>。</li>
<li>OSI模型将网络分为<strong>物理层</strong>、<strong>数据链路层</strong>、<strong>网络层</strong>、<strong>传输层</strong>、<strong>会话层</strong>、<strong>表示层</strong>和<strong>应用层</strong>。</li>
<li>TCP&#x2F;IP协议有四层，由下往上分别为<strong>网络接口层</strong>、<strong>网络层</strong>、<strong>传输层</strong>和<strong>应用层</strong>。</li>
<li>在TCP&#x2F;IP协议中，网络层主要协议有<strong>IP</strong>、<strong>ICMP</strong>、<strong>ARP</strong>和<strong>RARP</strong>。</li>
<li>在TCP&#x2F;IP协议中，传输层主要协议有<strong>TCP</strong>和<strong>UDP</strong>。</li>
<li>双绞线按结构可分为<strong>屏蔽双绞线</strong>和<strong>非屏蔽双绞线</strong>。</li>
<li>按传输模式分，光纤可分为<strong>单模光纤</strong>和<strong>多模光纤</strong>两类。</li>
<li>双绞线水晶头的制作标准有<strong>T568A</strong>和<strong>T568B</strong>两种。</li>
<li>交换机的互联方式主要有<strong>串行互联</strong>、<strong>并行互联</strong>、<strong>总线互联</strong>和<strong>星型互联</strong>。</li>
<li>局域网的体系结构涉及到了OSI模型的<strong>物理层</strong>和<strong>数据链路层</strong>两层。</li>
<li>802标准把局域网的数据链路层分为<strong>LLC子层</strong>和<strong>MAC子层</strong>两个子层。</li>
<li>常用的介质访问控制协议有三种：<strong>CSMA&#x2F;CD</strong>、<strong>CSMA&#x2F;CA</strong>和<strong>令牌环</strong>。</li>
<li>令牌环介质访问控制方法，是通过在环型网上传输<strong>令牌</strong>的方式来实现对介质的访问控制的。</li>
<li>IP地址由<strong>网络地址</strong>和<strong>主机地址</strong>两部分组成，前者用于该主机所在的网络，后者表示该主机在网络中的特定位置。</li>
<li>IPv6由<strong>128</strong>位二进制数组成。</li>
<li>以太网利用<strong>ARP</strong>协议获得主机IP地址与MAC地址的映射关系。</li>
<li>TCP连接包括<strong>三次握手</strong>、<strong>数据传输</strong>和<strong>四次挥手</strong>三个过程。</li>
<li>TCP采用<strong>滑动窗口</strong>机制实现流量控制功能。</li>
<li>Telnet服务系统采用<strong>C&#x2F;S</strong>工作模式，主要由<strong>Telnet服务器</strong>、<strong>Telnet客户端</strong>和<strong>网络</strong>组成。</li>
<li>复用技术主要有<strong>频分复用</strong>、<strong>时分复用</strong>和<strong>码分复用</strong>三种。</li>
<li>交换技术主要有<strong>电路交换</strong>、<strong>报文交换</strong>和<strong>分组交换</strong>三种。</li>
<li>IPv6地址为2005：0610：0000：0001：0000：0000：0000：67ff，可压缩表示为<strong>2005:610::1:0:0:67ff</strong>。</li>
</ol>
<h1 id="二、选择题"><a href="#二、选择题" class="headerlink" title="二、选择题"></a>二、选择题</h1><ol>
<li>一座大楼内的计算机网络系统属于（<strong>B．LAN</strong>）。</li>
<li>世界上第一个计算机网络是（<strong>A．ARPANET</strong>）。</li>
<li>计算机互联的主要目的是（<strong>D．资源共享</strong>）。</li>
<li>计算机资源主要指计算机（<strong>C．硬件、软件与数据</strong>）。</li>
<li>在一台计算机上向另一台计算机发送电子邮件信息时，下面哪一项正确的描述了数据封装的五个步骤？（<strong>A．Data Segment Packet Frame Bit</strong>）。</li>
<li>将双绞线制作成交叉线，该双绞线连接的两个设备可为（<strong>A．网卡与网卡</strong>）。</li>
<li>采用5类双绞线所连接的以太网，理论上任意两台PC机的最大间隔距离是多少？（<strong>A．100m</strong>）。</li>
<li>以太网交换机根据（<strong>B．MAC地址</strong>）转发数据包。</li>
<li>MAC地址通常存储在计算机的（<strong>A．网卡上</strong>）。</li>
<li>在以太网中，冲突（<strong>C．是一种正常现象</strong>）。</li>
<li>以下IP地址中，属于B类地址的是（<strong>B．166.166.166.166</strong>）。</li>
<li>一个局域网中某台主机的IP地址为192.168.160.13，使用22位作为网络地址，那么该局域网的子网掩码为（<strong>D．255.255.240.0</strong>）。</li>
<li>下列地址属于单播地址的是（<strong>C．192.168.25.59&#x2F;30</strong>）。</li>
<li>三次握手方法用于（<strong>A．传输层连接的建立</strong>）。</li>
<li>TCP是因特网中的（<strong>可靠的</strong>）协议，使用（<strong>三</strong>）次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答（<strong>SYN+ACK</strong>）。这种建立连接的方法可以防止（<strong>重复连接</strong>）。TCP使用的流量控制协议是（<strong>滑动窗口</strong>）。</li>
<li>在右图网络中，共有（ <strong>3</strong> ）个广播域，（ <strong>3</strong> ）个冲突域。</li>
</ol>
<p><img src="https://picst.sunbangyan.cn/2023/12/24/ecdd0352d5b1b1b140be364ace1aab00.jpeg" alt="右图网络"></p>
<h1 id="三、简答题"><a href="#三、简答题" class="headerlink" title="三、简答题"></a>三、简答题</h1><p>这是一份计算机网络的简答题，我可以帮助你完成。以下是我为你准备的答案：</p>
<ol>
<li>OSI的七层模型及每一层的数据形式：</li>
</ol>
<figure class="highlight asciidoc"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-hcxonolqj6epxh"></i><span>asciidoc</span><div class="collapse show" id="collapse-hcxonolqj6epxh"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>应用层（Application）：数据单位是报文（Message）<br><span class="hljs-bullet">- </span>表示层（Presentation）：数据单位是报文（Message）<br><span class="hljs-bullet">- </span>会话层（Session）：数据单位是报文（Message）<br><span class="hljs-bullet">- </span>传输层（Transport）：数据单位是段（Segment）<br><span class="hljs-bullet">- </span>网络层（Network）：数据单位是包（Packet）<br><span class="hljs-bullet">- </span>数据链路层（Data Link）：数据单位是帧（Frame）<br><span class="hljs-bullet">- </span>物理层（Physical）：数据单位是比特流（Bit）<br></code></pre></td></tr></table></div></figure>

<ol start="2">
<li>TCP&#x2F;IP的四层模型及上三层主要协议：</li>
</ol>
<figure class="highlight asciidoc"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-vxorahlqj6epxh"></i><span>asciidoc</span><div class="collapse show" id="collapse-vxorahlqj6epxh"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>应用层：HTTP、FTP、SMTP、DNS等<br><span class="hljs-bullet">- </span>传输层：TCP、UDP<br><span class="hljs-bullet">- </span>网络层：IP、ICMP、ARP、RARP<br><span class="hljs-bullet">- </span>网络接口层<br></code></pre></td></tr></table></div></figure>

<ol start="3">
<li><p><strong>FTTH</strong>（Fiber To The Home）是一种光纤直接到户的宽带接入方式，它提供了极高的带宽，可以满足用户对高速互联网、数字电视、电话等多种业务的需求。<br><strong>ADSL</strong>（Asymmetric Digital Subscriber Line）是一种非对称数字用户线路，它利用电话线提供宽带接入服务，但上行和下行的带宽不对称。</p>
</li>
<li><p><strong>HTTP</strong>（HyperText Transfer Protocol）是一种用于传输超文本的协议，主要用于网页浏览。<br><strong>DNS</strong>（Domain Name System）是一种用于将域名转换为IP地址的服务。<br><strong>FTP</strong>（File Transfer Protocol）是一种用于在网络上进行文件传输的协议。<br><strong>DHCP</strong>（Dynamic Host Configuration Protocol）是一种动态主机配置协议，用于自动分配IP地址。</p>
</li>
<li><p><strong>基带传输</strong>是指信号在传输过程中保持原始的形式和频率，通常用于短距离、高数据率的传输，如局域网。<br><strong>频带传输</strong>是指信号在传输过程中被调制到较高的频率，通常用于长距离、低数据率的传输，如电视广播。</p>
</li>
<li><p><strong>DNS</strong>有两种域名查询方式：<strong>递归查询</strong>和<strong>迭代查询</strong>。递归查询是指客户端向DNS服务器发出请求后，DNS服务器必须给出一个明确的回答。如果DNS服务器不知道答案，它会向其他服务器查询，直到得到一个明确的答案。迭代查询是指客户端向DNS服务器发出请求后，如果DNS服务器不知道答案，它会告诉客户端去向哪个服务器查询。</p>
</li>
<li><p><strong>VLAN</strong>的划分方式主要有以下几种：<strong>按端口划分</strong>、<strong>按MAC地址划分</strong>、<strong>按IP地址划分</strong>、<strong>按协议类型划分</strong>。</p>
</li>
</ol>
<h1 id="四、计算题"><a href="#四、计算题" class="headerlink" title="四、计算题"></a>四、计算题</h1><ol>
<li><p>一个主机的IP地址是202.112.14.137，掩码为255.255.255.224，求这个主机所在网络的网络地址和广播地址。</p>
<figure class="highlight dns"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ls7eaplqj6epxh"></i><span>dns</span><div class="collapse show" id="collapse-ls7eaplqj6epxh"><table><tr><td class="code"><pre><code class="hljs dns">IP地址：<span class="hljs-number">202.112.14.137</span> = <span class="hljs-number">11001010</span>.<span class="hljs-number">01110000</span>.<span class="hljs-number">00001110</span>.<span class="hljs-number">10001001</span><br>子网掩码：<span class="hljs-number">255.255.255.224</span> = <span class="hljs-number">11111111</span>.<span class="hljs-number">11111111</span>.<span class="hljs-number">11111111</span>.<span class="hljs-number">11100000</span><br>网络地址：将IP地址和子网掩码进行按位与运算，得到：<br><span class="hljs-number">11001010</span>.<span class="hljs-number">01110000</span>.<span class="hljs-number">00001110</span>.<span class="hljs-number">10000000</span> = <span class="hljs-number">202.112.14.128</span><br>广播地址：将网络地址的主机位全部置为<span class="hljs-number">1</span>，得到：<br><span class="hljs-number">11001010</span>.<span class="hljs-number">01110000</span>.<span class="hljs-number">00001110</span>.<span class="hljs-number">10011111</span> = <span class="hljs-number">202.112.14.159</span><br></code></pre></td></tr></table></div></figure></li>
</ol>
<p><strong>这个主机所在网络的网络地址是202.112.14.128，广播地址是202.112.14.159。</strong></p>
<ol start="2">
<li>如下图，通过设置静态路由实现主机A能ping通主机B，则在路由器R1、R2、R3上分别要设置怎样的静态路由。</li>
</ol>
<p><img src="https://picss.sunbangyan.cn/2023/12/24/77d7eb09d59f96cbcfaa7a8d7108aace.jpeg" alt="拓扑图"></p>
<p>R1</p>
<table>
<thead>
<tr>
<th align="left">Dest</th>
<th>Mask</th>
<th>GW</th>
<th>Interface</th>
</tr>
</thead>
<tbody><tr>
<td align="left">192.168.3.0</td>
<td>255.255.255.0</td>
<td>192.168.4.2</td>
<td>e1_1</td>
</tr>
</tbody></table>
<p>R2</p>
<table>
<thead>
<tr>
<th>Dest</th>
<th>Mask</th>
<th>GW</th>
<th>Interface</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.2.0</td>
<td>255.255.255.0</td>
<td>192.168.4.1</td>
<td>e1_1</td>
</tr>
<tr>
<td>192.168.3.0</td>
<td>255.255.255.0</td>
<td>192.168.6.2</td>
<td>e1_2</td>
</tr>
</tbody></table>
<p>R3</p>
<table>
<thead>
<tr>
<th>Dest</th>
<th>Mask</th>
<th>GW</th>
<th>Interface</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.2.0</td>
<td>255.255.255.0</td>
<td>192.168.6.1</td>
<td>e1_1</td>
</tr>
</tbody></table>
<h1 id="计算题解释"><a href="#计算题解释" class="headerlink" title="计算题解释"></a>计算题解释</h1><h2 id="1、计算网络地址和广播地址"><a href="#1、计算网络地址和广播地址" class="headerlink" title="1、计算网络地址和广播地址"></a>1、计算网络地址和广播地址</h2><ol>
<li><strong>计算网络地址</strong>：网络地址是通过将IP地址和子网掩码进行按位与运算得到的。按位与运算的规则是，如果两个对应的二进制位都为1，则结果为1，否则为0。因此，我们将IP地址和子网掩码对应的二进制位进行比较，如果都是1，则结果为1，否则为0。这样我们就得到了网络地址。</li>
<li><strong>计算广播地址</strong>：广播地址是通过将网络地址的主机位全部置为1得到的。在子网掩码中，网络位对应的是1，主机位对应的是0。因此，我们将网络地址中，对应子网掩码中0的那些位，全部置为1，就得到了广播地址。</li>
</ol>
<h2 id="2、配置静态路由"><a href="#2、配置静态路由" class="headerlink" title="2、配置静态路由"></a>2、配置静态路由</h2><p>静态路由的设置是基于网络的拓扑结构和IP地址配置。在你的网络中，主机A需要通过路由器R1、R2、R3来访问主机B。因此，我们需要在每个路由器上设置适当的静态路由，以便数据包能够正确地从主机A路由到主机B。</p>
<p>对于路由器R1，我们需要设置一个静态路由，使得所有目标为主机B所在网络的数据包都会被发送到下一跳路由器R2。因此，我们将目标网络设置为主机B所在的网络，子网掩码设置为主机B所在网络的子网掩码，网关设置为R1到R2的接口IP，接口设置为R1到R2的接口。</p>
<p>对于路由器R2，我们需要设置两个静态路由。一个是使得所有目标为主机B所在网络的数据包都会被发送到下一跳路由器R3，另一个是使得所有目标为主机A所在网络的数据包都会被发送到下一跳路由器R1。因此，我们将目标网络设置为主机B和主机A所在的网络，子网掩码设置为主机B和主机A所在网络的子网掩码，网关设置为R2到R3和R2到R1的接口IP，接口设置为R2到R3和R2到R1的接口。</p>
<p>对于路由器R3，我们需要设置一个静态路由，使得所有目标为主机A所在网络的数据包都会被发送到下一跳路由器R2。因此，我们将目标网络设置为主机A所在的网络，子网掩码设置为主机A所在网络的子网掩码，网关设置为R3到R2的接口IP，接口设置为R3到R2的接口。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
