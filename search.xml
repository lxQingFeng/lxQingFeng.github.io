<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Ubuntu搭建思源笔记（Docker）</title>
    <url>//post/Ubuntu%E6%90%AD%E5%BB%BA%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%EF%BC%88Docker%EF%BC%89.html</url>
    <content><![CDATA[<p>安装docker和docker-compose的过程不再赘叙</p>
<h2 id="编写docker-compose.yaml">编写docker-compose.yaml</h2>
<p>在任意位置新建<code>docker-compose.yaml</code>文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /siyuan &amp;&amp; cd /siyuan</span><br><span class="line">vim docker-compose.yaml</span><br></pre></td></tr></table></figure>
<p>写入以下信息（授权码自己修改）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">siyuan:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">b3log/siyuan:latest</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&#x27;--workspace=/siyuan/workspace/&#x27;</span>, <span class="string">&#x27;--accessAuthCode=授权码&#x27;</span>]</span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">siyuan</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">TZ=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">&#x27;1000:1000&#x27;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">6806</span><span class="string">:6806</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/siyuan/workspace:/siyuan/workspace</span></span><br></pre></td></tr></table></figure>
<p>保存退出后通过<code>docker-compose up -d</code>启动</p>
<p>随后就可以通过<code>http://&lt;your_ip:6806&gt;</code>查看服务</p>
<h2 id="自定义域名">自定义域名</h2>
<p>使用<code>docker</code>安装运行<code>Nginx Proxy Manager</code></p>
<p>在任意位置新建<code>docker-compose.yaml</code>文件并写入以下内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">jc21/nginx-proxy-manager:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">80</span><span class="string">:80</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">81</span><span class="string">:81</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">443</span><span class="string">:443</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">DB_MYSQL_HOST:</span> <span class="string">db</span></span><br><span class="line">      <span class="attr">DB_MYSQL_PORT:</span> <span class="number">3306</span></span><br><span class="line">      <span class="attr">DB_MYSQL_USER:</span> <span class="string">npm</span></span><br><span class="line">      <span class="attr">DB_MYSQL_PASSWORD:</span> <span class="string">npm</span></span><br><span class="line">      <span class="attr">DB_MYSQL_NAME:</span> <span class="string">npm</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./letsencrypt:/etc/letsencrypt</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">yobasystems/alpine-mariadb:latest</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">npm</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">npm</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">npm</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">npm</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mysql:/var/lib/mysql</span></span><br></pre></td></tr></table></figure>
<p>保存退出后通过<code>docker-compose up -d</code>启动</p>
<p>随后就可以通过<code>http://&lt;your_ip:81&gt;</code>查看服务</p>
<h3 id="配置nginx-proxy-manager">配置Nginx Proxy Manager</h3>
<p>通过<code>http://&lt;your_ip:81&gt;</code>打开浏览器查看服务</p>
<p>输入默认账号密码登录服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">账号：admin@example.com</span><br><span class="line">密码：changeme</span><br></pre></td></tr></table></figure>
<p>登录后点击界面上的<code>SSL Certificates</code>给服务添加证书</p>
<p><img
src="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/97e847c93aa2cb06df372139aa314c716e699f.webp" /></p>
<p>随后依次点击<code>Add SSL Certificates</code> --&gt;
<code>Let's Encrypt</code></p>
<p><img
src="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/71e3f0f25ef4da4e94b3582f94819dbfe9c242.webp" /></p>
<p>输入自己的域名并同意条款后点击<code>Save</code>等待几分钟即可</p>
<p><img
src="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/e128f87851b254bd1943900b3708b35dd30bb5.webp" /></p>
<p>随后点击<code>Hosts</code> --&gt; <code>Proxy Hosts</code></p>
<p><img
src="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/61571b806083cfc0474401d4d6f6de63220c19.webp" /></p>
<p>点击<code>Add Proxy Host</code></p>
<p><img
src="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/224784b392b7bf57bdd1724d0d6641f12a6e72.webp" /></p>
<p>根据自己的情况依次填入信息</p>
<p><img
src="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/d546ee5692d745a8fa5341161a9ec9b3c5701a.webp" /></p>
<p>其中<code>172.21.0.2</code>是容器IP 可以参考以下内容查看容器IP</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect [容器ID] | grep IPAddress</span><br></pre></td></tr></table></figure>
<p><img
src="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/41d033b249351c9c96d721a9525c7a3853aa9f.webp" /></p>
<p>随后点击<code>SSL</code>添加刚刚申请的证书并启用<code>Force SSL</code>与<code>HTTP/2 Support</code></p>
<p><img
src="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/0709b45547909dab5d903002d26bce5b801f6a.webp" /></p>
<p>再点击<code>Save</code>保存即可通过域名访问思源笔记</p>
<p>当然 前提是你的域名已经解析到了你的服务器</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux根目录下的各个目录的作用及各颜色类型</title>
    <url>//post/Linux%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E5%90%84%E4%B8%AA%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8.html</url>
    <content><![CDATA[<h1 id="linux根目录下的各个目录都有特定的作用和含义"><a
href="https://blog.csdn.net/alidada_blog/article/details/81778969">Linux根目录下的各个目录都有特定的作用和含义</a></h1>
<ol type="1">
<li><a
href="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/bin</code>：存放最常用命令</a></li>
<li><a
href="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/boot</code>：启动Linux的核心文件</a></li>
<li><a
href="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/dev</code>：设备文件，即设备的驱动程序</a></li>
<li><a
href="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/etc</code>：存放各种配置文件</a></li>
<li><a
href="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/home</code>：用户主目录</a></li>
<li><a
href="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/lib</code>：系统最基本的动态链接共享库</a></li>
<li><a
href="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/mnt</code>：一般是空的，用来临时挂载别的文件系统</a></li>
<li><a
href="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/proc</code>：虚拟目录，是内存的映射</a></li>
<li><a
href="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/sbin</code>：系统的管理命令，这里存放的是系统管理员使用的程序</a></li>
<li><a
href="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/tmp</code>：临时文件，重启后自动清空</a></li>
<li><a
href="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/var</code>：某些大文件的溢出区，比如各种服务的日志文件</a></li>
<li><a
href="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/media</code>：存放着可移除的设备，比如软盘，光盘</a></li>
<li><a
href="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/root</code>：超级用户的目录</a></li>
<li><a
href="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/opt</code>：这个是给第三方协力软件放置的目录</a></li>
<li><a
href="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/sys</code>：管理设备文件</a></li>
<li><a
href="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/usr</code>：最大的目录，存放着应用程序和文件</a></li>
</ol>
<h1
id="文件和目录的颜色代表了什么类型">文件和目录的颜色代表了什么类型</h1>
<ul>
<li><strong>蓝色</strong>：目录</li>
<li><strong>绿色</strong>：可执行文件</li>
<li><strong>红色</strong>：压缩文件</li>
<li><strong>浅蓝色</strong>：链接文件</li>
<li><strong>白色</strong>：普通文件或硬链接</li>
<li><strong>红色闪烁</strong>：某文件被删除后，链接到该文件的软链接的颜色</li>
<li><strong>黄色</strong>：设备文件，如键盘鼠标</li>
<li><strong>灰色</strong>：其它文件</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>//post/hello-world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>开始</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言练习题</title>
    <url>//post/C%E8%AF%AD%E8%A8%80%E7%BB%83%E4%B9%A0%E9%A2%98.html</url>
    <content><![CDATA[<h1 id="打印输出1-30之间的所有素数">打印输出1-30之间的所有素数</h1>
<h2 id="思路">思路</h2>
<p>这个程序的目标是打印出1到30之间的所有素数。为了实现这个目标，我们首先需要一个函数来判断一个数是否为素数。这就是<code>is_prime</code>函数的作用。它接受一个整数作为参数，然后通过一个for循环来检查这个数是否可以被2到它的平方根之间的任何整数整除。如果可以，那么这个数就不是素数，函数返回0；否则，这个数就是素数，函数返回1。</p>
<p>然后在<code>main</code>函数中，我们使用一个for循环来遍历1到30的所有整数。对于每一个整数，我们都调用<code>is_prime</code>函数来检查它是否为素数。如果是，我们就使用<code>printf</code>函数将它打印出来。</p>
<h2 id="代码">代码</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_prime</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_prime(i)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1
id="输入6个整数仅用指针法实现按由大到小的顺序输出">输入6个整数，仅用指针法实现按由大到小的顺序输出</h1>
<h2 id="思路-1">思路</h2>
<p>这个程序的目标是接收用户输入的6个整数，并按照由大到小的顺序输出这些整数。为了实现这个目标，我们首先需要一个函数来对数组进行排序。这就是<code>sort</code>函数的作用。它接受一个整数指针和一个整数作为参数，整数指针指向我们要排序的数组，整数表示数组的长度。<code>sort</code>函数使用了冒泡排序算法，通过两层循环来比较并交换数组中的元素，从而实现排序。</p>
<p>然后在<code>main</code>函数中，我们首先定义了一个长度为6的整数数组。然后，我们使用一个for循环和<code>scanf</code>函数来接收用户输入的6个整数，并将这些整数存储在数组中。接着，我们调用<code>sort</code>函数来对数组进行排序。最后，我们使用一个for循环和<code>printf</code>函数来按照由大到小的顺序输出这6个整数。</p>
<h2 id="代码-1">代码</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*(arr + i) &lt; *(arr + j)) &#123;</span><br><span class="line">                <span class="type">int</span> temp = *(arr + i);</span><br><span class="line">                *(arr + i) = *(arr + j);</span><br><span class="line">                *(arr + j) = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入6个整数：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, arr + i);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(arr, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;由大到小的顺序输出为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(arr + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="解释">解释</h1>
<h2 id="section">1</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这行代码包含了<code>stdio.h</code>头文件，它是C语言中提供输入/输出功能的库。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">is_prime</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br></pre></td></tr></table></figure>
<p>这行代码定义了一个名为<code>is_prime</code>的函数，它接受一个整数<code>num</code>作为参数。这个函数用于检查<code>num</code>是否为素数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (num &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>如果<code>num</code>小于或等于1，那么它就不是素数，所以我们返回0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= num; i++) &#123;</span><br></pre></td></tr></table></figure>
<p>这行代码是一个for循环，用于检查<code>num</code>是否可以被2到<code>sqrt(num)</code>之间的任何整数整除。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (num % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>如果<code>num</code>可以被<code>i</code>整除，那么<code>num</code>就不是素数，所以我们返回0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>num</code>不能被2到<code>sqrt(num)</code>之间的任何整数整除，那么<code>num</code>就是素数，所以我们返回1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br></pre></td></tr></table></figure>
<p>这行代码定义了程序的主函数<code>main</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br></pre></td></tr></table></figure>
<p>这行代码是一个for循环，用于遍历1到30的所有整数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (is_prime(i)) &#123;</span><br></pre></td></tr></table></figure>
<p>这行代码调用我们之前定义的<code>is_prime</code>函数，检查当前的整数<code>i</code>是否为素数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br></pre></td></tr></table></figure>
<p>如果<code>i</code>是素数，我们就打印出来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些是闭合前面的if语句和for循环的大括号，以及表示<code>main</code>函数的结束，<code>return 0;</code>表示程序执行成功。</p>
<h2 id="section-1">2</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>这行代码包含了<code>stdio.h</code>头文件，它是C语言中提供输入/输出功能的库。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> &#123;</span><br></pre></td></tr></table></figure>
<p>这行代码定义了一个名为<code>sort</code>的函数，它接受一个整数指针<code>arr</code>和一个整数<code>n</code>作为参数。<code>arr</code>指向我们要排序的数组，<code>n</code>是数组的长度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br></pre></td></tr></table></figure>
<p>这两行代码是两个嵌套的for循环，用于遍历数组中的每一对元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (*(arr + i) &lt; *(arr + j)) &#123;</span><br></pre></td></tr></table></figure>
<p>这行代码检查当前的两个元素是否满足我们的排序条件（即第一个元素是否小于第二个元素）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> temp = *(arr + i);</span><br><span class="line">*(arr + i) = *(arr + j);</span><br><span class="line">*(arr + j) = temp;</span><br></pre></td></tr></table></figure>
<p>如果满足排序条件，我们就交换这两个元素的位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些是闭合前面的if语句和for循环的大括号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br></pre></td></tr></table></figure>
<p>这行代码定义了程序的主函数<code>main</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">6</span>];</span><br></pre></td></tr></table></figure>
<p>这行代码定义了一个长度为6的整数数组<code>arr</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入6个整数：\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这行代码打印出提示信息，告诉用户需要输入6个整数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, arr + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两行代码是一个for循环，用于从用户那里读取6个整数并存储在数组<code>arr</code>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sort(arr, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p>这行代码调用我们之前定义的<code>sort</code>函数，对数组<code>arr</code>进行排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;由大到小的顺序输出为：\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这行代码打印出提示信息，告诉用户接下来将按照由大到小的顺序输出这6个整数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(arr + i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两行代码是一个for循环，用于按照由大到小的顺序打印出这6个整数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这行代码表示<code>main</code>函数的结束，<code>return 0;</code>表示程序执行成功。</p>
]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>eNSP配置三层交换机</title>
    <url>//post/eNSP%E9%85%8D%E7%BD%AE%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA.html</url>
    <content><![CDATA[<h1 id="拓扑图">拓扑图</h1>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%8B%93%E6%89%91%E5%9B%BE.png"
alt="拓扑图" />
<figcaption aria-hidden="true">拓扑图</figcaption>
</figure>
<h1 id="配置过程">配置过程</h1>
<h2 id="sw1配置">SW1配置</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system-view  # 进入系统视图</span><br><span class="line">vlan batch 10  # 创建vlan10</span><br><span class="line">interface GigabitEthernet 0/0/2  # 进入与PC1相连的接口</span><br><span class="line">port link-type access # 开启访问模式</span><br><span class="line">port default vlan 10  # 分配vlan</span><br><span class="line">interface GigabitEthernet 0/0/1  # 进入与SW2相连的接口</span><br><span class="line">port link-type trunk # 开启trunk模式</span><br><span class="line">port trunk allow-pass vlan 10 20 # 允许vlan10、20通过这个trunk端口</span><br></pre></td></tr></table></figure>
<h2 id="sw2配置">SW2配置</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system-view  # 进入系统视图</span><br><span class="line">vlan batch 10 20 # 创建vlan10、20</span><br><span class="line">interface GigabitEthernet 0/0/1 # 进入与SW1相连的接口</span><br><span class="line">port link-type trunk # 开启trunk模式</span><br><span class="line">port trunk allow-pass vlan 10 20 # 允许vlan10、20通过这个trunk端口</span><br><span class="line">interface GigabitEthernet 0/0/2 # 进入与SW3相连的接口</span><br><span class="line">port link-type trunk # 开启trunk模式</span><br><span class="line">port trunk allow-pass vlan 10 20 # 允许vlan10、20通过这个trunk端口</span><br><span class="line">interface Vlanif 10  # 进入vlan10</span><br><span class="line">ip address 192.168.3.1 24 # 为vlan10设置IP</span><br><span class="line">interface Vlanif 20  # 进入vlan20</span><br><span class="line">ip address 192.168.6.1 24 # 为vlan20设置IP</span><br></pre></td></tr></table></figure>
<h2 id="sw3配置">SW3配置</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system-view  # 进入系统视图</span><br><span class="line">vlan batch 20  # 创建vlan10</span><br><span class="line">interface GigabitEthernet 0/0/2  # 进入与PC1相连的接口</span><br><span class="line">port link-type access # 开启访问模式</span><br><span class="line">port default vlan 20  # 分配vlan</span><br><span class="line">interface GigabitEthernet 0/0/1  # 进入与SW2相连的接口</span><br><span class="line">port link-type trunk # 开启trunk模式</span><br><span class="line">port trunk allow-pass vlan 10 20 # 允许vlan10、20通过这个trunk端口</span><br></pre></td></tr></table></figure>
<h1 id="测试">测试</h1>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/ping.png"
alt="ping" />
<figcaption aria-hidden="true">ping</figcaption>
</figure>
]]></content>
      <categories>
        <category>网络设备</category>
      </categories>
      <tags>
        <tag>eNSP</tag>
      </tags>
  </entry>
  <entry>
    <title>地毯模组（Carpet）的使用教程</title>
    <url>//post/%E5%9C%B0%E6%AF%AF%E6%A8%A1%E7%BB%84%EF%BC%88Carpet%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html</url>
    <content><![CDATA[<p>Carpet中文百科</p>
<p><a href="https://www.mcmod.cn/class/2361.html">Carpet -
MC百科|最大的Minecraft中文MOD百科 (mcmod.cn)</a></p>
<p>本文仅从以上链接中的教程总结出较为常用的命令</p>
<h1 id="player">/player</h1>
<p>/player命令可以控制在线玩家或者假玩家。</p>
<h2 id="生成与清除">生成与清除</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/player &lt;target&gt; spawn</span><br></pre></td></tr></table></figure>
<p>该命令会在玩家所在位置生成一个名为<target>的玩家，无论是否真实存在，并且保持与执行者一样的视角和游戏模式。</p>
<p>如果生成的玩家真实存在，则该玩家上线时将顶替掉生成的假玩家，并恢复原先的游戏模式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/player &lt;target&gt; kill</span><br></pre></td></tr></table></figure>
<p>该命令会使假玩家退出当前存档或者服务器，同时保留他身上的物品。</p>
<p>该命令只对假玩家有效。</p>
<p>如果原版游戏规则keepInventory设为false，击杀生存模式的假玩家会使该玩家掉落身上的所有物品。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/player &lt;target&gt; shadow</span><br></pre></td></tr></table></figure>
<p>该命令会将目标玩家踢出存档或服务器，并在他的相同位置生成一个名称相同的假玩家。</p>
<p>该命令只对当前正在游玩的真玩家有效。</p>
<h2 id="移动">移动</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/player &lt;target&gt; look &lt;direction&gt;</span><br></pre></td></tr></table></figure>
<p>该命令会让玩家看向一定的方向。&lt;direction&gt;可以是：</p>
<ul>
<li>north（北）、south（南）、west（西）、east（东）、up（上）、down（下）；</li>
<li>at：让玩家看向某个位置。后面还需要跟玩家要看向的位置的坐标。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/player &lt;target&gt; move &lt;direction&gt;</span><br></pre></td></tr></table></figure>
<p>该命令会让玩家按照指定的方向持续移动。&lt;direction&gt;可以是backward（后），forward（前），left（左），right（右）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/player &lt;target&gt; jump [&lt;option&gt;]</span><br></pre></td></tr></table></figure>
<p>该命令会让玩家跳跃一次。</p>
<p>可以使用[&lt;option&gt;]参数指定跳跃模式。[&lt;option&gt;]可以是：</p>
<ul>
<li>continuous：让玩家连续跳跃。</li>
<li>interval：让玩家每隔一定游戏刻跳跃一次。该参数要求后面再跟一个参数，指定跳跃间隔的游戏刻数。</li>
<li>once：让玩家跳跃一次，与默认情况相同。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/player &lt;target&gt; sneak</span><br><span class="line">/player &lt;target&gt; unsneak</span><br></pre></td></tr></table></figure>
<p>这两个命令可以分别让玩家潜行和取消潜行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/player &lt;target&gt; sprint</span><br><span class="line">/player &lt;target&gt; unsprint</span><br></pre></td></tr></table></figure>
<p>这两个命令可以分别让玩家疾跑和停止疾跑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/player &lt;target&gt; turn &lt;option&gt;</span><br></pre></td></tr></table></figure>
<p>该命令可以让玩家的视角旋转。&lt;option&gt;可以是：</p>
<ul>
<li>back（转向身后），left（左转90°），right（右转90°）。</li>
<li>两个浮点数：具体控制旋转的角度。第一个数字控制视角的俯仰（正为俯视，负为仰视），第二个数字控制视角的水平角度（正为右转，负为左转）。例如，
/player &lt;target&gt; turn -45 90 会让玩家的视角上扬45°并右转90°。</li>
</ul>
<p>更多教程看</p>
<p><a href="https://www.mcmod.cn/item/list/2361-10.html">游戏设定 -
Carpet - MC百科|最大的Minecraft中文MOD百科 (mcmod.cn)</a></p>
]]></content>
      <categories>
        <category>Minecraft</category>
      </categories>
      <tags>
        <tag>我的世界mod教程</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql常用命令</title>
    <url>//post/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    <content><![CDATA[<p>1.连接数据库 mysql -u用户名 -p密码</p>
<p>2.显示已有数据库 show databases;</p>
<p>3.创建数据库 create database sqlname;</p>
<p>4.选择数据库 use database sqlname;</p>
<p>5.显示数据库中的表（先选择数据库） show tables;</p>
<p>6.显示当前数据库的版本信息以及连接用户名 select version(),user();</p>
<p>7.删除数据库(删除时没有提示直接删除) drop database sqlname;delete
from user where uesr='' [删除匿名用户]</p>
<p>create user '用户名'@'IP地址' identified by '密码' [创建新用户]</p>
<p>grant all privileges on 数据库.数据表 to '用户名'@'IP地址' identified
by '密码' [赋予用户权限，all=全部]</p>
<p>grant select,insert,update,delete on 数据库.数据表 to '用户名'@'地址'
identified by '密码' [赋予用户指定权限]</p>
<p>drop user 用户@IP地址; [删除用户]</p>
<p>msfdb init （初始化数据库） insert into 表名(字段1,字段2,......)
values(数据1,数据2,......)[插入数据]</p>
<p>update 表名 set 列=列('要修改的内容') where 对应列='对应列内容'
select * from 表名（查看数据表内容） create tables 表名; (创建表)</p>
<p>show tables;（查看数据表）</p>
<p>show create table 表名;（查看数据表创建语句）</p>
<p>desc 表名;（查看表的字段信息）</p>
<p>alter table 表名 rename 新表名;（修改表名）</p>
<p>alter table 表名 change 字段名 新字段名 属性;（修改字段名）</p>
<p>alter table 表名 modify id int(20);（修改字段的数据类型）</p>
<p>alter table 表名 add 字段名 属性;（添加字段）</p>
<p>alter table 表名 drop 字段名;（删除字段） alter table 表名 modify
字段名 属性 字段;（修改字段的位置）</p>
<p>表的约束：</p>
<table>
<thead>
<tr class="header">
<th>约束条件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>PRIMARY KEY</td>
<td>主键约束，用于唯一标识对应的记录</td>
</tr>
<tr class="even">
<td>FOREIGN KEY</td>
<td>外键约束</td>
</tr>
<tr class="odd">
<td>NOT NULL</td>
<td>非空约束</td>
</tr>
<tr class="even">
<td>UNIQUE</td>
<td>唯一性约束</td>
</tr>
<tr class="odd">
<td>DEFAULT</td>
<td>默认值约束，用于设置字段的默认值</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>华为交换机基础配置</title>
    <url>//post/%E5%8D%8E%E4%B8%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE.html</url>
    <content><![CDATA[<h1 id="基础配置命令">基础配置命令</h1>
<p>启动后进入交换机</p>
<h2 id="设置中文提示">设置中文提示</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">language-mode Chinese</span><br></pre></td></tr></table></figure>
<h2 id="进入系统视图">进入系统视图</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system-view</span><br></pre></td></tr></table></figure>
<h2 id="用户权限">用户权限</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user privilege level 15</span><br></pre></td></tr></table></figure>
<h2 id="进入console配置">进入console配置</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user-interface console 0</span><br></pre></td></tr></table></figure>
<h2 id="设置console密码">设置console密码</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">authentication-mode password</span><br><span class="line">set authentication password simple Huawei</span><br></pre></td></tr></table></figure>
<h2 id="设置登录前后标语">设置登录前后标语</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">header login information &quot;This is SW1&quot;</span><br><span class="line">header shell information &quot;login succeed&quot;</span><br></pre></td></tr></table></figure>
<h2 id="创建与划分vlan">创建与划分vlan</h2>
<h3 id="创建vlan">创建vlan</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vlan batch 10 20</span><br></pre></td></tr></table></figure>
<h3 id="进入端口并划分vlan">进入端口并划分vlan</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface GigabitEthernet 0/0/1</span><br><span class="line">port link-type access</span><br><span class="line">port default vlan 10</span><br></pre></td></tr></table></figure>
<h2 id="设置vlan-ip">设置vlan IP</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface vlanif 10</span><br><span class="line">ip address 192.168.10.1 24</span><br></pre></td></tr></table></figure>
<h2 id="查看配置结果">查看配置结果</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display current-configuration</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络设备</category>
      </categories>
      <tags>
        <tag>eNSP</tag>
      </tags>
  </entry>
  <entry>
    <title>imgTP图床测试</title>
    <url>//post/imgTP%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95.html</url>
    <content><![CDATA[<p>我是OP</p>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/%E6%B2%B9%E7%94%BBLH.jpg"
alt="OP图片" />
<figcaption aria-hidden="true">OP图片</figcaption>
</figure>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用tmux（终端工具）</title>
    <url>//post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tmux%EF%BC%88%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%EF%BC%89.html</url>
    <content><![CDATA[<h1 id="什么是tmux">什么是tmux</h1>
<p>Tmux 是一个终端复用器（terminal multiplexer）</p>
<p>tmux 有主要两个用途：</p>
<ol type="1">
<li>分屏。既可以同时使用多个命令行；</li>
<li>会话与窗口解绑。当窗口意外关闭时，会话并不会终止，后面需要的时候，会话可以再次绑定窗口。尤其当使用SSH远程登录计算机时，可以不受断网的影响。</li>
</ol>
<h1 id="基本使用">基本使用</h1>
<h2 id="安装tmux">安装tmux</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Ubantu or Debian</span></span><br><span class="line">sudo apt-get install tmux</span><br><span class="line"></span><br><span class="line"><span class="comment"># Centos or Fedora</span></span><br><span class="line">sudo yum install tmux</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mac</span></span><br><span class="line">brew install tmux</span><br></pre></td></tr></table></figure>
<h2 id="启动退出">启动、退出</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux</span><br></pre></td></tr></table></figure>
<p>在终端输入以上命令即可启动tmux，启动后终端底部会显示一个状态栏。</p>
<p>左侧是窗口信息（编号和名称），右侧是系统信息。</p>
<figure>
<img
src="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tmux%EF%BC%88%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%EF%BC%89/image-20230606181115946.png"
alt="image-20230606181115946" />
<figcaption aria-hidden="true">image-20230606181115946</figcaption>
</figure>
<p>按下<code>Ctrl + d</code>或者在终端输入<code>exit</code>即可退出tmux。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<h2 id="tmux术语">tmux术语</h2>
<p>tmux 采用 client/server模型，主要有四个模块：</p>
<ul>
<li>server：服务。tmux运行的基础服务，以下模块均依赖于此服务；</li>
<li>session：会话。一个服务可以包含多个会话；</li>
<li>window：窗口。一个会话可以包含多个窗口；</li>
<li>panel：窗格/面板。一个窗口可以包含多个窗格。</li>
</ul>
<p>执行 tmux
命令时，即开启了一个服务，并创建了一个会话、窗口和窗格。</p>
<h2 id="前缀键">前缀键</h2>
<p>Tmux
窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是<code>Ctrl+b</code>，即先按下<code>Ctrl+b</code>，快捷键才会生效。</p>
<p>举例来说，帮助命令的快捷键是<code>Ctrl+b ?</code>。它的用法是，在
Tmux
窗口中，先按下<code>Ctrl+b</code>，再按下<code>?</code>，就会显示帮助信息。</p>
<p>然后，按下 ESC 键或<code>q</code>键，就可以退出帮助。</p>
<h1 id="tmux会话管理">Tmux会话管理</h1>
<h2 id="新建会话">新建会话</h2>
<p>第一个启动的 Tmux 窗口，编号是 <code>0</code>，第二个窗口的编号是
<code>1</code>，以此类推。这些窗口对应的会话，就是 0 号会话、1
号会话。</p>
<p>使用编号区分会话，不太直观，更好的方法是为会话起名。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux new -s &lt;your-session-name&gt;</span><br></pre></td></tr></table></figure>
<p>上面命令新建一个指定名称的会话。</p>
<h2 id="分离会话">分离会话</h2>
<p>在 Tmux 窗口中，按下 <code>Ctrl+b d</code> 或者输入
<code>tmux detach</code> 命令，就会将当前会话与窗口分离。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux detach</span><br></pre></td></tr></table></figure>
<p>上面命令执行后，就会退出当前 Tmux
窗口，但是会话和里面的进程仍然在后台运行。</p>
<p><code>tmux ls</code> 命令可以查看当前所有的 Tmux 会话。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">tmux list-session</span><br></pre></td></tr></table></figure>
<figure>
<img
src="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tmux%EF%BC%88%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%EF%BC%89/image-20230606182214934.png"
alt="image-20230606182214934" />
<figcaption aria-hidden="true">image-20230606182214934</figcaption>
</figure>
<h2 id="接入会话">接入会话</h2>
<p>在终端输入<code>tmux attach</code>用于重新接入某个已存在的会话。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用会话编号接入会话</span></span><br><span class="line">tmux attach -t 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用会话名称接入会话</span></span><br><span class="line">tmux attach -t &lt;your-session-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="kill会话">kill会话</h2>
<p>在终端输入<code>tmux kill-session</code>用于杀死某个已存在的会话。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用会话编号结束会话</span></span><br><span class="line">tmux kill-sesion -t 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用会话名称结束会话</span></span><br><span class="line">tmux kill-sesion -t &lt;your-session-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="切换会话">切换会话</h2>
<p>在终端输入<code>tmux switch</code>以切换会话。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用会话编号切换会话</span></span><br><span class="line">tmux switch -t 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用会话名称切换会话</span></span><br><span class="line">tmux switch -t &lt;session-name&gt;</span><br></pre></td></tr></table></figure>
<h2 id="重命名会话">重命名会话</h2>
<p>在终端输入<code>tmux rename-session</code>以重命名会话。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux rename-session -t 0 &lt;new-name&gt;</span><br></pre></td></tr></table></figure>
<p>以上命令会将<code>0</code>号会话重命名。</p>
<h1 id="快捷键">快捷键</h1>
<p>tmux大部分操作都可以用快捷键来代替。</p>
<p>使用快捷键的前提是先按下了<code>Ctrl + b</code></p>
<p>使用<code>tmux list-keys</code>可以列出所有快捷键。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tmux list-keys</span><br></pre></td></tr></table></figure>
<h2 id="会话快捷键">会话快捷键</h2>
<ul>
<li>s ：列出所有会话，也可以在列表中用鼠标或上下键切换会话</li>
<li>d ：离开当前会话</li>
<li>$ ：重命名当前会话</li>
</ul>
<h2 id="窗口快捷键">窗口快捷键</h2>
<ul>
<li>c ： 创建一个新窗口</li>
<li>n ： 切换到下一个窗口</li>
<li>w ： 从列表中选择窗口</li>
<li>&lt;0~9&gt; ： 切换到指定标号的窗口，编号显示在状态栏</li>
<li>,（这是一个英文逗号） : 将窗口重命名</li>
</ul>
<p>一个<code>session</code>中可以有很多个窗口，可以在状态栏中查看，如：</p>
<figure>
<img
src="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tmux%EF%BC%88%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%EF%BC%89/image-20230606184635853.png"
alt="image-20230606184635853" />
<figcaption aria-hidden="true">image-20230606184635853</figcaption>
</figure>
<p>其中：</p>
<p><code>[key]</code>表示的是当前会话的名称。</p>
<p><code>0：zsh-</code>表示的是0号窗口，<code>zsh</code>是窗口的名字。</p>
<p>窗口名字后的<code>*</code>号代表当前显示的窗口。</p>
<p>而右侧显示的是用户名、当前时间、当前日期。</p>
<h2 id="窗格快捷键">窗格快捷键</h2>
<ul>
<li>% ： 将窗口分成<strong>左右</strong>两个窗格。</li>
<li>"（这是一个英文双引号）：
将窗口分成<strong>上下</strong>两个窗格。</li>
<li>z ： 将当前窗格<strong>全屏显示</strong>，再按一次恢复。</li>
<li>q ： 显示窗格编号。</li>
<li>t ： 再当前窗格显示时间。</li>
<li>o ： 将光标切换到下个一个窗格。</li>
<li>&lt;arrow key&gt; ：
将光标切换到其他窗格。使用<strong>上下左右方向键</strong>进行切换</li>
<li>{ ： 将当前窗格<strong>左移</strong>。</li>
<li>} ： 将当前窗格<strong>右移</strong>。</li>
<li>Ctrl + o ： 将当前窗格<strong>上移</strong>。</li>
<li>Alt + o ： 将当前窗格<strong>下移</strong>。</li>
<li>space（空格键） ： 切换窗格布局。</li>
<li>x ： 删除当前窗格。</li>
</ul>
<h1 id="配置tmux支持鼠标">配置tmux支持鼠标</h1>
<p>鼠标支持的内容：</p>
<ul>
<li>用鼠标点击窗格来激活该窗格；</li>
<li>用鼠标拖动调节窗格的大小（拖动位置是窗格之间的分隔线）；</li>
<li>用鼠标点击来切换活动窗口（点击位置是状态栏的窗口名称）；</li>
<li>开启窗口/窗格里面的鼠标支持，用鼠标回滚显示窗口内容，按下shift的同时用鼠标选取文本，使用
ctrl+shift+c、ctrl+shift+v 的方式进行复制粘贴。</li>
</ul>
<p>配置方式为在 ~/.tmux.conf 文件中，增加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">set-option -g mouse on</span><br></pre></td></tr></table></figure>
<h1 id="参考文章">参考文章</h1>
<ol type="1">
<li><a
href="https://zhuanlan.zhihu.com/p/137715607">https://zhuanlan.zhihu.com/p/137715607</a></li>
<li><a
href="https://www.cnblogs.com/niuben/p/15983908.html">https://www.cnblogs.com/niuben/p/15983908.html</a></li>
<li><a
href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">https://www.ruanyifeng.com/blog/2019/10/tmux.html</a></li>
<li><a
href="https://blog.csdn.net/CSSDCC/article/details/121231906">https://blog.csdn.net/CSSDCC/article/details/121231906</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>如何正确的食用Docker</title>
    <url>//post/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%A3%9F%E7%94%A8Docker.html</url>
    <content><![CDATA[<h1 id="docker简介">Docker简介</h1>
<h2 id="什么是docker">什么是Docker？</h2>
<p>Docker 是一个开源的应用容器引擎，基于 <a
href="https://www.runoob.com/go/go-tutorial.html">Go 语言</a> 并遵从
Apache2.0 协议开源。</p>
<p>Docker
可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的
Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的
app）,更重要的是容器性能开销极低。</p>
<h2 id="docker能干嘛">Docker能干嘛？</h2>
<p>软件开发最大的麻烦事之一，就是环境配置。而Docker可以十分方便的配置它们。</p>
<p>传统的虚拟机技术启动应用服务往往需要数分钟，而 <code>Docker</code>
容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>
<h2 id="docker的三个基本概念">Docker的三个基本概念</h2>
<p>Docker 包括三个基本概念：</p>
<ul>
<li><strong>镜像（image）</strong>：Docker
镜像（image），相当于是一个root文件系统。例如官方镜像 Ubuntu: 16.04
就包含了完整的一套 Ubuntu 16.04 最小系统的root文件系统。</li>
<li><strong>容器（Container）</strong>：容器（Container）<strong>由</strong>
Docker 镜像（image）生成。一旦容器生成，就会同时存在两个文件： image
文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</li>
<li><strong>仓库（Repository）</strong>：镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a
href="https://docker-practice.github.io/zh-cn/repository/registry.html">Docker
Registry</a> 就是这样的服务。</li>
</ul>
<h1 id="安装docker">安装Docker</h1>
<p>Docker 分为 <code>stable</code> <code>test</code> 和
<code>nightly</code> 三个更新频道。</p>
<p><a href="https://docs.docker.com/get-docker/">Get Docker | Docker
Documentation</a></p>
<h2 id="在ubuntu安装docker">在Ubuntu安装Docker</h2>
<p>Docker 支持以下版本的 <a href="https://ubuntu.com/server">Ubuntu</a>
操作系统：</p>
<ul>
<li>Ubuntu Hirsute 21.04</li>
<li>Ubuntu Groovy 20.10</li>
<li>Ubuntu Focal 20.04 (LTS)</li>
<li>Ubuntu Bionic 18.04 (LTS)</li>
</ul>
<p>Docker 可以安装在 64 位的 x86 平台或 ARM 平台上。Ubuntu
发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5
年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS
版本。</p>
<h3 id="卸载旧版本docker">卸载旧版本Docker</h3>
<p>旧版本的 Docker 称为 <code>docker</code> 或者
<code>docker-engine</code>，使用以下命令卸载旧版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove docker \</span><br><span class="line">             docker-engine \</span><br><span class="line">             docker.io</span><br></pre></td></tr></table></figure>
<h3 id="使用-apt-安装">使用 APT 安装</h3>
<p>由于 <code>apt</code> 源使用 HTTPS
以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS
传输的软件包以及 CA 证书。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get udate</span><br><span class="line"></span><br><span class="line">sudo apt-get install \</span><br><span class="line">	apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br></pre></td></tr></table></figure>
<p>为了确认所下载软件包的合法性，需要添加软件源的 <code>GPG</code>
密钥。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure>
<p>向<code>sources.list</code>中添加 Docker 软件源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line"><span class="comment"># $ echo \</span></span><br><span class="line"><span class="comment">#   &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="comment">#   $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span></span><br></pre></td></tr></table></figure>
<h3 id="安装-docker">安装 Docker</h3>
<p>更新 apt 软件包缓存，并安装 <code>docker-ce</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>
<h3 id="启动-docker">启动 Docker</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<h3 id="建立-docker-用户组">建立 Docker 用户组</h3>
<p>默认情况下，<code>docker</code> 命令会使用 <a
href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a>
与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code>
组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux
系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用
<code>docker</code> 的用户加入 <code>docker</code> 用户组。</p>
<p>建立<code>docker</code>组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure>
<p>将当前用户加入<code>docker</code>组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>
<h2 id="在centos安装docker">在CentOS安装Docker</h2>
<p>切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker</p>
<p>Docker 支持 64 位版本 CentOS 7/8，并且要求内核版本不低于 3.10。
CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如
<code>overlay2</code>
存储层驱动）无法使用，并且部分功能可能不太稳定。</p>
<h3 id="卸载旧版本docker-1">卸载旧版本Docker</h3>
<p>旧版本的 Docker 称为 <code>docker</code> 或者
<code>docker-engine</code>，使用以下命令卸载旧版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                docker-client \</span><br><span class="line">                docker-client-latest \</span><br><span class="line">                docker-common \</span><br><span class="line">                docker-latest \</span><br><span class="line">                docker-latest-logrotate \</span><br><span class="line">                docker-logrotate \</span><br><span class="line">                docker-selinux \</span><br><span class="line">                docker-engine-selinux \</span><br><span class="line">                docker-engine</span><br></pre></td></tr></table></figure>
<h3 id="使用-yum-安装">使用 yum 安装</h3>
<p>安装依赖包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure>
<p>添加<code>yum</code>软件源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">	--add-repp \</span><br><span class="line">	https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">sudo sed -i <span class="string">&#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27;</span> /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 官方源</span></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">	--add-repp</span><br><span class="line">	https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>如需测试版本的Docker：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --<span class="built_in">enable</span> docker-ce-test</span><br></pre></td></tr></table></figure>
<h3 id="安装-docker-1">安装 Docker</h3>
<p>更新 <code>yum</code> 软件源缓存，并安装 <code>docker-ce</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>
<h3 id="centos8的额外设置">CentOS8的额外设置</h3>
<p>由于 CentOS8 防火墙使用了 <code>nftables</code>，但 Docker 尚未支持
<code>nftables</code>， 我们可以使用如下设置使用
<code>iptables</code>：</p>
<p>更改 <code>/etc/firewalld/firewalld.conf</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># FirewallBackend=nftables</span></span><br><span class="line">FirewallBackend=iptables</span><br></pre></td></tr></table></figure>
<p>或执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=trusted --add-interface=docker0</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>
<h3 id="启动-docker-1">启动 Docker</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<h3 id="建立-docker-用户组-1">建立 Docker 用户组</h3>
<p>默认情况下，<code>docker</code> 命令会使用 <a
href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a>
与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code>
组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux
系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用
<code>docker</code> 的用户加入 <code>docker</code> 用户组。</p>
<p>建立 <code>docker</code> 组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure>
<p>将当前用户加入<code>docker</code>组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo usermod -aG docekr <span class="variable">$USER</span></span><br></pre></td></tr></table></figure>
<h3 id="添加内核参数">添加内核参数</h3>
<p>如果在 CentOS 使用 Docker 看到下面的这些警告信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">WARNING: bridge-nf-call-iptables is disabled</span><br><span class="line">WARNING: bridge-nf-call-ip6tables is disabled</span><br></pre></td></tr></table></figure>
<p>添加内核配置参数以启用这些功能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">tee</span> -a /etc/sysctl.conf &lt;&lt;-<span class="string">EOF</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>
<p>重新加载<code>sysctl.conf</code>即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sysctl -p</span><br></pre></td></tr></table></figure>
<h1 id="docker食用指南">Docker食用指南</h1>
<h2 id="镜像使用指南">镜像使用指南</h2>
<p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker
会从镜像仓库下载该镜像。</p>
<h3 id="获取镜像">获取镜像</h3>
<p>从 Docker 镜像仓库获取镜像的命令是
<code>docker pull</code>。命令格式是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure>
<p><strong>参数说明：</strong></p>
<ul>
<li>TAG：标签（版本）</li>
<li>DIGEST：摘要</li>
<li>OPTIONS：
<ul>
<li>-a ：下载镜像仓库中所有的指定镜像；</li>
<li>–disable-content-trust：跳过镜像验证（默认值是true）；</li>
<li>–platform： 如果服务具有多平台功能，则设置平台；</li>
<li>-q：一直详细输出；</li>
</ul></li>
</ul>
<p>具体选项可以通过<code>docker pull --help</code>命令查看。</p>
<p><strong>例子如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker pull ubuntu:18.04</span><br><span class="line">18.04: Pulling from library/ubuntu</span><br><span class="line">92dc2a97ff99: Pull complete</span><br><span class="line">be13a9d27eb8: Pull complete</span><br><span class="line">c8299583700a: Pull complete</span><br><span class="line">Digest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> ubuntu:18.04</span><br><span class="line">docker.io/library/ubuntu:18.04</span><br></pre></td></tr></table></figure>
<p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub
（<code>docker.io</code>）获取镜像。而镜像名称是
<code>ubuntu:18.04</code>，因此将会获取官方镜像
<code>library/ubuntu</code> 仓库中标签为 <code>18.04</code>
的镜像。<code>docker pull</code>
命令的输出结果最后一行给出了镜像的完整名称，即：
<code>docker.io/library/ubuntu:18.04</code>。</p>
<ul>
<li>Docker
镜像仓库地址：地址的格式一般是<code>域名/IP[:端口号]</code>。默认地址是
Docker Hub（<code>docker.io</code>）。</li>
<li>仓库名：仓库名是两段式名称，即<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于
Docker
Hub，如果没有指定用户名，则默认是<code>library</code>，也就是官方镜像。</li>
</ul>
<h4 id="运行">运行</h4>
<p>有了镜像后，可以以这个镜像为基础启动并运行一个容器。以上面的<code>Ubuntu:18.04</code>为例，如果打算启动里面的<code>bash</code>并且进行交互式操作的话，可以执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -it --<span class="built_in">rm</span> ubuntu:18:04 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是容器内操作</span></span><br><span class="line">root@e7009c6ce357:/<span class="comment"># cat /etc/os-release</span></span><br><span class="line">NAME=<span class="string">&quot;Ubuntu&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;18.04.1 LTS (Bionic Beaver)&quot;</span></span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME=<span class="string">&quot;Ubuntu 18.04.1 LTS&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;18.04&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;https://www.ubuntu.com/&quot;</span></span><br><span class="line">SUPPORT_URL=<span class="string">&quot;https://help.ubuntu.com/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.launchpad.net/ubuntu/&quot;</span></span><br><span class="line">PRIVACY_POLICY_URL=<span class="string">&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span></span><br><span class="line">VERSION_CODENAME=bionic</span><br><span class="line">UBUNTU_CODENAME=bionic</span><br></pre></td></tr></table></figure>
<p><code>docker run</code>就是要运行容器的命令，这里简单说明一下上面用到的参数</p>
<ul>
<li><code>-it</code>：这是两个参数，一个是
<code>-i</code>：交互式操作，一个是 <code>-t</code>
终端。我们这里打算进入 <code>bash</code>
执行一些命令并查看返回结果，因此我们需要交互式终端。</li>
<li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动
<code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用
<code>--rm</code> 可以避免浪费空间。</li>
<li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code>
镜像为基础来启动容器。</li>
<li><code>bash</code>：放在镜像名后的是
<strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是
<code>bash</code>。</li>
</ul>
<p>进入容器后就可以在 Shell
下操作执行任何所需的命令。例如，上面就执行了<code>cat /etc/os-release</code>，这是Linux常用的查看当前系统版本的命令，从返回的结果可以看到容器内是<code>Ubuntu 18.04.1 LTS</code>系统。</p>
<p>最后可以通过<code>exit</code>退出这个容器。</p>
<h3 id="列出镜像">列出镜像</h3>
<p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code>
命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span></span><br><span class="line">REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis                latest              5f515359c7f8        5 days ago          183 MB</span><br><span class="line">nginx                latest              05a60462f8ba        5 days ago          181 MB</span><br><span class="line">mongo                3.2                 fe9198c04d62        5 days ago          342 MB</span><br><span class="line">&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB</span><br><span class="line">ubuntu               18.04               329ed837d508        3 days ago          63.3MB</span><br><span class="line">ubuntu               bionic              329ed837d508        3 days ago          63.3MB</span><br></pre></td></tr></table></figure>
<p>列表包含了
<code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code>
以及 <code>所占用的空间</code>。</p>
<p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong>镜像
ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个
<strong>标签</strong>。因此，在上面的例子中，我们可以看到
<code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的
ID，因为它们对应的是同一个镜像。</p>
<h4 id="镜像体积">镜像体积</h4>
<p>Docker
Hub上显示的镜像体积是压缩后的体积大小，在镜像上传和下载的过程中镜像是保持压缩状态的。而使用命令<code>docker image ls</code>显示的是镜像下载到本地后展开的大小，准确说，是展开后的各层所占空间的总和。</p>
<p>另外一个需要注意的问题是，<code>docker image ls</code>
列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker
镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。相同的层只需要保存一份即可。</p>
<p>通过<code>docker system df</code>命令来查看镜像、容器、数据卷所占用的空间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker system <span class="built_in">df</span></span><br><span class="line">TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE</span><br><span class="line">Images          2         1         390.2MB   390.2MB (99%)</span><br><span class="line">Containers      1         0         0B        0B</span><br><span class="line">Local Volumes   0         0         0B        0B</span><br><span class="line">Build Cache     18        0         789B      789B</span><br></pre></td></tr></table></figure>
<h4 id="列出部分镜像">列出部分镜像</h4>
<p>不加任何参数的情况下，<code>docker image ls</code>
会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code>
有好几个参数可以帮助做到这个事情。</p>
<p>根据仓库名列出仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> ubuntu</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">ubuntu       latest    ba6acccedd29   23 months ago   72.8MB</span><br><span class="line">ubuntu       18.04     5a214d77f5d7   23 months ago   63.1MB</span><br></pre></td></tr></table></figure>
<p>列出特定的某个镜像，也就是说指定仓库名和标签</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">ls</span> ubuntu:18.04</span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">ubuntu       18.04     5a214d77f5d7   23 months ago   63.1MB</span><br></pre></td></tr></table></figure>
<h3 id="删除本地镜像">删除本地镜像</h3>
<p>如果要删除本地的镜像，可以使用 <code>docker image rm</code>
命令，其格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker image <span class="built_in">rm</span> [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure>
<p>其中，<code>&lt;镜像&gt;</code> 可以是
<code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者
<code>镜像摘要</code>。</p>
<p>我们可以用镜像的完整 ID，也称为
<code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长
ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code>
来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID
了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p>
<h2 id="操作容器">操作容器</h2>
<h4 id="启动容器">启动容器、</h4>
<p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p>
<p>因为 Docker
的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p>
<h1 id="未完待续">未完待续</h1>
<h1 id="参考文章">参考文章</h1>
<p>更多详细教程请参考 <a
href="https://docker-practice.github.io/zh-cn/">前言 · Docker --
从入门到实践 (docker-practice.github.io)</a></p>
<p><a
href="https://blog.csdn.net/zhuzicc/article/details/118066353">Docker
“pull“命令获取镜像，讲道理你真的会吗？_docker
pull_zhuzicc的博客-CSDN博客</a></p>
<p><a href="https://www.runoob.com/docker/docker-tutorial.html">Docker
教程 | 菜鸟教程 (runoob.com)</a></p>
<p><a
href="https://zhuanlan.zhihu.com/p/435605760">全面的Docker快速入门教程 -
知乎 (zhihu.com)</a></p>
<p><a
href="https://ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker
入门教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全工具大全</title>
    <url>//post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%85%A8.html</url>
    <content><![CDATA[<p><strong>资料来源 wx公众号：橘猫学安全</strong></p>
<h1 id="漏洞及渗透练习平台">漏洞及渗透练习平台</h1>
<h2 id="webgoat漏洞练习环境">WebGoat漏洞练习环境</h2>
<p>https://github.com/WebGoat/WebGoat</p>
<p>https://github.com/WebGoat/WebGoat-Legacy</p>
<h2 id="damn-vulnerable-web-application漏洞练习平台dvwa">Damn Vulnerable
Web Application(漏洞练习平台)DVWA</h2>
<p>https://github.com/RandomStorm/DVWA</p>
<h2 id="数据库注入练习平台">数据库注入练习平台</h2>
<p>https://github.com/Audi-1/sqli-labs</p>
<h2
id="用node编写的漏洞练习平台like-owasp-node-goat">用node编写的漏洞练习平台，like
OWASP Node Goat</h2>
<p>https://github.com/cr0hn/vulnerable-node</p>
<h1 id="花式扫描器">花式扫描器</h1>
<h2 id="端口扫描器nmap">端口扫描器Nmap</h2>
<p>https://github.com/nmap/nmap</p>
<h2 id="本地网络扫描器">本地网络扫描器</h2>
<p>https://github.com/SkyLined/LocalNetworkScanner</p>
<h2 id="子域名扫描器">子域名扫描器</h2>
<p>https://github.com/lijiejie/subDomainsBrute</p>
<h2 id="漏洞路由扫描器">漏洞路由扫描器</h2>
<p>https://github.com/jh00nbr/Routerhunter-2.0</p>
<h2 id="迷你批量信息泄漏扫描脚本">迷你批量信息泄漏扫描脚本</h2>
<p>https://github.com/lijiejie/BBScan</p>
<h2 id="waf类型检测工具">Waf类型检测工具</h2>
<p>https://github.com/EnableSecurity/wafw00f</p>
<h1 id="信息搜集工具">信息搜集工具</h1>
<h2
id="社工插件可查找以emailphoneusername的注册的所有网站账号信息">社工插件，可查找以email、phone、username的注册的所有网站账号信息</h2>
<p>https://github.com/n0tr00t/Sreg</p>
<h2
id="github信息搜集可实时扫描查询git最新上传有关邮箱账号密码信息">Github信息搜集，可实时扫描查询git最新上传有关邮箱账号密码信息</h2>
<p>https://github.com/sea-god/gitscan</p>
<h2 id="github-repo信息搜集工具">github Repo信息搜集工具</h2>
<p>https://github.com/metac0rtex/GitHarvester</p>
<h1 id="web工具">WEB工具</h1>
<h2 id="webshell大合集">webshell大合集</h2>
<p>https://github.com/tennc/webshell</p>
<h2 id="渗透以及web攻击脚本">渗透以及web攻击脚本</h2>
<p>https://github.com/brianwrf/hackUtils</p>
<h2 id="web渗透小工具大合集">web渗透小工具大合集</h2>
<p>https://github.com/rootphantomer/hacktoolsfor_me</p>
<h2 id="xss数据接收平台">XSS数据接收平台</h2>
<p>https://github.com/firesunCN/BlueLotus_XSSReceiver</p>
<h2 id="xss与csrf工具">XSS与CSRF工具</h2>
<p>https://github.com/evilcos/xssor</p>
<h2
id="short-for-command-injection-exploiterweb向命令注入检测工具">Short
for command injection exploiter，web向命令注入检测工具</h2>
<p>https://github.com/stasinopoulos/commix</p>
<h1 id="数据库注入工具">数据库注入工具</h1>
<h2 id="sqlmap">SQLmap</h2>
<p>https://github.com/sqlmapproject/sqlmap</p>
<h2
id="web代理通过加载sqlmap-api进行sqli实时检测">Web代理，通过加载sqlmap
api进行sqli实时检测</h2>
<p>https://github.com/zt2/sqli-hunter</p>
<h2 id="新版中国菜刀">新版中国菜刀</h2>
<p>https://github.com/Chora10/Cknife</p>
<h2 id="git泄露利用exp">.git泄露利用EXP</h2>
<p>https://github.com/lijiejie/GitHack</p>
<h2 id="浏览器攻击框架">浏览器攻击框架</h2>
<p>https://github.com/beefproject/beef</p>
<h2 id="自动化绕过waf脚本">自动化绕过WAF脚本</h2>
<p>https://github.com/khalilbijjou/WAFNinja</p>
<h2
id="http命令行客户端可以从命令行构造发送各种http请求类似于curl">http命令行客户端，可以从命令行构造发送各种http请求（类似于Curl）</h2>
<p>https://github.com/jkbrzt/httpie</p>
<h2 id="浏览器调试利器">浏览器调试利器</h2>
<p>https://github.com/firebug/firebug</p>
<h2 id="一款开源waf">一款开源WAF</h2>
<p>https://github.com/SpiderLabs/ModSecurity</p>
<h1 id="windows域渗透工具">windows域渗透工具</h1>
<h2 id="windows渗透神器">windows渗透神器</h2>
<p>https://github.com/gentilkiwi/mimikatz</p>
<h2 id="powershell渗透库合集">Powershell渗透库合集</h2>
<p>https://github.com/PowerShellMafia/PowerSploit</p>
<h2 id="powershell-tools合集">Powershell tools合集</h2>
<p>https://github.com/clymb3r/PowerShell</p>
<h1 id="fuzz">Fuzz</h1>
<h2 id="web向fuzz工具">Web向Fuzz工具</h2>
<p>https://github.com/xmendez/wfuzz</p>
<h2 id="http暴力破解撞库攻击脚本">HTTP暴力破解，撞库攻击脚本</h2>
<p>https://github.com/lijiejie/htpwdScan</p>
<h1 id="漏洞利用及攻击框架">漏洞利用及攻击框架</h1>
<h2 id="msf">msf</h2>
<p>https://github.com/rapid7/metasploit-framework</p>
<h2
id="poc调用框架可加载pocsuitetangscanbeebeeto等">Poc调用框架，可加载Pocsuite,Tangscan，Beebeeto等</h2>
<p>https://github.com/erevus-cn/pocscan</p>
<h2 id="pocsuite">Pocsuite</h2>
<p>https://github.com/knownsec/Pocsuite</p>
<h2 id="beebeeto">Beebeeto</h2>
<p>https://github.com/n0tr00t/Beebeeto-framework</p>
<h1 id="漏洞pocexp">漏洞POC&amp;EXP</h1>
<h2 id="exploitdb官方git版本">ExploitDB官方git版本</h2>
<p>https://github.com/offensive-security/exploit-database</p>
<h2 id="php漏洞代码分析">php漏洞代码分析</h2>
<p>https://github.com/80vul/phpcodz</p>
<h2 id="simple-test-for-cve-2016-2107">Simple test for
CVE-2016-2107</h2>
<p>https://github.com/FiloSottile/CVE-2016-2107</p>
<h2 id="cve-2015-7547-poc">CVE-2015-7547 POC</h2>
<p>https://github.com/fjserna/CVE-2015-7547</p>
<h2 id="java反序列化poc生成工具">JAVA反序列化POC生成工具</h2>
<p>https://github.com/frohoff/ysoserial</p>
<h2 id="java反序列化exp">JAVA反序列化EXP</h2>
<p>https://github.com/foxglovesec/JavaUnserializeExploits</p>
<h2 id="jenkins-commoncollections-exp">Jenkins CommonCollections
EXP</h2>
<p>https://github.com/CaledoniaProject/jenkins-cli-exploit</p>
<h2 id="cve-2015-2426-exp-windows内核提权">CVE-2015-2426 EXP
(windows内核提权)</h2>
<p>https://github.com/vlad902/hacking-team-windows-kernel-lpe</p>
<h2
id="use-docker-to-show-web-attackphp本地文件包含结合phpinfo-getshell-以及ssrf结合curl的利用演示">use
docker to show web attack(php本地文件包含结合phpinfo getshell
以及ssrf结合curl的利用演示)</h2>
<p>https://github.com/hxer/vulnapp</p>
<h2
id="php7缓存覆写漏洞demo及相关工具">php7缓存覆写漏洞Demo及相关工具</h2>
<p>https://github.com/GoSecure/php7-opcache-override</p>
<h2 id="xcodeghost木马样本">XcodeGhost木马样本</h2>
<p>https://github.com/XcodeGhostSource/XcodeGhost</p>
<h1 id="中间人攻击及钓鱼">中间人攻击及钓鱼</h1>
<h2 id="中间人攻击框架">中间人攻击框架</h2>
<p>https://github.com/secretsquirrel/the-backdoor-factory</p>
<p>https://github.com/secretsquirrel/BDFProxy</p>
<p>https://github.com/byt3bl33d3r/MITMf</p>
<p>Inject code, jam wifi, and spy on wifi users</p>
<p>https://github.com/DanMcInerney/LANs.py</p>
<h2 id="可扩展的中间人代理工具">可扩展的中间人代理工具</h2>
<p>https://github.com/intrepidusgroup/mallory</p>
<h2 id="wifi钓鱼">wifi钓鱼</h2>
<p>https://github.com/sophron/wifiphisher</p>
<h1 id="密码破解">密码破解</h1>
<h2 id="密码破解工具">密码破解工具</h2>
<p>https://github.com/shinnok/johnny</p>
<h2 id="本地存储的各类密码提取利器">本地存储的各类密码提取利器</h2>
<p>https://github.com/AlessandroZ/LaZagne</p>
<h1 id="二进制及代码分析工具">二进制及代码分析工具</h1>
<h2 id="二进制分析工具">二进制分析工具</h2>
<p>https://github.com/devttys0/binwalk</p>
<h2
id="系统扫描器用于寻找程序和库然后收集他们的依赖关系链接等信息">系统扫描器，用于寻找程序和库然后收集他们的依赖关系，链接等信息</h2>
<p>https://github.com/quarkslab/binmap</p>
<h2
id="rp-is-a-full-cpp-written-tool-that-aims-to-find-rop-sequences-in-peelfmach-o-doesnt-support-the-fat-binaries-x86x64-binaries.">rp++
is a full-cpp written tool that aims to find ROP sequences in
PE/Elf/Mach-O (doesn't support the FAT binaries) x86/x64 binaries.</h2>
<p>https://github.com/0vercl0k/rp</p>
<h2 id="windows-exploit-development工具">Windows Exploit
Development工具</h2>
<p>https://github.com/lillypad/badger</p>
<h2 id="二进制静态分析工具python">二进制静态分析工具（python）</h2>
<p>https://github.com/bdcht/amoco</p>
<h2 id="python-exploit-development-assistance-for-gdb">Python Exploit
Development Assistance for GDB</h2>
<p>https://github.com/longld/peda</p>
<h2 id="对billgates-linux-botnet系木马活动的监控工具">对BillGates Linux
Botnet系木马活动的监控工具</h2>
<p>https://github.com/ValdikSS/billgates-botnet-tracker</p>
<h2 id="木马配置参数提取工具">木马配置参数提取工具</h2>
<p>https://github.com/kevthehermit/RATDecoders</p>
<h2
id="shellphish编写的二进制分析工具ctf向">Shellphish编写的二进制分析工具（CTF向）</h2>
<p>https://github.com/angr/angr</p>
<h2 id="针对python的静态代码分析工具">针对python的静态代码分析工具</h2>
<p>https://github.com/yinwang0/pysonar2</p>
<h2
id="一个自动化的脚本shell分析工具用来给出警告和建议">一个自动化的脚本（shell）分析工具，用来给出警告和建议</h2>
<p>https://github.com/koalaman/shellcheck</p>
<h2
id="基于ast变换的简易javascript反混淆辅助工具">基于AST变换的简易Javascript反混淆辅助工具</h2>
<p>https://github.com/ChiChou/etacsufbo</p>
<h1 id="exp编写框架及工具">EXP编写框架及工具</h1>
<h2 id="二进制exp编写工具">二进制EXP编写工具</h2>
<p>https://github.com/t00sh/rop-tool</p>
<h2 id="ctf-pwn-类题目脚本编写框架">CTF Pwn 类题目脚本编写框架</h2>
<p>https://github.com/Gallopsled/pwntools</p>
<h2 id="an-easy-to-use-io-library-for-pwning-development">an easy-to-use
io library for pwning development</h2>
<p>https://github.com/zTrix/zio</p>
<h2
id="跨平台注入工具-inject-javascript-to-explore-native-apps-on-windows-mac-linux-ios-and-android.">跨平台注入工具（
Inject JavaScript to explore native apps on Windows, Mac, Linux, iOS and
Android.）</h2>
<p>https://github.com/frida/frida</p>
<h1 id="隐写相关工具">隐写相关工具</h1>
<h2 id="隐写检测工具">隐写检测工具</h2>
<p>https://github.com/abeluck/stegdetect</p>
<h1 id="各类安全资料">各类安全资料</h1>
<h2 id="域渗透教程">域渗透教程</h2>
<p>https://github.com/l3m0n/pentest_study</p>
<h2
id="python-security教程原文链接httpwww.primalsecurity.nettutorialspython-tutorials">python
security教程（原文链接http://www.primalsecurity.net/tutorials/python-tutorials/）</h2>
<p>https://github.com/smartFlash/pySecurity</p>
<h2 id="data_hacking合集">data_hacking合集</h2>
<p>https://github.com/ClickSecurity/data_hacking</p>
<h2 id="mobile-security-wiki">mobile-security-wiki</h2>
<p>https://github.com/exploitprotocol/mobile-security-wiki</p>
<h2
id="书籍reverse-engineering-for-beginners">书籍《reverse-engineering-for-beginners》</h2>
<p>https://github.com/veficos/reverse-engineering-for-beginners</p>
<h2 id="一些信息安全标准及设备配置">一些信息安全标准及设备配置</h2>
<p>https://github.com/luyg24/IT_security</p>
<h2 id="apt相关笔记">APT相关笔记</h2>
<p>https://github.com/kbandla/APTnotes</p>
<h2 id="kcon资料">Kcon资料</h2>
<p>https://github.com/knownsec/KCon</p>
<h2 id="ctf及黑客资源合集">ctf及黑客资源合集</h2>
<p>https://github.com/bt3gl/My-Gray-Hacker-Resources</p>
<h2 id="ctf和安全工具大合集">ctf和安全工具大合集</h2>
<p>https://github.com/zardus/ctf-tools</p>
<h2 id="do-not-fuck-with-a-hacker">《DO NOT FUCK WITH A HACKER》</h2>
<p>https://github.com/citypw/DNFWAH</p>
<h1 id="各类ctf资源">各类CTF资源</h1>
<h2 id="近年ctf-writeup大全">近年ctf writeup大全</h2>
<p>https://github.com/ctfs/write-ups-2016</p>
<p>https://github.com/ctfs/write-ups-2015</p>
<p>https://github.com/ctfs/write-ups-2014</p>
<h2 id="fbctf竞赛平台demo">fbctf竞赛平台Demo</h2>
<p>https://github.com/facebook/fbctf</p>
<h2 id="ctf-resources">ctf Resources</h2>
<p>https://github.com/ctfs/resources</p>
<h2 id="各类编程资源大礼包什么都有">各类编程资源大礼包（什么都有）</h2>
<p>https://github.com/bayandin/awesome-awesomeness</p>
<h2 id="bash-handbook">bash-handbook</h2>
<p>https://github.com/denysdovhan/bash-handbook</p>
<h2 id="python资源大全">python资源大全</h2>
<p>https://github.com/jobbole/awesome-python-cn</p>
<h2 id="git学习资料">git学习资料</h2>
<p>https://github.com/xirong/my-git</p>
<h2 id="安卓开源代码解析">安卓开源代码解析</h2>
<p>https://github.com/android-cn/android-open-project-analysis</p>
<h2 id="python框架库资源大合集">python框架，库，资源大合集</h2>
<p>https://github.com/vinta/awesome-python</p>
<h2 id="js-正则表达式库用于简化构造复杂的js正则表达式">JS
正则表达式库（用于简化构造复杂的JS正则表达式）</h2>
<p>https://github.com/VerbalExpressions/JSVerbalExpressions</p>
<h1 id="python">Python</h1>
<h2 id="python-正则表达式库用于简化构造复杂的python正则表达式">python
正则表达式库（用于简化构造复杂的python正则表达式）</h2>
<p>https://github.com/VerbalExpressions/PythonVerbalExpressions</p>
<h2 id="python任务管理以及命令执行库">python任务管理以及命令执行库</h2>
<p>https://github.com/pyinvoke/invoke</p>
<h2 id="python-exe打包库">python exe打包库</h2>
<p>https://github.com/pyinstaller/pyinstaller</p>
<h2 id="py3-爬虫框架">py3 爬虫框架</h2>
<p>https://github.com/orf/cyborg</p>
<h2
id="一个提供底层接口数据包编程和网络协议支持的python库">一个提供底层接口数据包编程和网络协议支持的python库</h2>
<p>https://github.com/CoreSecurity/impacket</p>
<h2 id="python-requests-库">python requests 库</h2>
<p>https://github.com/kennethreitz/requests</p>
<h2 id="python-实用工具合集">python 实用工具合集</h2>
<p>https://github.com/mahmoud/boltons</p>
<h2 id="python爬虫系统">python爬虫系统</h2>
<p>https://github.com/binux/pyspider</p>
<h2 id="ctf向-python工具包">ctf向 python工具包</h2>
<p>https://github.com/P1kachu/v0lt</p>
<h1 id="科学上网">科学上网</h1>
<h2 id="科学上网工具">科学上网工具</h2>
<p>https://github.com/XX-net/XX-Net</p>
<h1 id="老司机福利">老司机福利</h1>
<h2 id="微信自动抢红包动态库">微信自动抢红包动态库</h2>
<p>https://github.com/east520/AutoGetRedEnv</p>
<h2 id="微信抢红包插件安卓版">微信抢红包插件（安卓版）</h2>
<p>https://github.com/geeeeeeeeek/WeChatLuckyMoney</p>
<h2 id="神器">神器</h2>
<p>https://github.com/yangyangwithgnu/hardseed</p>
<h1 id="其他">其他</h1>
<p>以下内容来自：https://github.com/We5ter/Scanners-Box/blob/master/README_CN.md</p>
<h2 id="子域名枚举类">子域名枚举类</h2>
<p>https://github.com/lijiejie/subDomainsBrute
(经典的子域名爆破枚举脚本)</p>
<p>https://github.com/ring04h/wydomain (子域名字典穷举)</p>
<p>https://github.com/le4f/dnsmaper (子域名枚举与地图标记)</p>
<p>https://github.com/0xbug/orangescan (在线子域名信息收集工具)</p>
<p>https://github.com/TheRook/subbrute （根据DNS记录查询子域名)</p>
<p>https://github.com/We5ter/GoogleSSLdomainFinder
(基于谷歌SSL透明证书的子域名查询脚本)</p>
<p>https://github.com/mandatoryprogrammer/cloudflare_enum
（使用CloudFlare进行子域名枚举的脚本）</p>
<p>https://github.com/18F/domain-scan (A domain scanner）</p>
<p>https://github.com/Evi1CLAY/Cool ...
Python/DomainSeeker（多方式收集目标子域名信息）</p>
<h2 id="数据库漏洞扫描类">数据库漏洞扫描类</h2>
<p>https://github.com/0xbug/SQLiScanner
(一款基于SQLMAP和Charles的被动SQL注入漏洞扫描工具)</p>
<p>https://github.com/stamparm/DSSS
(99行代码实现的sql注入漏洞扫描器)</p>
<p>https://github.com/LoRexxar/Feigong（针对各种情况自由变化的MySQL注入脚本）</p>
<p>https://github.com/youngyangyang04/NoSQLAttack
(一款针对mongoDB的攻击工具)</p>
<p>https://github.com/Neohapsis/bbqsql（SQL盲注利用框架）</p>
<p>https://github.com/NetSPI/PowerUpSQL（攻击SQLSERVER的Powershell脚本框架）</p>
<h2 id="弱口令或信息泄漏扫描类">弱口令或信息泄漏扫描类</h2>
<p>https://github.com/lijiejie/htpwdScan
(一个简单的HTTP暴力破解、撞库攻击脚本)</p>
<p>https://github.com/lijiejie/BBScan
(一个迷你的信息泄漏批量扫描脚本)</p>
<p>https://github.com/lijiejie/GitHack (.git文件夹泄漏利用工具)</p>
<p>https://github.com/wilson9x1/fenghuangscanner_v3
(端口及弱口令检测)</p>
<p>https://github.com/ysrc/F-Scrack (对各类服务进行弱口令检测的脚本)</p>
<p>https://github.com/Mebus/cupp
（根据用户习惯生成弱口令探测字典脚本）</p>
<p>https://github.com/RicterZ/genpAss （中国特色的弱口令生成器）</p>
<p>https://github.com/netxfly/crack_ssh （go写的协程版的ssh）</p>
<h2 id="物联网设备扫描">物联网设备扫描</h2>
<p>https://github.com/rapid7/IoTSeeker
（物联网设备默认密码扫描检测工具)</p>
<p>https://github.com/shodan-labs/iotdb (使用nmap扫描IoT设备)</p>
<h2 id="xss扫描器">xss扫描器</h2>
<p>https://github.com/shawarkhanethicalhacker/BruteXSS （Cross-Site
Scripting Bruteforcer）</p>
<p>https://github.com/1N3/XSSTracer (A small python script to check for
Cross-Site Tracing)</p>
<p>https://github.com/0x584A/fuzzXssPHP (PHP版本的反射型xss扫描)</p>
<p>https://github.com/chuhades/xss_scan (批量扫描xss的python脚本）</p>
<h2 id="企业网络自检">企业网络自检</h2>
<p>https://github.com/sowish/LNScan （详细的内部网络信息扫描器）</p>
<p>https://github.com/ysrc/xunfeng (网络资产识别引擎，漏洞检测引擎）</p>
<p>https://github.com/SkyLined/LocalNetworkScanner
(javascript实现的本地网络扫描器)</p>
<p>https://github.com/laramies/theHarvester
（企业被搜索引擎收录敏感资产信息监控脚本：员工邮箱、子域名、Hosts）</p>
<p>https://github.com/x0day/Multisearch-v2
(bing、google、360、zoomeye等搜索引擎聚合搜索，可用于发现企业被搜索引擎收录的敏感资产信息）</p>
<h2 id="webshell检测">webshell检测</h2>
<p>https://github.com/We5ter/Scanners-Box/tree/master/Find_webshell/
（php后门检测，脚本较简单，因此存在误报高和效率低下的问题）</p>
<p>https://github.com/yassineaddi/BackdoorMan （A toolkit find
malicious, hidden and suspicious PHP scripts and shells in a chosen
destination）</p>
<h2 id="内网渗透">内网渗透</h2>
<p>https://github.com/0xwindows/VulScritp
（企业内网渗透脚本，包括banner扫描、端口扫描；phpmyadmin、jenkins等通用漏洞利用等）</p>
<p>https://github.com/lcatro/networkbackdoorscanner（基于网络流量的内网探测框架）</p>
<p>https://github.com/fdiskyou/hunter（调用 Windows API
枚举用户登录信息）</p>
<h2 id="中间件扫描指纹识别类">中间件扫描、指纹识别类</h2>
<p>https://github.com/ring04h/wyportmap
(目标端口扫描+系统服务指纹识别)</p>
<p>https://github.com/ring04h/weakfilescan
(动态多线程敏感信息泄露检测工具)</p>
<p>https://github.com/EnableSecurity/wafw00f (WAF产品指纹识别)</p>
<p>https://github.com/rbsec/sslscan （ssl类型识别)</p>
<p>https://github.com/urbanadventurer/whatweb (web指纹识别)</p>
<p>https://github.com/tanjiti/FingerPrint (web应用指纹识别)</p>
<p>https://github.com/nanshihui/Scan-T （网络爬虫式指纹识别)</p>
<p>https://github.com/OffensivePython/Nscan (a fast Network scanner
inspired by Masscan and Zmap)</p>
<p>https://github.com/ywolf/F-NAScan (网络资产信息扫描,
ICMP存活探测,端口扫描，端口指纹服务识别）</p>
<p>https://github.com/ywolf/F-MiddlewareScan （中间件扫描）</p>
<p>https://github.com/maurosoria/dirsearch (Web path scanner)</p>
<p>https://github.com/x0day/bannerscan （C段Banner与路径扫描）</p>
<p>https://github.com/RASSec/RASscan (端口服务扫描)</p>
<p>https://github.com/3xp10it/bypass_waf （waf自动暴破）</p>
<p>https://github.com/3xp10it/mytools/blob/master/xcdn.py（获取cdn背后的真实ip）</p>
<p>https://github.com/Xyntax/BingC（基于Bing搜索引擎的C段/旁站查询，多线程，支持API）</p>
<p>https://github.com/Xyntax/DirBrute（多线程WEB目录爆破工具）</p>
<p>https://github.com/zer0h/httpscan（一个爬虫式的网段Web主机发现小工具）</p>
<p>https://github.com/lietdai/doom（thorn上实现的分布式任务分发的ip端口漏洞扫描器）</p>
<h2 id="专用扫描器">专用扫描器</h2>
<p>https://github.com/blackye/Jenkins
(Jenkins漏洞探测、用户抓取爆破)</p>
<p>https://github.com/code-scan/dzscan (discuz扫描)</p>
<p>https://github.com/chuhades/CMS-Exploit-Framework (CMS攻击框架)</p>
<p>https://github.com/lijiejie/IISshortnameScanner (an IIS shortname
Scanner)</p>
<p>https://github.com/We5ter/Scanne ... ter/FlashScanner.pl
(flashxss扫描)</p>
<p>https://github.com/coffeehb/SSTIF（一个Fuzzing服务器端模板注入漏洞的半自动化工具）</p>
<h2 id="无线网络">无线网络</h2>
<p>https://github.com/savio-code/fern-wifi-cracker/
(无线安全审计工具)</p>
<p>https://github.com/m4n3dw0lf/PytheM（Python网络/渗透测试工具）</p>
<p>https://github.com/P0cL4bs/WiFi-Pumpkin（无线安全渗透测试套件）</p>
<h2 id="综合类">综合类</h2>
<p>https://github.com/az0ne/AZScanner
(自动漏洞扫描器，子域名爆破，端口扫描，目录爆破，常用框架漏洞检测)</p>
<p>https://github.com/blackye/lalascan
(自主开发的分布式web漏洞扫描框架，集合owasp
top10漏洞扫描和边界资产发现能力)</p>
<p>https://github.com/blackye/BkScanner (BkScanner
分布式、插件化web漏洞扫描器)</p>
<p>https://github.com/ysrc/GourdScanV2 （被动式漏洞扫描)</p>
<p>https://github.com/alpha1e0/pentestdb (WEB渗透测试数据库)</p>
<p>https://github.com/netxfly/passive_scan
(基于http代理的web漏洞扫描器)</p>
<p>https://github.com/1N3/Sn1per
(自动化扫描器，包括中间件扫描以及设备指纹识别)</p>
<p>https://github.com/RASSec/pentestEr_Fully-automatic-scanner
（定向全自动化渗透测试工具）</p>
<p>https://github.com/3xp10it/3xp10it （3xp10it自动化渗透测试框架）</p>
<p>https://github.com/Lcys/lcyscan（python插件化漏洞扫描器）</p>
<p>https://github.com/Xyntax/POC-T（渗透测试插件化并发框架）</p>
<p>CTF平台 http://www.shiyanbar.com/</p>
<p>http://oj.xctf.org.cn/</p>
<p>http://ctf.bugku.com/</p>
<p>http://rookiehacker.org/</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>这是一篇用来测试的文章</title>
    <url>//post/%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E7%94%A8%E6%9D%A5%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%87%E7%AB%A0.html</url>
    <content><![CDATA[<p>此篇文章用来记录一些hexo的基本操作（纯新手）</p>
<h1 id="插入图片">插入图片</h1>
<h2 id="第一种方法">第一种方法</h2>
<p><del>此时我在<strong>source</strong>文件夹下新建了一个名为
“Article_Picture” 的文件夹用来存放图片。</del>
<del>此时只需要按照以下格式在.md文件中写入即可。</del></p>
<p>不用看以上方法了，没用。</p>
<p>首先在hexo的配置文件<code>config.yaml</code>更改一下配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>随后使用命令新建一篇文章时，hexo会在<code>_posts</code>中生成相同名字的文件夹，此时将图片放在该文件夹下，而后按照以下格式进行插入即可。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片加载失败时的描述</span>](<span class="link">图片链接</span>)</span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/%E6%B5%8B%E8%AF%95%E6%88%AA%E5%9B%BE2.png"
alt="这其实是一张图片" />
<figcaption aria-hidden="true">这其实是一张图片</figcaption>
</figure>
<h2 id="第二种方法">第二种方法</h2>
<p>略</p>
<h1 id="插件的查看与卸载">插件的查看与卸载</h1>
<h2 id="查看已安装插件">查看已安装插件</h2>
<p>在blog目录下输入以下命令即可查看已安装插件 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm <span class="built_in">ls</span> <span class="literal">-dept</span> <span class="number">0</span></span><br></pre></td></tr></table></figure> <img
src="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/mingling.png"
alt="这其实是一张图片" /></p>
<h2 id="卸载插件">卸载插件</h2>
<p>在blog目录下输入以下命令即可卸载已安装插件 <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo<span class="literal">-asset-image</span>@<span class="number">0.0</span>.<span class="number">5</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure> 其中
<strong>hexo-asset-image@0.0.5</strong> 为要卸载的插件的名称</p>
<p>最后还需前往 <strong>node_modules</strong>
文件夹删除相关配置和文件</p>
<h1 id="插入数学公式">插入数学公式</h1>
<h2 id="安装所需插件">安装所需插件</h2>
<p>卸载 Hexo 自带的 renderer，安装 Pandoc renderer <a
href="https://github.com/jgm/pandoc">下载pandoc并安装</a>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo<span class="literal">-renderer-marked</span> <span class="literal">--save</span></span><br><span class="line">npm install hexo<span class="literal">-renderer-pandoc</span> <span class="literal">--save</span></span><br></pre></td></tr></table></figure></p>
<h2 id="如何使用">如何使用</h2>
<p><a
href="https://corner430.github.io/2021/07/02/%E7%94%A8markdown%E4%B9%A6%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/#:~:text=%E8%A1%8C%E5%86%85%E5%85%AC%E5%BC%8F%EF%BC%9A%E5%B0%86%E5%85%AC%E5%BC%8F%E6%8F%92%E5%85%A5%E5%88%B0%E6%9C%AC%E8%A1%8C%E5%86%85%EF%BC%8C%E7%AC%A6%E5%8F%B7%EF%BC%9A%20%24%E5%85%AC%E5%BC%8F%E5%86%85%E5%AE%B9%24%20%EF%BC%8C%E5%A6%82%EF%BC%9A%20xyz,%E7%8B%AC%E8%A1%8C%E5%85%AC%E5%BC%8F%EF%BC%9A%E5%B0%86%E5%85%AC%E5%BC%8F%E6%8F%92%E5%85%A5%E5%88%B0%E6%96%B0%E7%9A%84%E4%B8%80%E8%A1%8C%E5%86%85%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%B1%85%E4%B8%AD%EF%BC%8C%E7%AC%A6%E5%8F%B7%EF%BC%9A%20%24%24%E5%85%AC%E5%BC%8F%E5%86%85%E5%AE%B9%24%24%20%EF%BC%8C%E5%A6%82%EF%BC%9A%20xyz">具体请参考这篇文章</a></p>
<p>所有公式都应该包括在一对 “$” 符号中，例如： <figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">$里面是公式内容$</span><br></pre></td></tr></table></figure> <span
class="math inline">\(5^5-ads\)</span></p>
<h1 id="如何使用-emoji-表情">如何使用 Emoji 表情</h1>
<h2 id="使用表情符号简码">使用表情符号简码</h2>
<p>一些Markdown应用程序允许您通过键入表情符号短代码来插入表情符号。这些以冒号开头和结尾，并包含表情符号的名称。
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">去露营了！ :tent: 很快回来。</span><br><span class="line">真好笑！ :joy:</span><br></pre></td></tr></table></figure> 呈现的输出如下所示： 去露营了！ :tent: 很快回来。 真好笑！
:joy:</p>
<p><a
href="https://markdown.com.cn/extended-syntax/emoji.html">请参考Markdown的官方教程</a></p>
<p><a
href="https://gist.github.com/rxaviers/7360908">这是表情符号简码列表</a></p>
<h1 id="插入表格">插入表格</h1>
<h2 id="markdown默认方法">Markdown默认方法</h2>
<p>表头内容默认居中对齐，单元格内容默认左对齐，Markdown 代码:
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 标题1 | 标题2 | 标题3 |</span><br><span class="line">| ------ | ------ | ------ |</span><br><span class="line">| 文本好短 | 文本不短也不长 | 文本好长文本好长文本好长 |</span><br><span class="line">| 文本好长文本好长文本好长 | 文本好短 | 文本不短也不长 |</span><br></pre></td></tr></table></figure> 显示效果：</p>
<table>
<thead>
<tr class="header">
<th>标题1</th>
<th>标题2</th>
<th>标题3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>123</td>
<td>123</td>
<td>123</td>
</tr>
<tr class="even">
<td>123</td>
<td>123</td>
<td>123</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
