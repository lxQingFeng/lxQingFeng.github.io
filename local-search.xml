<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C语言练习题</title>
    <link href="/post/C%E8%AF%AD%E8%A8%80%E7%BB%83%E4%B9%A0%E9%A2%98.html"/>
    <url>/post/C%E8%AF%AD%E8%A8%80%E7%BB%83%E4%B9%A0%E9%A2%98.html</url>
    
    <content type="html"><![CDATA[<h1 id="打印输出1-30之间的所有素数"><a href="#打印输出1-30之间的所有素数" class="headerlink" title="打印输出1-30之间的所有素数"></a>打印输出1-30之间的所有素数</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个程序的目标是打印出1到30之间的所有素数。为了实现这个目标，我们首先需要一个函数来判断一个数是否为素数。这就是<code>is_prime</code>函数的作用。它接受一个整数作为参数，然后通过一个for循环来检查这个数是否可以被2到它的平方根之间的任何整数整除。如果可以，那么这个数就不是素数，函数返回0；否则，这个数就是素数，函数返回1。</p><p>然后在<code>main</code>函数中，我们使用一个for循环来遍历1到30的所有整数。对于每一个整数，我们都调用<code>is_prime</code>函数来检查它是否为素数。如果是，我们就使用<code>printf</code>函数将它打印出来。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-qxbqymlqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-qxbqymlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= num; i++) &#123;<br>        <span class="hljs-keyword">if</span> (num % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (is_prime(i)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></div></figure><h1 id="输入6个整数，仅用指针法实现按由大到小的顺序输出"><a href="#输入6个整数，仅用指针法实现按由大到小的顺序输出" class="headerlink" title="输入6个整数，仅用指针法实现按由大到小的顺序输出"></a>输入6个整数，仅用指针法实现按由大到小的顺序输出</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这个程序的目标是接收用户输入的6个整数，并按照由大到小的顺序输出这些整数。为了实现这个目标，我们首先需要一个函数来对数组进行排序。这就是<code>sort</code>函数的作用。它接受一个整数指针和一个整数作为参数，整数指针指向我们要排序的数组，整数表示数组的长度。<code>sort</code>函数使用了冒泡排序算法，通过两层循环来比较并交换数组中的元素，从而实现排序。</p><p>然后在<code>main</code>函数中，我们首先定义了一个长度为6的整数数组。然后，我们使用一个for循环和<code>scanf</code>函数来接收用户输入的6个整数，并将这些整数存储在数组中。接着，我们调用<code>sort</code>函数来对数组进行排序。最后，我们使用一个for循环和<code>printf</code>函数来按照由大到小的顺序输出这6个整数。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-kz849tlqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-kz849tlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (*(arr + i) &lt; *(arr + j)) &#123;<br>                <span class="hljs-type">int</span> temp = *(arr + i);<br>                *(arr + i) = *(arr + j);<br>                *(arr + j) = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">6</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入6个整数：\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr + i);<br>    &#125;<br>    sort(arr, <span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;由大到小的顺序输出为：\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *(arr + i));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></div></figure><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-q64hn5lqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-q64hn5lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br></code></pre></td></tr></table></div></figure><p>这行代码包含了<code>stdio.h</code>头文件，它是C语言中提供输入&#x2F;输出功能的库。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-1ytdqolqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-1ytdqolqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br></code></pre></td></tr></table></div></figure><p>这行代码定义了一个名为<code>is_prime</code>的函数，它接受一个整数<code>num</code>作为参数。这个函数用于检查<code>num</code>是否为素数。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-6sug05lqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-6sug05lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></div></figure><p>如果<code>num</code>小于或等于1，那么它就不是素数，所以我们返回0。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-eulnwplqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-eulnwplqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= num; i++) &#123;<br></code></pre></td></tr></table></div></figure><p>这行代码是一个for循环，用于检查<code>num</code>是否可以被2到<code>sqrt(num)</code>之间的任何整数整除。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-b0sstylqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-b0sstylqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (num % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></div></figure><p>如果<code>num</code>可以被<code>i</code>整除，那么<code>num</code>就不是素数，所以我们返回0。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-6fdblwlqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-6fdblwlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></div></figure><p>如果<code>num</code>不能被2到<code>sqrt(num)</code>之间的任何整数整除，那么<code>num</code>就是素数，所以我们返回1。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-u6jsdrlqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-u6jsdrlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br></code></pre></td></tr></table></div></figure><p>这行代码定义了程序的主函数<code>main</code>。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-mos4dslqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-mos4dslqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br></code></pre></td></tr></table></div></figure><p>这行代码是一个for循环，用于遍历1到30的所有整数。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-86qvp7lqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-86qvp7lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (is_prime(i)) &#123;<br></code></pre></td></tr></table></div></figure><p>这行代码调用我们之前定义的<code>is_prime</code>函数，检查当前的整数<code>i</code>是否为素数。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-hcvxe1lqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-hcvxe1lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br></code></pre></td></tr></table></div></figure><p>如果<code>i</code>是素数，我们就打印出来。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-gxhcqplqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-gxhcqplqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></div></figure><p>这些是闭合前面的if语句和for循环的大括号，以及表示<code>main</code>函数的结束，<code>return 0;</code>表示程序执行成功。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-f01nollqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-f01nollqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br></code></pre></td></tr></table></div></figure><p>这行代码包含了<code>stdio.h</code>头文件，它是C语言中提供输入&#x2F;输出功能的库。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-dfqo5olqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-dfqo5olqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> n)</span> &#123;<br></code></pre></td></tr></table></div></figure><p>这行代码定义了一个名为<code>sort</code>的函数，它接受一个整数指针<code>arr</code>和一个整数<code>n</code>作为参数。<code>arr</code>指向我们要排序的数组，<code>n</code>是数组的长度。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-g3q5uxlqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-g3q5uxlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br></code></pre></td></tr></table></div></figure><p>这两行代码是两个嵌套的for循环，用于遍历数组中的每一对元素。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-5sdk6ylqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-5sdk6ylqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (*(arr + i) &lt; *(arr + j)) &#123;<br></code></pre></td></tr></table></div></figure><p>这行代码检查当前的两个元素是否满足我们的排序条件（即第一个元素是否小于第二个元素）。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-c385e6lqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-c385e6lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> temp = *(arr + i);<br>*(arr + i) = *(arr + j);<br>*(arr + j) = temp;<br></code></pre></td></tr></table></div></figure><p>如果满足排序条件，我们就交换这两个元素的位置。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-arsmotlqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-arsmotlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></div></figure><p>这些是闭合前面的if语句和for循环的大括号。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ss8zvslqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-ss8zvslqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br></code></pre></td></tr></table></div></figure><p>这行代码定义了程序的主函数<code>main</code>。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-wa5f87lqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-wa5f87lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">6</span>];<br></code></pre></td></tr></table></div></figure><p>这行代码定义了一个长度为6的整数数组<code>arr</code>。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-eowkyslqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-eowkyslqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入6个整数：\n&quot;</span>);<br></code></pre></td></tr></table></div></figure><p>这行代码打印出提示信息，告诉用户需要输入6个整数。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-486ukrlqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-486ukrlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr + i);<br>&#125;<br></code></pre></td></tr></table></div></figure><p>这两行代码是一个for循环，用于从用户那里读取6个整数并存储在数组<code>arr</code>中。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-guqah5lqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-guqah5lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sort(arr, <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></div></figure><p>这行代码调用我们之前定义的<code>sort</code>函数，对数组<code>arr</code>进行排序。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-1qcs84lqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-1qcs84lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;由大到小的顺序输出为：\n&quot;</span>);<br></code></pre></td></tr></table></div></figure><p>这行代码打印出提示信息，告诉用户接下来将按照由大到小的顺序输出这6个整数。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-h4tkmklqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-h4tkmklqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *(arr + i));<br>&#125;<br></code></pre></td></tr></table></div></figure><p>这两行代码是一个for循环，用于按照由大到小的顺序打印出这6个整数。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-sczlyelqpaf7yn"></i><span>c</span><div class="collapse show" id="collapse-sczlyelqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></div></figure><p>这行代码表示<code>main</code>函数的结束，<code>return 0;</code>表示程序执行成功。</p>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eNSP配置三层交换机</title>
    <link href="/post/eNSP%E9%85%8D%E7%BD%AE%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA.html"/>
    <url>/post/eNSP%E9%85%8D%E7%BD%AE%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA.html</url>
    
    <content type="html"><![CDATA[<h1 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h1><p><img src="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%8B%93%E6%89%91%E5%9B%BE.png" alt="拓扑图"></p><h1 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h1><h2 id="SW1配置"><a href="#SW1配置" class="headerlink" title="SW1配置"></a>SW1配置</h2><figure class="highlight pf"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-8a2y81lqpaf7yn"></i><span>pf</span><div class="collapse show" id="collapse-8a2y81lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pf">system-view  <span class="hljs-comment"># 进入系统视图</span><br>vlan batch <span class="hljs-number">10</span>  <span class="hljs-comment"># 创建vlan10</span><br>interface GigabitEthernet <span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">2</span>  <span class="hljs-comment"># 进入与PC1相连的接口</span><br><span class="hljs-keyword">port</span> link-type access <span class="hljs-comment"># 开启访问模式</span><br><span class="hljs-keyword">port</span> <span class="hljs-keyword">default</span> vlan <span class="hljs-number">10</span>  <span class="hljs-comment"># 分配vlan</span><br>interface GigabitEthernet <span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>  <span class="hljs-comment"># 进入与SW2相连的接口</span><br><span class="hljs-keyword">port</span> link-type trunk <span class="hljs-comment"># 开启trunk模式</span><br><span class="hljs-keyword">port</span> trunk allow-pass vlan <span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-comment"># 允许vlan10、20通过这个trunk端口</span><br></code></pre></td></tr></table></div></figure><h2 id="SW2配置"><a href="#SW2配置" class="headerlink" title="SW2配置"></a>SW2配置</h2><figure class="highlight apache"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-7vovu6lqpaf7yn"></i><span>apache</span><div class="collapse show" id="collapse-7vovu6lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">system</span>-view  # 进入系统视图<br><span class="hljs-attribute">vlan</span> batch <span class="hljs-number">10</span> <span class="hljs-number">20</span> # 创建vlan10、<span class="hljs-number">20</span><br><span class="hljs-attribute">interface</span> GigabitEthernet <span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">1</span> # 进入与SW1相连的接口<br><span class="hljs-attribute">port</span> link-type trunk # 开启trunk模式<br><span class="hljs-attribute">port</span> trunk <span class="hljs-literal">allow</span>-pass vlan <span class="hljs-number">10</span> <span class="hljs-number">20</span> # 允许vlan10、<span class="hljs-number">20</span>通过这个trunk端口<br><span class="hljs-attribute">interface</span> GigabitEthernet <span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">2</span> # 进入与SW3相连的接口<br><span class="hljs-attribute">port</span> link-type trunk # 开启trunk模式<br><span class="hljs-attribute">port</span> trunk <span class="hljs-literal">allow</span>-pass vlan <span class="hljs-number">10</span> <span class="hljs-number">20</span> # 允许vlan10、<span class="hljs-number">20</span>通过这个trunk端口<br><span class="hljs-attribute">interface</span> Vlanif <span class="hljs-number">10</span>  # 进入vlan10<br><span class="hljs-attribute">ip</span> address <span class="hljs-number">192.168.3.1</span> <span class="hljs-number">24</span> # 为vlan10设置IP<br><span class="hljs-attribute">interface</span> Vlanif <span class="hljs-number">20</span>  # 进入vlan20<br><span class="hljs-attribute">ip</span> address <span class="hljs-number">192.168.6.1</span> <span class="hljs-number">24</span> # 为vlan20设置IP<br></code></pre></td></tr></table></div></figure><h2 id="SW3配置"><a href="#SW3配置" class="headerlink" title="SW3配置"></a>SW3配置</h2><figure class="highlight pf"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-egrlp4lqpaf7yn"></i><span>pf</span><div class="collapse show" id="collapse-egrlp4lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pf">system-view  <span class="hljs-comment"># 进入系统视图</span><br>vlan batch <span class="hljs-number">20</span>  <span class="hljs-comment"># 创建vlan10</span><br>interface GigabitEthernet <span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">2</span>  <span class="hljs-comment"># 进入与PC1相连的接口</span><br><span class="hljs-keyword">port</span> link-type access <span class="hljs-comment"># 开启访问模式</span><br><span class="hljs-keyword">port</span> <span class="hljs-keyword">default</span> vlan <span class="hljs-number">20</span>  <span class="hljs-comment"># 分配vlan</span><br>interface GigabitEthernet <span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>  <span class="hljs-comment"># 进入与SW2相连的接口</span><br><span class="hljs-keyword">port</span> link-type trunk <span class="hljs-comment"># 开启trunk模式</span><br><span class="hljs-keyword">port</span> trunk allow-pass vlan <span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-comment"># 允许vlan10、20通过这个trunk端口</span><br></code></pre></td></tr></table></div></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p><img src="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/ping.png" alt="ping"></p>]]></content>
    
    
    <categories>
      
      <category>网络设备</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eNSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络练习题</title>
    <link href="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%83%E4%B9%A0%E9%A2%98.html"/>
    <url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%83%E4%B9%A0%E9%A2%98.html</url>
    
    <content type="html"><![CDATA[<h1 id="一、填空题"><a href="#一、填空题" class="headerlink" title="一、填空题"></a>一、填空题</h1><ol><li>按照网络覆盖的地理范围，计算机网络可以分为<strong>局域网</strong>、<strong>城域网</strong>和<strong>广域网</strong>。</li><li>广播网络传输方式有<strong>单播</strong>、<strong>广播</strong>和<strong>多播</strong>。</li><li>从功能上来看将计算机网路逻辑划分为<strong>客户端</strong>和<strong>服务器端</strong>。</li><li>从组网的层次角度来看，网络的组成结构是一个典型的三层网络机构，最上层称为<strong>核心层</strong>，中间层称为<strong>汇聚层</strong>，最下层称为<strong>接入层</strong>。</li><li>影响网络的因素有<strong>带宽</strong>、<strong>延迟</strong>、<strong>抖动</strong>和<strong>丢包</strong>。</li><li>OSI模型将网络分为<strong>物理层</strong>、<strong>数据链路层</strong>、<strong>网络层</strong>、<strong>传输层</strong>、<strong>会话层</strong>、<strong>表示层</strong>和<strong>应用层</strong>。</li><li>TCP&#x2F;IP协议有四层，由下往上分别为<strong>网络接口层</strong>、<strong>网络层</strong>、<strong>传输层</strong>和<strong>应用层</strong>。</li><li>在TCP&#x2F;IP协议中，网络层主要协议有<strong>IP</strong>、<strong>ICMP</strong>、<strong>ARP</strong>和<strong>RARP</strong>。</li><li>在TCP&#x2F;IP协议中，传输层主要协议有<strong>TCP</strong>和<strong>UDP</strong>。</li><li>双绞线按结构可分为<strong>屏蔽双绞线</strong>和<strong>非屏蔽双绞线</strong>。</li><li>按传输模式分，光纤可分为<strong>单模光纤</strong>和<strong>多模光纤</strong>两类。</li><li>双绞线水晶头的制作标准有<strong>T568A</strong>和<strong>T568B</strong>两种。</li><li>交换机的互联方式主要有<strong>串行互联</strong>、<strong>并行互联</strong>、<strong>总线互联</strong>和<strong>星型互联</strong>。</li><li>局域网的体系结构涉及到了OSI模型的<strong>物理层</strong>和<strong>数据链路层</strong>两层。</li><li>802标准把局域网的数据链路层分为<strong>LLC子层</strong>和<strong>MAC子层</strong>两个子层。</li><li>常用的介质访问控制协议有三种：<strong>CSMA&#x2F;CD</strong>、<strong>CSMA&#x2F;CA</strong>和<strong>令牌环</strong>。</li><li>令牌环介质访问控制方法，是通过在环型网上传输<strong>令牌</strong>的方式来实现对介质的访问控制的。</li><li>IP地址由<strong>网络地址</strong>和<strong>主机地址</strong>两部分组成，前者用于该主机所在的网络，后者表示该主机在网络中的特定位置。</li><li>IPv6由<strong>128</strong>位二进制数组成。</li><li>以太网利用<strong>ARP</strong>协议获得主机IP地址与MAC地址的映射关系。</li><li>TCP连接包括<strong>三次握手</strong>、<strong>数据传输</strong>和<strong>四次挥手</strong>三个过程。</li><li>TCP采用<strong>滑动窗口</strong>机制实现流量控制功能。</li><li>Telnet服务系统采用<strong>C&#x2F;S</strong>工作模式，主要由<strong>Telnet服务器</strong>、<strong>Telnet客户端</strong>和<strong>网络</strong>组成。</li><li>复用技术主要有<strong>频分复用</strong>、<strong>时分复用</strong>和<strong>码分复用</strong>三种。</li><li>交换技术主要有<strong>电路交换</strong>、<strong>报文交换</strong>和<strong>分组交换</strong>三种。</li><li>IPv6地址为2005：0610：0000：0001：0000：0000：0000：67ff，可压缩表示为<strong>2005:610::1:0:0:67ff</strong>。</li></ol><h1 id="二、选择题"><a href="#二、选择题" class="headerlink" title="二、选择题"></a>二、选择题</h1><ol><li>一座大楼内的计算机网络系统属于（<strong>B．LAN</strong>）。</li><li>世界上第一个计算机网络是（<strong>A．ARPANET</strong>）。</li><li>计算机互联的主要目的是（<strong>D．资源共享</strong>）。</li><li>计算机资源主要指计算机（<strong>C．硬件、软件与数据</strong>）。</li><li>在一台计算机上向另一台计算机发送电子邮件信息时，下面哪一项正确的描述了数据封装的五个步骤？（<strong>A．Data Segment Packet Frame Bit</strong>）。</li><li>将双绞线制作成交叉线，该双绞线连接的两个设备可为（<strong>A．网卡与网卡</strong>）。</li><li>采用5类双绞线所连接的以太网，理论上任意两台PC机的最大间隔距离是多少？（<strong>A．100m</strong>）。</li><li>以太网交换机根据（<strong>B．MAC地址</strong>）转发数据包。</li><li>MAC地址通常存储在计算机的（<strong>A．网卡上</strong>）。</li><li>在以太网中，冲突（<strong>C．是一种正常现象</strong>）。</li><li>以下IP地址中，属于B类地址的是（<strong>B．166.166.166.166</strong>）。</li><li>一个局域网中某台主机的IP地址为192.168.160.13，使用22位作为网络地址，那么该局域网的子网掩码为（<strong>D．255.255.240.0</strong>）。</li><li>下列地址属于单播地址的是（<strong>C．192.168.25.59&#x2F;30</strong>）。</li><li>三次握手方法用于（<strong>A．传输层连接的建立</strong>）。</li><li>TCP是因特网中的（<strong>可靠的</strong>）协议，使用（<strong>三</strong>）次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答（<strong>SYN+ACK</strong>）。这种建立连接的方法可以防止（<strong>重复连接</strong>）。TCP使用的流量控制协议是（<strong>滑动窗口</strong>）。</li><li>在右图网络中，共有（ <strong>3</strong> ）个广播域，（ <strong>3</strong> ）个冲突域。</li></ol><p><img src="https://picst.sunbangyan.cn/2023/12/24/ecdd0352d5b1b1b140be364ace1aab00.jpeg" alt="右图网络"></p><h1 id="三、简答题"><a href="#三、简答题" class="headerlink" title="三、简答题"></a>三、简答题</h1><ol><li>OSI的七层模型及每一层的数据形式：</li></ol><figure class="highlight asciidoc"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-700e2elqpaf7yn"></i><span>asciidoc</span><div class="collapse show" id="collapse-700e2elqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>应用层（Application）：数据单位是报文（Message）<br><span class="hljs-bullet">- </span>表示层（Presentation）：数据单位是报文（Message）<br><span class="hljs-bullet">- </span>会话层（Session）：数据单位是报文（Message）<br><span class="hljs-bullet">- </span>传输层（Transport）：数据单位是段（Segment）<br><span class="hljs-bullet">- </span>网络层（Network）：数据单位是包（Packet）<br><span class="hljs-bullet">- </span>数据链路层（Data Link）：数据单位是帧（Frame）<br><span class="hljs-bullet">- </span>物理层（Physical）：数据单位是比特流（Bit）<br></code></pre></td></tr></table></div></figure><ol start="2"><li>TCP&#x2F;IP的四层模型及上三层主要协议：</li></ol><figure class="highlight asciidoc"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-fxilo6lqpaf7yn"></i><span>asciidoc</span><div class="collapse show" id="collapse-fxilo6lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>应用层：HTTP、FTP、SMTP、DNS等<br><span class="hljs-bullet">- </span>传输层：TCP、UDP<br><span class="hljs-bullet">- </span>网络层：IP、ICMP、ARP、RARP<br><span class="hljs-bullet">- </span>网络接口层<br></code></pre></td></tr></table></div></figure><ol start="3"><li><p><strong>FTTH</strong>（Fiber To The Home）是一种光纤直接到户的宽带接入方式，它提供了极高的带宽，可以满足用户对高速互联网、数字电视、电话等多种业务的需求。<br><strong>ADSL</strong>（Asymmetric Digital Subscriber Line）是一种非对称数字用户线路，它利用电话线提供宽带接入服务，但上行和下行的带宽不对称。</p></li><li><p><strong>HTTP</strong>（HyperText Transfer Protocol）是一种用于传输超文本的协议，主要用于网页浏览。<br><strong>DNS</strong>（Domain Name System）是一种用于将域名转换为IP地址的服务。<br><strong>FTP</strong>（File Transfer Protocol）是一种用于在网络上进行文件传输的协议。<br><strong>DHCP</strong>（Dynamic Host Configuration Protocol）是一种动态主机配置协议，用于自动分配IP地址。</p></li><li><p><strong>基带传输</strong>是指信号在传输过程中保持原始的形式和频率，通常用于短距离、高数据率的传输，如局域网。<br><strong>频带传输</strong>是指信号在传输过程中被调制到较高的频率，通常用于长距离、低数据率的传输，如电视广播。</p></li><li><p><strong>DNS</strong>有两种域名查询方式：<strong>递归查询</strong>和<strong>迭代查询</strong>。递归查询是指客户端向DNS服务器发出请求后，DNS服务器必须给出一个明确的回答。如果DNS服务器不知道答案，它会向其他服务器查询，直到得到一个明确的答案。迭代查询是指客户端向DNS服务器发出请求后，如果DNS服务器不知道答案，它会告诉客户端去向哪个服务器查询。</p></li><li><p><strong>VLAN</strong>的划分方式主要有以下几种：<strong>按端口划分</strong>、<strong>按MAC地址划分</strong>、<strong>按IP地址划分</strong>、<strong>按协议类型划分</strong>。</p></li></ol><h1 id="四、计算题"><a href="#四、计算题" class="headerlink" title="四、计算题"></a>四、计算题</h1><ol><li><p>一个主机的IP地址是202.112.14.137，掩码为255.255.255.224，求这个主机所在网络的网络地址和广播地址。</p><figure class="highlight dns"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-g2m3eylqpaf7yn"></i><span>dns</span><div class="collapse show" id="collapse-g2m3eylqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">IP地址：<span class="hljs-number">202.112.14.137</span> = <span class="hljs-number">11001010</span>.<span class="hljs-number">01110000</span>.<span class="hljs-number">00001110</span>.<span class="hljs-number">10001001</span><br>子网掩码：<span class="hljs-number">255.255.255.224</span> = <span class="hljs-number">11111111</span>.<span class="hljs-number">11111111</span>.<span class="hljs-number">11111111</span>.<span class="hljs-number">11100000</span><br>网络地址：将IP地址和子网掩码进行按位与运算，得到：<br><span class="hljs-number">11001010</span>.<span class="hljs-number">01110000</span>.<span class="hljs-number">00001110</span>.<span class="hljs-number">10000000</span> = <span class="hljs-number">202.112.14.128</span><br>广播地址：将网络地址的主机位全部置为<span class="hljs-number">1</span>，得到：<br><span class="hljs-number">11001010</span>.<span class="hljs-number">01110000</span>.<span class="hljs-number">00001110</span>.<span class="hljs-number">10011111</span> = <span class="hljs-number">202.112.14.159</span><br></code></pre></td></tr></table></div></figure></li></ol><p><strong>这个主机所在网络的网络地址是202.112.14.128，广播地址是202.112.14.159。</strong></p><ol start="2"><li>如下图，通过设置静态路由实现主机A能ping通主机B，则在路由器R1、R2、R3上分别要设置怎样的静态路由。</li></ol><p><img src="https://picss.sunbangyan.cn/2023/12/24/77d7eb09d59f96cbcfaa7a8d7108aace.jpeg" alt="拓扑图"></p><p>R1</p><table><thead><tr><th align="left">Dest</th><th>Mask</th><th>GW</th><th>Interface</th></tr></thead><tbody><tr><td align="left">192.168.3.0</td><td>255.255.255.0</td><td>192.168.4.2</td><td>e1_1</td></tr></tbody></table><p>R2</p><table><thead><tr><th>Dest</th><th>Mask</th><th>GW</th><th>Interface</th></tr></thead><tbody><tr><td>192.168.2.0</td><td>255.255.255.0</td><td>192.168.4.1</td><td>e1_1</td></tr><tr><td>192.168.3.0</td><td>255.255.255.0</td><td>192.168.6.2</td><td>e1_2</td></tr></tbody></table><p>R3</p><table><thead><tr><th>Dest</th><th>Mask</th><th>GW</th><th>Interface</th></tr></thead><tbody><tr><td>192.168.2.0</td><td>255.255.255.0</td><td>192.168.6.1</td><td>e1_1</td></tr></tbody></table><h1 id="计算题解释"><a href="#计算题解释" class="headerlink" title="计算题解释"></a>计算题解释</h1><h2 id="1、计算网络地址和广播地址"><a href="#1、计算网络地址和广播地址" class="headerlink" title="1、计算网络地址和广播地址"></a>1、计算网络地址和广播地址</h2><ol><li><strong>计算网络地址</strong>：网络地址是通过将IP地址和子网掩码进行按位与运算得到的。按位与运算的规则是，如果两个对应的二进制位都为1，则结果为1，否则为0。因此，我们将IP地址和子网掩码对应的二进制位进行比较，如果都是1，则结果为1，否则为0。这样我们就得到了网络地址。</li><li><strong>计算广播地址</strong>：广播地址是通过将网络地址的主机位全部置为1得到的。在子网掩码中，网络位对应的是1，主机位对应的是0。因此，我们将网络地址中，对应子网掩码中0的那些位，全部置为1，就得到了广播地址。</li></ol><h2 id="2、配置静态路由"><a href="#2、配置静态路由" class="headerlink" title="2、配置静态路由"></a>2、配置静态路由</h2><p>静态路由的设置是基于网络的拓扑结构和IP地址配置。在你的网络中，主机A需要通过路由器R1、R2、R3来访问主机B。因此，我们需要在每个路由器上设置适当的静态路由，以便数据包能够正确地从主机A路由到主机B。</p><p>对于路由器R1，我们需要设置一个静态路由，使得所有目标为主机B所在网络的数据包都会被发送到下一跳路由器R2。因此，我们将目标网络设置为主机B所在的网络，子网掩码设置为主机B所在网络的子网掩码，网关设置为R1到R2的接口IP，接口设置为R1到R2的接口。</p><p>对于路由器R2，我们需要设置两个静态路由。一个是使得所有目标为主机B所在网络的数据包都会被发送到下一跳路由器R3，另一个是使得所有目标为主机A所在网络的数据包都会被发送到下一跳路由器R1。因此，我们将目标网络设置为主机B和主机A所在的网络，子网掩码设置为主机B和主机A所在网络的子网掩码，网关设置为R2到R3和R2到R1的接口IP，接口设置为R2到R3和R2到R1的接口。</p><p>对于路由器R3，我们需要设置一个静态路由，使得所有目标为主机A所在网络的数据包都会被发送到下一跳路由器R2。因此，我们将目标网络设置为主机A所在的网络，子网掩码设置为主机A所在网络的子网掩码，网关设置为R3到R2的接口IP，接口设置为R3到R2的接口。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/post/hello-world.html"/>
    <url>/post/hello-world.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-5dnqkklqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-5dnqkklqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></div></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-bat4gglqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-bat4gglqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></div></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-cye9s0lqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-cye9s0lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></div></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-58rjcslqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-58rjcslqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></div></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开始</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何正确的食用Docker</title>
    <link href="/post/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%A3%9F%E7%94%A8Docker.html"/>
    <url>/post/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%A3%9F%E7%94%A8Docker.html</url>
    
    <content type="html"><![CDATA[<h1 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><h2 id="什么是Docker？"><a href="#什么是Docker？" class="headerlink" title="什么是Docker？"></a>什么是Docker？</h2><p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html">Go 语言</a> 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><h2 id="Docker能干嘛？"><a href="#Docker能干嘛？" class="headerlink" title="Docker能干嘛？"></a>Docker能干嘛？</h2><p>软件开发最大的麻烦事之一，就是环境配置。而Docker可以十分方便的配置它们。</p><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 <code>Docker</code> 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h2 id="Docker的三个基本概念"><a href="#Docker的三个基本概念" class="headerlink" title="Docker的三个基本概念"></a>Docker的三个基本概念</h2><p>Docker 包括三个基本概念：</p><ul><li><strong>镜像（image）</strong>：Docker 镜像（image），相当于是一个root文件系统。例如官方镜像 Ubuntu: 16.04 就包含了完整的一套 Ubuntu 16.04 最小系统的root文件系统。</li><li><strong>容器（Container）</strong>：容器（Container）<strong>由</strong> Docker 镜像（image）生成。一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</li><li><strong>仓库（Repository）</strong>：镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href="https://docker-practice.github.io/zh-cn/repository/registry.html">Docker Registry</a> 就是这样的服务。</li></ul><h1 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h1><p>Docker 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p><p><a href="https://docs.docker.com/get-docker/">Get Docker | Docker Documentation</a></p><h2 id="在Ubuntu安装Docker"><a href="#在Ubuntu安装Docker" class="headerlink" title="在Ubuntu安装Docker"></a>在Ubuntu安装Docker</h2><p>Docker 支持以下版本的 <a href="https://ubuntu.com/server">Ubuntu</a> 操作系统：</p><ul><li>Ubuntu Hirsute 21.04</li><li>Ubuntu Groovy 20.10</li><li>Ubuntu Focal 20.04 (LTS)</li><li>Ubuntu Bionic 18.04 (LTS)</li></ul><p>Docker 可以安装在 64 位的 x86 平台或 ARM 平台上。Ubuntu 发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本。</p><h3 id="卸载旧版本Docker"><a href="#卸载旧版本Docker" class="headerlink" title="卸载旧版本Docker"></a>卸载旧版本Docker</h3><p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-xzb3jflqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-xzb3jflqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get remove docker \<br>             docker-engine \<br>             docker.io<br></code></pre></td></tr></table></div></figure><h3 id="使用-APT-安装"><a href="#使用-APT-安装" class="headerlink" title="使用 APT 安装"></a>使用 APT 安装</h3><p>由于 <code>apt</code> 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-fyex0rlqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-fyex0rlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get udate<br><br>sudo apt-get install \<br>apt-transport-https \<br>    ca-certificates \<br>    curl \<br>    gnupg \<br>    lsb-release<br></code></pre></td></tr></table></div></figure><p>为了确认所下载软件包的合法性，需要添加软件源的 <code>GPG</code> 密钥。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-wqcgwjlqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-wqcgwjlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br><br><span class="hljs-comment"># 官方源</span><br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br></code></pre></td></tr></table></div></figure><p>向<code>sources.list</code>中添加 Docker 软件源</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-q3abt2lqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-q3abt2lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> \<br>  <span class="hljs-string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span><br><span class="hljs-string">  <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br><br><span class="hljs-comment"># 官方源</span><br><span class="hljs-comment"># $ echo \</span><br><span class="hljs-comment">#   &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="hljs-comment">#   $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></code></pre></td></tr></table></div></figure><h3 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p>更新 apt 软件包缓存，并安装 <code>docker-ce</code>：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-z4x7pdlqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-z4x7pdlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin<br></code></pre></td></tr></table></div></figure><h3 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h3><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-qnq6gilqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-qnq6gilqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> docker<br>sudo systemctl start docker<br></code></pre></td></tr></table></div></figure><h3 id="建立-Docker-用户组"><a href="#建立-Docker-用户组" class="headerlink" title="建立 Docker 用户组"></a>建立 Docker 用户组</h3><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立<code>docker</code>组：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-qfgqkzlqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-qfgqkzlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo groupadd docker<br></code></pre></td></tr></table></div></figure><p>将当前用户加入<code>docker</code>组：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-f317nilqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-f317nilqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></div></figure><h2 id="在CentOS安装Docker"><a href="#在CentOS安装Docker" class="headerlink" title="在CentOS安装Docker"></a>在CentOS安装Docker</h2><p>切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker</p><p>Docker 支持 64 位版本 CentOS 7&#x2F;8，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 <code>overlay2</code> 存储层驱动）无法使用，并且部分功能可能不太稳定。</p><h3 id="卸载旧版本Docker-1"><a href="#卸载旧版本Docker-1" class="headerlink" title="卸载旧版本Docker"></a>卸载旧版本Docker</h3><p>旧版本的 Docker 称为 <code>docker</code> 或者 <code>docker-engine</code>，使用以下命令卸载旧版本：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-mys882lqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-mys882lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum remove docker \<br>                docker-client \<br>                docker-client-latest \<br>                docker-common \<br>                docker-latest \<br>                docker-latest-logrotate \<br>                docker-logrotate \<br>                docker-selinux \<br>                docker-engine-selinux \<br>                docker-engine<br></code></pre></td></tr></table></div></figure><h3 id="使用-yum-安装"><a href="#使用-yum-安装" class="headerlink" title="使用 yum 安装"></a>使用 yum 安装</h3><p>安装依赖包：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-t2v98qlqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-t2v98qlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install -y yum-utils<br></code></pre></td></tr></table></div></figure><p>添加<code>yum</code>软件源：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-vqvroylqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-vqvroylqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum-config-manager \<br>--add-repp \<br>https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br>sudo sed -i <span class="hljs-string">&#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27;</span> /etc/yum.repos.d/docker-ce.repo<br><br><span class="hljs-comment"># 官方源</span><br>sudo yum-config-manager \<br>--add-repp<br>https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></div></figure><p>如需测试版本的Docker：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-elnjf4lqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-elnjf4lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum-config-manager --<span class="hljs-built_in">enable</span> docker-ce-test<br></code></pre></td></tr></table></div></figure><h3 id="安装-Docker-1"><a href="#安装-Docker-1" class="headerlink" title="安装 Docker"></a>安装 Docker</h3><p>更新 <code>yum</code> 软件源缓存，并安装 <code>docker-ce</code>。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-dx29solqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-dx29solqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin<br></code></pre></td></tr></table></div></figure><h3 id="CentOS8的额外设置"><a href="#CentOS8的额外设置" class="headerlink" title="CentOS8的额外设置"></a>CentOS8的额外设置</h3><p>由于 CentOS8 防火墙使用了 <code>nftables</code>，但 Docker 尚未支持 <code>nftables</code>， 我们可以使用如下设置使用 <code>iptables</code>：</p><p>更改 <code>/etc/firewalld/firewalld.conf</code></p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ty8fullqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-ty8fullqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># FirewallBackend=nftables</span><br>FirewallBackend=iptables<br></code></pre></td></tr></table></div></figure><p>或执行以下命令：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-wjpo6ulqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-wjpo6ulqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">firewall-cmd --permanent --zone=trusted --add-interface=docker0<br>firewall-cmd --reload<br></code></pre></td></tr></table></div></figure><h3 id="启动-Docker-1"><a href="#启动-Docker-1" class="headerlink" title="启动 Docker"></a>启动 Docker</h3><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-97cemilqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-97cemilqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> docker<br>sudo systemctl start docker<br></code></pre></td></tr></table></div></figure><h3 id="建立-Docker-用户组-1"><a href="#建立-Docker-用户组-1" class="headerlink" title="建立 Docker 用户组"></a>建立 Docker 用户组</h3><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-h7jye4lqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-h7jye4lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo groupadd docker<br></code></pre></td></tr></table></div></figure><p>将当前用户加入<code>docker</code>组：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-imno9olqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-imno9olqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo usermod -aG docekr <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></div></figure><h3 id="添加内核参数"><a href="#添加内核参数" class="headerlink" title="添加内核参数"></a>添加内核参数</h3><p>如果在 CentOS 使用 Docker 看到下面的这些警告信息：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-7byd6rlqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-7byd6rlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">WARNING: bridge-nf-call-iptables is disabled<br>WARNING: bridge-nf-call-ip6tables is disabled<br></code></pre></td></tr></table></div></figure><p>添加内核配置参数以启用这些功能</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-gyvnwalqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-gyvnwalqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">tee</span> -a /etc/sysctl.conf &lt;&lt;-<span class="hljs-string">EOF</span><br><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="hljs-string">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></div></figure><p>重新加载<code>sysctl.conf</code>即可</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-acw4o6lqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-acw4o6lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo sysctl -p<br></code></pre></td></tr></table></div></figure><h1 id="Docker食用指南"><a href="#Docker食用指南" class="headerlink" title="Docker食用指南"></a>Docker食用指南</h1><h2 id="镜像使用指南"><a href="#镜像使用指南" class="headerlink" title="镜像使用指南"></a>镜像使用指南</h2><p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。命令格式是：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-dtna37lqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-dtna37lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull [OPTIONS] NAME[:TAG|@DIGEST]<br></code></pre></td></tr></table></div></figure><p> <strong>参数说明：</strong></p><ul><li>TAG：标签（版本）</li><li>DIGEST：摘要</li><li>OPTIONS：<ul><li>-a ：下载镜像仓库中所有的指定镜像；</li><li>–disable-content-trust：跳过镜像验证（默认值是true）；</li><li>–platform： 如果服务具有多平台功能，则设置平台；</li><li>-q：一直详细输出；</li></ul></li></ul><p>具体选项可以通过<code>docker pull --help</code>命令查看。</p><p><strong>例子如下：</strong></p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-mb7q81lqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-mb7q81lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker pull ubuntu:18.04<br>18.04: Pulling from library/ubuntu<br>92dc2a97ff99: Pull complete<br>be13a9d27eb8: Pull complete<br>c8299583700a: Pull complete<br>Digest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> ubuntu:18.04<br>docker.io/library/ubuntu:18.04<br></code></pre></td></tr></table></div></figure><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （<code>docker.io</code>）获取镜像。而镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。<code>docker pull</code> 命令的输出结果最后一行给出了镜像的完整名称，即： <code>docker.io/library/ubuntu:18.04</code>。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是<code>域名/IP[:端口号]</code>。默认地址是 Docker Hub（<code>docker.io</code>）。</li><li>仓库名：仓库名是两段式名称，即<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于 Docker Hub，如果没有指定用户名，则默认是<code>library</code>，也就是官方镜像。</li></ul><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>有了镜像后，可以以这个镜像为基础启动并运行一个容器。以上面的<code>Ubuntu:18.04</code>为例，如果打算启动里面的<code>bash</code>并且进行交互式操作的话，可以执行以下命令：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-txlckvlqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-txlckvlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -it --<span class="hljs-built_in">rm</span> ubuntu:18:04 bash<br><br><span class="hljs-comment"># 以下是容器内操作</span><br>root@e7009c6ce357:/<span class="hljs-comment"># cat /etc/os-release</span><br>NAME=<span class="hljs-string">&quot;Ubuntu&quot;</span><br>VERSION=<span class="hljs-string">&quot;18.04.1 LTS (Bionic Beaver)&quot;</span><br>ID=ubuntu<br>ID_LIKE=debian<br>PRETTY_NAME=<span class="hljs-string">&quot;Ubuntu 18.04.1 LTS&quot;</span><br>VERSION_ID=<span class="hljs-string">&quot;18.04&quot;</span><br>HOME_URL=<span class="hljs-string">&quot;https://www.ubuntu.com/&quot;</span><br>SUPPORT_URL=<span class="hljs-string">&quot;https://help.ubuntu.com/&quot;</span><br>BUG_REPORT_URL=<span class="hljs-string">&quot;https://bugs.launchpad.net/ubuntu/&quot;</span><br>PRIVACY_POLICY_URL=<span class="hljs-string">&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span><br>VERSION_CODENAME=bionic<br>UBUNTU_CODENAME=bionic<br></code></pre></td></tr></table></div></figure><p><code>docker run</code>就是要运行容器的命令，这里简单说明一下上面用到的参数</p><ul><li><code>-it</code>：这是两个参数，一个是 <code>-i</code>：交互式操作，一个是 <code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li><li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</li><li><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</li></ul><p>进入容器后就可以在 Shell 下操作执行任何所需的命令。例如，上面就执行了<code>cat /etc/os-release</code>，这是Linux常用的查看当前系统版本的命令，从返回的结果可以看到容器内是<code>Ubuntu 18.04.1 LTS</code>系统。</p><p>最后可以通过<code>exit</code>退出这个容器。</p><h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-jbmyzilqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-jbmyzilqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span><br>REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE<br>redis                latest              5f515359c7f8        5 days ago          183 MB<br>nginx                latest              05a60462f8ba        5 days ago          181 MB<br>mongo                3.2                 fe9198c04d62        5 days ago          342 MB<br>&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB<br>ubuntu               18.04               329ed837d508        3 days ago          63.3MB<br>ubuntu               bionic              329ed837d508        3 days ago          63.3MB<br></code></pre></td></tr></table></div></figure><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p><p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p><h4 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h4><p>Docker Hub上显示的镜像体积是压缩后的体积大小，在镜像上传和下载的过程中镜像是保持压缩状态的。而使用命令<code>docker image ls</code>显示的是镜像下载到本地后展开的大小，准确说，是展开后的各层所占空间的总和。</p><p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。相同的层只需要保存一份即可。</p><p>通过<code>docker system df</code>命令来查看镜像、容器、数据卷所占用的空间。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-3mwwm4lqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-3mwwm4lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker system <span class="hljs-built_in">df</span><br>TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE<br>Images          2         1         390.2MB   390.2MB (99%)<br>Containers      1         0         0B        0B<br>Local Volumes   0         0         0B        0B<br>Build Cache     18        0         789B      789B<br></code></pre></td></tr></table></div></figure><h4 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h4><p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p><p>根据仓库名列出仓库</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-mx9lr8lqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-mx9lr8lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span> ubuntu<br>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE<br>ubuntu       latest    ba6acccedd29   23 months ago   72.8MB<br>ubuntu       18.04     5a214d77f5d7   23 months ago   63.1MB<br></code></pre></td></tr></table></div></figure><p>列出特定的某个镜像，也就是说指定仓库名和标签</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-f4bg0blqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-f4bg0blqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span> ubuntu:18.04<br>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE<br>ubuntu       18.04     5a214d77f5d7   23 months ago   63.1MB<br></code></pre></td></tr></table></div></figure><h3 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h3><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-bkfufylqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-bkfufylqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">rm</span> [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]<br></code></pre></td></tr></table></div></figure><p>其中，<code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><h2 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h2><h4 id="启动容器、"><a href="#启动容器、" class="headerlink" title="启动容器、"></a>启动容器、</h4><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p><p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p>更多详细教程请参考 <a href="https://docker-practice.github.io/zh-cn/">前言 · Docker – 从入门到实践 (docker-practice.github.io)</a></p><p><a href="https://blog.csdn.net/zhuzicc/article/details/118066353">Docker “pull“命令获取镜像，讲道理你真的会吗？_docker pull_zhuzicc的博客-CSDN博客</a></p><p><a href="https://www.runoob.com/docker/docker-tutorial.html">Docker 教程 | 菜鸟教程 (runoob.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/435605760">全面的Docker快速入门教程 - 知乎 (zhihu.com)</a></p><p><a href="https://ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker 入门教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用tmux（终端工具）</title>
    <link href="/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tmux%EF%BC%88%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%EF%BC%89.html"/>
    <url>/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tmux%EF%BC%88%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%EF%BC%89.html</url>
    
    <content type="html"><![CDATA[<h1 id="什么是tmux"><a href="#什么是tmux" class="headerlink" title="什么是tmux"></a>什么是tmux</h1><p>Tmux 是一个终端复用器（terminal multiplexer）</p><p>tmux 有主要两个用途：</p><ol><li>分屏。既可以同时使用多个命令行；</li><li>会话与窗口解绑。当窗口意外关闭时，会话并不会终止，后面需要的时候，会话可以再次绑定窗口。尤其当使用SSH远程登录计算机时，可以不受断网的影响。</li></ol><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h2 id="安装tmux"><a href="#安装tmux" class="headerlink" title="安装tmux"></a>安装tmux</h2><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-lduhqclqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-lduhqclqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ubantu or Debian</span><br>sudo apt-get install tmux<br><br><span class="hljs-comment"># Centos or Fedora</span><br>sudo yum install tmux<br><br><span class="hljs-comment"># Mac</span><br>brew install tmux<br></code></pre></td></tr></table></div></figure><h2 id="启动、退出"><a href="#启动、退出" class="headerlink" title="启动、退出"></a>启动、退出</h2><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-dduuu1lqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-dduuu1lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmux<br></code></pre></td></tr></table></div></figure><p>在终端输入以上命令即可启动tmux，启动后终端底部会显示一个状态栏。</p><p>左侧是窗口信息（编号和名称），右侧是系统信息。</p><p><img src="/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tmux%EF%BC%88%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%EF%BC%89/image-20230606181115946.png" alt="image-20230606181115946"></p><p>按下<code>Ctrl + d</code>或者在终端输入<code>exit</code>即可退出tmux。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-p5gltwlqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-p5gltwlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></div></figure><h2 id="tmux术语"><a href="#tmux术语" class="headerlink" title="tmux术语"></a>tmux术语</h2><p>tmux 采用 client&#x2F;server模型，主要有四个模块：</p><ul><li>server：服务。tmux运行的基础服务，以下模块均依赖于此服务；</li><li>session：会话。一个服务可以包含多个会话；</li><li>window：窗口。一个会话可以包含多个窗口；</li><li>panel：窗格&#x2F;面板。一个窗口可以包含多个窗格。</li></ul><p>执行 tmux 命令时，即开启了一个服务，并创建了一个会话、窗口和窗格。</p><h2 id="前缀键"><a href="#前缀键" class="headerlink" title="前缀键"></a>前缀键</h2><p>Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是<code>Ctrl+b</code>，即先按下<code>Ctrl+b</code>，快捷键才会生效。</p><p>举例来说，帮助命令的快捷键是<code>Ctrl+b ?</code>。它的用法是，在 Tmux 窗口中，先按下<code>Ctrl+b</code>，再按下<code>?</code>，就会显示帮助信息。</p><p>然后，按下 ESC 键或<code>q</code>键，就可以退出帮助。</p><h1 id="Tmux会话管理"><a href="#Tmux会话管理" class="headerlink" title="Tmux会话管理"></a>Tmux会话管理</h1><h2 id="新建会话"><a href="#新建会话" class="headerlink" title="新建会话"></a>新建会话</h2><p>第一个启动的 Tmux 窗口，编号是 <code>0</code>，第二个窗口的编号是 <code>1</code>，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</p><p>使用编号区分会话，不太直观，更好的方法是为会话起名。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-4n0fvxlqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-4n0fvxlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmux new -s &lt;your-session-name&gt;<br></code></pre></td></tr></table></div></figure><p>上面命令新建一个指定名称的会话。</p><h2 id="分离会话"><a href="#分离会话" class="headerlink" title="分离会话"></a>分离会话</h2><p>在 Tmux 窗口中，按下 <code>Ctrl+b d</code> 或者输入 <code>tmux detach</code> 命令，就会将当前会话与窗口分离。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-uhg4fglqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-uhg4fglqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmux detach<br></code></pre></td></tr></table></div></figure><p>上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。</p><p><code>tmux ls</code> 命令可以查看当前所有的 Tmux 会话。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-1j63fklqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-1j63fklqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmux <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># or</span><br>tmux list-session<br></code></pre></td></tr></table></div></figure><p><img src="/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tmux%EF%BC%88%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%EF%BC%89/image-20230606182214934.png" alt="image-20230606182214934"></p><h2 id="接入会话"><a href="#接入会话" class="headerlink" title="接入会话"></a>接入会话</h2><p>在终端输入<code>tmux attach</code>用于重新接入某个已存在的会话。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-86220glqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-86220glqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用会话编号接入会话</span><br>tmux attach -t 0<br><br><span class="hljs-comment"># 使用会话名称接入会话</span><br>tmux attach -t &lt;your-session-name&gt;<br></code></pre></td></tr></table></div></figure><h2 id="kill会话"><a href="#kill会话" class="headerlink" title="kill会话"></a>kill会话</h2><p>在终端输入<code>tmux kill-session</code>用于杀死某个已存在的会话。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ddslxulqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-ddslxulqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用会话编号结束会话</span><br>tmux kill-sesion -t 0<br><br><span class="hljs-comment"># 使用会话名称结束会话</span><br>tmux kill-sesion -t &lt;your-session-name&gt;<br></code></pre></td></tr></table></div></figure><h2 id="切换会话"><a href="#切换会话" class="headerlink" title="切换会话"></a>切换会话</h2><p>在终端输入<code>tmux switch</code>以切换会话。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-c0z54qlqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-c0z54qlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用会话编号切换会话</span><br>tmux switch -t 0<br><br><span class="hljs-comment"># 使用会话名称切换会话</span><br>tmux switch -t &lt;session-name&gt;<br></code></pre></td></tr></table></div></figure><h2 id="重命名会话"><a href="#重命名会话" class="headerlink" title="重命名会话"></a>重命名会话</h2><p>在终端输入<code>tmux rename-session</code>以重命名会话。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-rr9m0olqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-rr9m0olqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmux rename-session -t 0 &lt;new-name&gt;<br></code></pre></td></tr></table></div></figure><p>以上命令会将<code>0</code>号会话重命名。</p><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>tmux大部分操作都可以用快捷键来代替。</p><p>使用快捷键的前提是先按下了<code>Ctrl + b</code></p><p>使用<code>tmux list-keys</code>可以列出所有快捷键。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-dq02a9lqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-dq02a9lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmux list-keys<br></code></pre></td></tr></table></div></figure><h2 id="会话快捷键"><a href="#会话快捷键" class="headerlink" title="会话快捷键"></a>会话快捷键</h2><ul><li>s ：列出所有会话，也可以在列表中用鼠标或上下键切换会话</li><li>d ：离开当前会话</li><li>$ ：重命名当前会话</li></ul><h2 id="窗口快捷键"><a href="#窗口快捷键" class="headerlink" title="窗口快捷键"></a>窗口快捷键</h2><ul><li>c ： 创建一个新窗口</li><li>n ： 切换到下一个窗口</li><li>w ： 从列表中选择窗口</li><li>&lt;0~9&gt; ： 切换到指定标号的窗口，编号显示在状态栏</li><li>,（这是一个英文逗号） : 将窗口重命名</li></ul><p>一个<code>session</code>中可以有很多个窗口，可以在状态栏中查看，如：</p><p><img src="/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tmux%EF%BC%88%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%EF%BC%89/image-20230606184635853.png" alt="image-20230606184635853"></p><p>其中：</p><p><code>[key]</code>表示的是当前会话的名称。</p><p><code>0：zsh-</code>表示的是0号窗口，<code>zsh</code>是窗口的名字。</p><p>窗口名字后的<code>*</code>号代表当前显示的窗口。</p><p>而右侧显示的是用户名、当前时间、当前日期。</p><h2 id="窗格快捷键"><a href="#窗格快捷键" class="headerlink" title="窗格快捷键"></a>窗格快捷键</h2><ul><li>% ： 将窗口分成<strong>左右</strong>两个窗格。</li><li>“（这是一个英文双引号）： 将窗口分成<strong>上下</strong>两个窗格。</li><li>z ： 将当前窗格<strong>全屏显示</strong>，再按一次恢复。</li><li>q ： 显示窗格编号。</li><li>t ： 再当前窗格显示时间。</li><li>o ： 将光标切换到下个一个窗格。</li><li>&lt;arrow key&gt; ： 将光标切换到其他窗格。使用<strong>上下左右方向键</strong>进行切换</li><li>{ ： 将当前窗格<strong>左移</strong>。</li><li>} ： 将当前窗格<strong>右移</strong>。</li><li>Ctrl + o ： 将当前窗格<strong>上移</strong>。</li><li>Alt + o ： 将当前窗格<strong>下移</strong>。</li><li>space（空格键） ： 切换窗格布局。</li><li>x ： 删除当前窗格。</li></ul><h1 id="配置tmux支持鼠标"><a href="#配置tmux支持鼠标" class="headerlink" title="配置tmux支持鼠标"></a>配置tmux支持鼠标</h1><p>鼠标支持的内容：</p><ul><li>用鼠标点击窗格来激活该窗格；</li><li>用鼠标拖动调节窗格的大小（拖动位置是窗格之间的分隔线）；</li><li>用鼠标点击来切换活动窗口（点击位置是状态栏的窗口名称）；</li><li>开启窗口&#x2F;窗格里面的鼠标支持，用鼠标回滚显示窗口内容，按下shift的同时用鼠标选取文本，使用 ctrl+shift+c、ctrl+shift+v 的方式进行复制粘贴。</li></ul><p>配置方式为在 ~&#x2F;.tmux.conf 文件中，增加：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-exm3lulqpaf7yn"></i><span>bash</span><div class="collapse show" id="collapse-exm3lulqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">set-option -g mouse on<br></code></pre></td></tr></table></div></figure><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol><li><a href="https://zhuanlan.zhihu.com/p/137715607">https://zhuanlan.zhihu.com/p/137715607</a></li><li><a href="https://www.cnblogs.com/niuben/p/15983908.html">https://www.cnblogs.com/niuben/p/15983908.html</a></li><li><a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">https://www.ruanyifeng.com/blog/2019/10/tmux.html</a></li><li><a href="https://blog.csdn.net/CSSDCC/article/details/121231906">https://blog.csdn.net/CSSDCC/article/details/121231906</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>地毯模组（Carpet）的使用教程</title>
    <link href="/post/%E5%9C%B0%E6%AF%AF%E6%A8%A1%E7%BB%84%EF%BC%88Carpet%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html"/>
    <url>/post/%E5%9C%B0%E6%AF%AF%E6%A8%A1%E7%BB%84%EF%BC%88Carpet%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html</url>
    
    <content type="html"><![CDATA[<p>Carpet中文百科</p><p><a href="https://www.mcmod.cn/class/2361.html">Carpet - MC百科|最大的Minecraft中文MOD百科 (mcmod.cn)</a></p><p>本文仅从以上链接中的教程总结出较为常用的命令</p><h1 id="player"><a href="#player" class="headerlink" title="&#x2F;player"></a>&#x2F;player</h1><p>&#x2F;player命令可以控制在线玩家或者假玩家。</p><h2 id="生成与清除"><a href="#生成与清除" class="headerlink" title="生成与清除"></a>生成与清除</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-9zg7bflqpaf7yn"></i><span>MC-CMD</span><div class="collapse show" id="collapse-9zg7bflqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; spawn<br></code></pre></td></tr></table></div></figure><p>该命令会在玩家所在位置生成一个名为<target>的玩家，无论是否真实存在，并且保持与执行者一样的视角和游戏模式。</p><p>如果生成的玩家真实存在，则该玩家上线时将顶替掉生成的假玩家，并恢复原先的游戏模式。</p><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ixkgl0lqpaf7yn"></i><span>MC-CMD</span><div class="collapse show" id="collapse-ixkgl0lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; kill<br></code></pre></td></tr></table></div></figure><p>该命令会使假玩家退出当前存档或者服务器，同时保留他身上的物品。</p><p>该命令只对假玩家有效。</p><p>如果原版游戏规则keepInventory设为false，击杀生存模式的假玩家会使该玩家掉落身上的所有物品。</p><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-vlowtmlqpaf7yn"></i><span>MC-CMD</span><div class="collapse show" id="collapse-vlowtmlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; shadow<br></code></pre></td></tr></table></div></figure><p>该命令会将目标玩家踢出存档或服务器，并在他的相同位置生成一个名称相同的假玩家。</p><p>该命令只对当前正在游玩的真玩家有效。</p><h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-yhpvyylqpaf7yn"></i><span>MC-CMD</span><div class="collapse show" id="collapse-yhpvyylqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; look &lt;direction&gt;<br></code></pre></td></tr></table></div></figure><p>该命令会让玩家看向一定的方向。&lt;direction&gt;可以是：</p><ul><li>north（北）、south（南）、west（西）、east（东）、up（上）、down（下）；</li><li>at：让玩家看向某个位置。后面还需要跟玩家要看向的位置的坐标。</li></ul><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-833kcblqpaf7yn"></i><span>MC-CMD</span><div class="collapse show" id="collapse-833kcblqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; move &lt;direction&gt;<br></code></pre></td></tr></table></div></figure><p>该命令会让玩家按照指定的方向持续移动。&lt;direction&gt;可以是backward（后），forward（前），left（左），right（右）。</p><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-6smekhlqpaf7yn"></i><span>MC-CMD</span><div class="collapse show" id="collapse-6smekhlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; jump [&lt;option&gt;]<br></code></pre></td></tr></table></div></figure><p>该命令会让玩家跳跃一次。</p><p>可以使用[&lt;option&gt;]参数指定跳跃模式。[&lt;option&gt;]可以是：</p><ul><li>continuous：让玩家连续跳跃。</li><li>interval：让玩家每隔一定游戏刻跳跃一次。该参数要求后面再跟一个参数，指定跳跃间隔的游戏刻数。</li><li>once：让玩家跳跃一次，与默认情况相同。</li></ul><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-4vmwkelqpaf7yn"></i><span>MC-CMD</span><div class="collapse show" id="collapse-4vmwkelqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; sneak<br>/player &lt;target&gt; unsneak<br></code></pre></td></tr></table></div></figure><p>这两个命令可以分别让玩家潜行和取消潜行。</p><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-osfzmylqpaf7yn"></i><span>MC-CMD</span><div class="collapse show" id="collapse-osfzmylqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; sprint<br>/player &lt;target&gt; unsprint<br></code></pre></td></tr></table></div></figure><p>这两个命令可以分别让玩家疾跑和停止疾跑。</p><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-zec9tllqpaf7yn"></i><span>MC-CMD</span><div class="collapse show" id="collapse-zec9tllqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; turn &lt;option&gt;<br></code></pre></td></tr></table></div></figure><p>该命令可以让玩家的视角旋转。&lt;option&gt;可以是：</p><ul><li>back（转向身后），left（左转90°），right（右转90°）。</li><li>两个浮点数：具体控制旋转的角度。第一个数字控制视角的俯仰（正为俯视，负为仰视），第二个数字控制视角的水平角度（正为右转，负为左转）。例如， &#x2F;player &lt;target&gt; turn -45 90 会让玩家的视角上扬45°并右转90°。</li></ul><p>更多教程看</p><p><a href="https://www.mcmod.cn/item/list/2361-10.html">游戏设定 - Carpet - MC百科|最大的Minecraft中文MOD百科 (mcmod.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Minecraft</category>
      
    </categories>
    
    
    <tags>
      
      <tag>我的世界mod教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为交换机基础配置</title>
    <link href="/post/%E5%8D%8E%E4%B8%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE.html"/>
    <url>/post/%E5%8D%8E%E4%B8%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE.html</url>
    
    <content type="html"><![CDATA[<h1 id="基础配置命令"><a href="#基础配置命令" class="headerlink" title="基础配置命令"></a>基础配置命令</h1><p>启动后进入交换机</p><h2 id="设置中文提示"><a href="#设置中文提示" class="headerlink" title="设置中文提示"></a>设置中文提示</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-qrzbu1lqpaf7yn"></i><span>switch</span><div class="collapse show" id="collapse-qrzbu1lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs switch">language-mode Chinese<br></code></pre></td></tr></table></div></figure><h2 id="进入系统视图"><a href="#进入系统视图" class="headerlink" title="进入系统视图"></a>进入系统视图</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-agbp8ylqpaf7yn"></i><span>switch</span><div class="collapse show" id="collapse-agbp8ylqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs switch">system-view<br></code></pre></td></tr></table></div></figure><h2 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-uucro9lqpaf7yn"></i><span>switch</span><div class="collapse show" id="collapse-uucro9lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs switch">user privilege level 15<br></code></pre></td></tr></table></div></figure><h2 id="进入console配置"><a href="#进入console配置" class="headerlink" title="进入console配置"></a>进入console配置</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-160ag8lqpaf7yn"></i><span>switch</span><div class="collapse show" id="collapse-160ag8lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs switch">user-interface console 0<br></code></pre></td></tr></table></div></figure><h2 id="设置console密码"><a href="#设置console密码" class="headerlink" title="设置console密码"></a>设置console密码</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-jktulhlqpaf7yn"></i><span>switch</span><div class="collapse show" id="collapse-jktulhlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs switch">authentication-mode password<br>set authentication password simple Huawei<br></code></pre></td></tr></table></div></figure><h2 id="设置登录前后标语"><a href="#设置登录前后标语" class="headerlink" title="设置登录前后标语"></a>设置登录前后标语</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-mpl0iflqpaf7yn"></i><span>switch</span><div class="collapse show" id="collapse-mpl0iflqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs switch">header login information &quot;This is SW1&quot;<br>header shell information &quot;login succeed&quot;<br></code></pre></td></tr></table></div></figure><h2 id="创建与划分vlan"><a href="#创建与划分vlan" class="headerlink" title="创建与划分vlan"></a>创建与划分vlan</h2><h3 id="创建vlan"><a href="#创建vlan" class="headerlink" title="创建vlan"></a>创建vlan</h3><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-reg9i8lqpaf7yn"></i><span>switch</span><div class="collapse show" id="collapse-reg9i8lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs switch">vlan batch 10 20<br></code></pre></td></tr></table></div></figure><h3 id="进入端口并划分vlan"><a href="#进入端口并划分vlan" class="headerlink" title="进入端口并划分vlan"></a>进入端口并划分vlan</h3><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-kxbqjulqpaf7yn"></i><span>switch</span><div class="collapse show" id="collapse-kxbqjulqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs switch">interface GigabitEthernet 0/0/1<br>port link-type access<br>port default vlan 10<br></code></pre></td></tr></table></div></figure><h2 id="设置vlan-IP"><a href="#设置vlan-IP" class="headerlink" title="设置vlan IP"></a>设置vlan IP</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-777kkolqpaf7yn"></i><span>switch</span><div class="collapse show" id="collapse-777kkolqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs switch">interface vlanif 10<br>ip address 192.168.10.1 24<br></code></pre></td></tr></table></div></figure><h2 id="查看配置结果"><a href="#查看配置结果" class="headerlink" title="查看配置结果"></a>查看配置结果</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-pdn2pklqpaf7yn"></i><span>switch</span><div class="collapse show" id="collapse-pdn2pklqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs switch">display current-configuration<br></code></pre></td></tr></table></div></figure>]]></content>
    
    
    <categories>
      
      <category>网络设备</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eNSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>imgTP图床测试</title>
    <link href="/post/imgTP%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95.html"/>
    <url>/post/imgTP%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95.html</url>
    
    <content type="html"><![CDATA[<p>我是OP</p><p><img src="/imgTP%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95/EOFNREpH.jpg" alt="二次元图片"></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这是一篇用来测试的文章</title>
    <link href="/post/%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E7%94%A8%E6%9D%A5%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%87%E7%AB%A0.html"/>
    <url>/post/%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E7%94%A8%E6%9D%A5%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%87%E7%AB%A0.html</url>
    
    <content type="html"><![CDATA[<p>此篇文章用来记录一些hexo的基本操作（纯新手）</p><h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><h2 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h2><p><del>此时我在<strong>source</strong>文件夹下新建了一个名为 “Article_Picture” 的文件夹用来存放图片。</del><br><del>此时只需要按照以下格式在.md文件中写入即可。</del></p><p>不用看以上方法了，没用。</p><p>首先在hexo的配置文件<code>config.yaml</code>更改一下配置：</p><figure class="highlight yaml"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-xmpbi5lqpaf7yn"></i><span>yaml</span><div class="collapse show" id="collapse-xmpbi5lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></div></figure><p>随后使用命令新建一篇文章时，hexo会在<code>_posts</code>中生成相同名字的文件夹，此时将图片放在该文件夹下，而后按照以下格式进行插入即可。</p><figure class="highlight markdown"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-yrxk2flqpaf7yn"></i><span>markdown</span><div class="collapse show" id="collapse-yrxk2flqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">图片加载失败时的描述</span>](<span class="hljs-link">图片链接</span>)<br></code></pre></td></tr></table></div></figure><p><img src="/./%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E7%94%A8%E6%9D%A5%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%87%E7%AB%A0/%E6%B5%8B%E8%AF%95%E6%88%AA%E5%9B%BE2.png" alt="这其实是一张图片"></p><h2 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h2><p>略</p><h1 id="插件的查看与卸载"><a href="#插件的查看与卸载" class="headerlink" title="插件的查看与卸载"></a>插件的查看与卸载</h1><h2 id="查看已安装插件"><a href="#查看已安装插件" class="headerlink" title="查看已安装插件"></a>查看已安装插件</h2><p>在blog目录下输入以下命令即可查看已安装插件</p><figure class="highlight powershell"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-eie3ozlqpaf7yn"></i><span>powershell</span><div class="collapse show" id="collapse-eie3ozlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm <span class="hljs-built_in">ls</span> <span class="hljs-literal">-dept</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></div></figure><p><img src="/./%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E7%94%A8%E6%9D%A5%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%87%E7%AB%A0/mingling.png" alt="这其实是一张图片"></p><h2 id="卸载插件"><a href="#卸载插件" class="headerlink" title="卸载插件"></a>卸载插件</h2><p>在blog目录下输入以下命令即可卸载已安装插件</p><figure class="highlight powershell"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-a8ggr5lqpaf7yn"></i><span>powershell</span><div class="collapse show" id="collapse-a8ggr5lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm uninstall hexo<span class="hljs-literal">-asset-image</span>@<span class="hljs-number">0.0</span>.<span class="hljs-number">5</span> <span class="hljs-literal">--save</span><br></code></pre></td></tr></table></div></figure><p>其中 <strong><a href="mailto:&#104;&#x65;&#120;&#x6f;&#45;&#97;&#115;&#x73;&#101;&#116;&#x2d;&#x69;&#x6d;&#97;&#103;&#x65;&#x40;&#x30;&#46;&#x30;&#46;&#x35;">&#104;&#x65;&#120;&#x6f;&#45;&#97;&#115;&#x73;&#101;&#116;&#x2d;&#x69;&#x6d;&#97;&#103;&#x65;&#x40;&#x30;&#46;&#x30;&#46;&#x35;</a></strong> 为要卸载的插件的名称</p><p>最后还需前往 <strong>node_modules</strong> 文件夹删除相关配置和文件</p><h1 id="插入数学公式"><a href="#插入数学公式" class="headerlink" title="插入数学公式"></a>插入数学公式</h1><h2 id="安装所需插件"><a href="#安装所需插件" class="headerlink" title="安装所需插件"></a>安装所需插件</h2><p>卸载 Hexo 自带的 renderer，安装 Pandoc renderer<br><a href="https://github.com/jgm/pandoc">下载pandoc并安装</a></p><figure class="highlight powershell"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-hptwxxlqpaf7yn"></i><span>powershell</span><div class="collapse show" id="collapse-hptwxxlqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm uninstall hexo<span class="hljs-literal">-renderer-marked</span> <span class="hljs-literal">--save</span><br>npm install hexo<span class="hljs-literal">-renderer-pandoc</span> <span class="hljs-literal">--save</span><br></code></pre></td></tr></table></div></figure><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p><a href="https://corner430.github.io/2021/07/02/%E7%94%A8markdown%E4%B9%A6%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/#:~:text=%E8%A1%8C%E5%86%85%E5%85%AC%E5%BC%8F%EF%BC%9A%E5%B0%86%E5%85%AC%E5%BC%8F%E6%8F%92%E5%85%A5%E5%88%B0%E6%9C%AC%E8%A1%8C%E5%86%85%EF%BC%8C%E7%AC%A6%E5%8F%B7%EF%BC%9A%20%24%E5%85%AC%E5%BC%8F%E5%86%85%E5%AE%B9%24%20%EF%BC%8C%E5%A6%82%EF%BC%9A%20xyz,%E7%8B%AC%E8%A1%8C%E5%85%AC%E5%BC%8F%EF%BC%9A%E5%B0%86%E5%85%AC%E5%BC%8F%E6%8F%92%E5%85%A5%E5%88%B0%E6%96%B0%E7%9A%84%E4%B8%80%E8%A1%8C%E5%86%85%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%B1%85%E4%B8%AD%EF%BC%8C%E7%AC%A6%E5%8F%B7%EF%BC%9A%20%24%24%E5%85%AC%E5%BC%8F%E5%86%85%E5%AE%B9%24%24%20%EF%BC%8C%E5%A6%82%EF%BC%9A%20xyz">具体请参考这篇文章</a></p><p>所有公式都应该包括在一对 “$” 符号中，例如：</p><figure class="highlight markdown"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-6m99tilqpaf7yn"></i><span>markdown</span><div class="collapse show" id="collapse-6m99tilqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$里面是公式内容$<br></code></pre></td></tr></table></div></figure><p>$5^5-ads$</p><h1 id="如何使用-Emoji-表情"><a href="#如何使用-Emoji-表情" class="headerlink" title="如何使用 Emoji 表情"></a>如何使用 Emoji 表情</h1><h2 id="使用表情符号简码"><a href="#使用表情符号简码" class="headerlink" title="使用表情符号简码"></a>使用表情符号简码</h2><p>一些Markdown应用程序允许您通过键入表情符号短代码来插入表情符号。这些以冒号开头和结尾，并包含表情符号的名称。</p><figure class="highlight markdown"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-2vbnaalqpaf7yn"></i><span>markdown</span><div class="collapse show" id="collapse-2vbnaalqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">去露营了！ :tent: 很快回来。<br>真好笑！ :joy:<br></code></pre></td></tr></table></div></figure><p>呈现的输出如下所示：<br>去露营了！ :tent: 很快回来。<br>真好笑！ :joy:</p><p><a href="https://markdown.com.cn/extended-syntax/emoji.html">请参考Markdown的官方教程</a></p><p><a href="https://gist.github.com/rxaviers/7360908">这是表情符号简码列表</a></p><h1 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h1><h2 id="Markdown默认方法"><a href="#Markdown默认方法" class="headerlink" title="Markdown默认方法"></a>Markdown默认方法</h2><p>表头内容默认居中对齐，单元格内容默认左对齐，Markdown 代码:</p><figure class="highlight markdown"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-5pynh5lqpaf7yn"></i><span>markdown</span><div class="collapse show" id="collapse-5pynh5lqpaf7yn"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">| 标题1 | 标题2 | 标题3 |<br>| ------ | ------ | ------ |<br>| 文本好短 | 文本不短也不长 | 文本好长文本好长文本好长 |<br>| 文本好长文本好长文本好长 | 文本好短 | 文本不短也不长 |<br></code></pre></td></tr></table></div></figure><p>显示效果：</p><table><thead><tr><th>标题1</th><th>标题2</th><th>标题3</th></tr></thead><tbody><tr><td>123</td><td>123</td><td>123</td></tr><tr><td>123</td><td>123</td><td>123</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
