<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>mysql常用命令</title>
    <link href="/post/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
    <url>/post/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
    
    <content type="html"><![CDATA[<p>1.连接数据库 mysql -u用户名 -p密码</p><p>2.显示已有数据库 show databases;</p><p>3.创建数据库 create database sqlname;</p><p>4.选择数据库 use database sqlname;</p><p>5.显示数据库中的表（先选择数据库） show tables;</p><p>6.显示当前数据库的版本信息以及连接用户名 select version(),user();</p><p>7.删除数据库(删除时没有提示直接删除) drop database sqlname;deletefrom user where uesr='' [删除匿名用户]</p><p>create user '用户名'@'IP地址' identified by '密码' [创建新用户]</p><p>grant all privileges on 数据库.数据表 to '用户名'@'IP地址' identifiedby '密码' [赋予用户权限，all=全部]</p><p>grant select,insert,update,delete on 数据库.数据表 to '用户名'@'地址'identified by '密码' [赋予用户指定权限]</p><p>drop user 用户@IP地址; [删除用户]</p><p>msfdb init （初始化数据库） insert into 表名(字段1,字段2,......)values(数据1,数据2,......)[插入数据]</p><p>update 表名 set 列=列('要修改的内容') where 对应列='对应列内容'select * from 表名（查看数据表内容） create tables 表名; (创建表)</p><p>show tables;（查看数据表）</p><p>show create table 表名;（查看数据表创建语句）</p><p>desc 表名;（查看表的字段信息）</p><p>alter table 表名 rename 新表名;（修改表名）</p><p>alter table 表名 change 字段名 新字段名 属性;（修改字段名）</p><p>alter table 表名 modify id int(20);（修改字段的数据类型）</p><p>alter table 表名 add 字段名 属性;（添加字段）</p><p>alter table 表名 drop 字段名;（删除字段） alter table 表名 modify字段名 属性 字段;（修改字段的位置）</p><p>表的约束：</p><table><thead><tr class="header"><th>约束条件</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>PRIMARY KEY</td><td>主键约束，用于唯一标识对应的记录</td></tr><tr class="even"><td>FOREIGN KEY</td><td>外键约束</td></tr><tr class="odd"><td>NOT NULL</td><td>非空约束</td></tr><tr class="even"><td>UNIQUE</td><td>唯一性约束</td></tr><tr class="odd"><td>DEFAULT</td><td>默认值约束，用于设置字段的默认值</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux根目录下的各个目录的作用及各颜色类型</title>
    <link href="/post/Linux%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E5%90%84%E4%B8%AA%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8.html"/>
    <url>/post/Linux%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E5%90%84%E4%B8%AA%E7%9B%AE%E5%BD%95%E7%9A%84%E4%BD%9C%E7%94%A8.html</url>
    
    <content type="html"><![CDATA[<h1 id="linux根目录下的各个目录都有特定的作用和含义"><ahref="https://blog.csdn.net/alidada_blog/article/details/81778969">Linux根目录下的各个目录都有特定的作用和含义</a></h1><ol type="1"><li><ahref="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/bin</code>：存放最常用命令</a></li><li><ahref="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/boot</code>：启动Linux的核心文件</a></li><li><ahref="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/dev</code>：设备文件，即设备的驱动程序</a></li><li><ahref="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/etc</code>：存放各种配置文件</a></li><li><ahref="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/home</code>：用户主目录</a></li><li><ahref="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/lib</code>：系统最基本的动态链接共享库</a></li><li><ahref="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/mnt</code>：一般是空的，用来临时挂载别的文件系统</a></li><li><ahref="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/proc</code>：虚拟目录，是内存的映射</a></li><li><ahref="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/sbin</code>：系统的管理命令，这里存放的是系统管理员使用的程序</a></li><li><ahref="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/tmp</code>：临时文件，重启后自动清空</a></li><li><ahref="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/var</code>：某些大文件的溢出区，比如各种服务的日志文件</a></li><li><ahref="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/media</code>：存放着可移除的设备，比如软盘，光盘</a></li><li><ahref="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/root</code>：超级用户的目录</a></li><li><ahref="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/opt</code>：这个是给第三方协力软件放置的目录</a></li><li><ahref="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/sys</code>：管理设备文件</a></li><li><ahref="https://blog.csdn.net/alidada_blog/article/details/81778969"><code>/usr</code>：最大的目录，存放着应用程序和文件</a></li></ol><h1id="文件和目录的颜色代表了什么类型">文件和目录的颜色代表了什么类型</h1><ul><li><strong>蓝色</strong>：目录</li><li><strong>绿色</strong>：可执行文件</li><li><strong>红色</strong>：压缩文件</li><li><strong>浅蓝色</strong>：链接文件</li><li><strong>白色</strong>：普通文件或硬链接</li><li><strong>红色闪烁</strong>：某文件被删除后，链接到该文件的软链接的颜色</li><li><strong>黄色</strong>：设备文件，如键盘鼠标</li><li><strong>灰色</strong>：其它文件</li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu搭建思源笔记（Docker）</title>
    <link href="/post/Ubuntu%E6%90%AD%E5%BB%BA%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%EF%BC%88Docker%EF%BC%89.html"/>
    <url>/post/Ubuntu%E6%90%AD%E5%BB%BA%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%EF%BC%88Docker%EF%BC%89.html</url>
    
    <content type="html"><![CDATA[<p>安装docker和docker-compose的过程不再赘叙</p><h2 id="编写docker-compose.yaml">编写docker-compose.yaml</h2><p>在任意位置新建<code>docker-compose.yaml</code>文件</p><figure class="highlight shell"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-m4829qlu5obpg4"></i><span>shell</span><div class="collapse show" id="collapse-m4829qlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /siyuan &amp;&amp; cd /siyuan<br>vim docker-compose.yaml<br></code></pre></td></tr></table></div></figure><p>写入以下信息（授权码自己修改）</p><figure class="highlight yaml"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-rw6acslu5obpg4"></i><span>yaml</span><div class="collapse show" id="collapse-rw6acslu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">siyuan:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">b3log/siyuan:latest</span><br>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;--workspace=/siyuan/workspace/&#x27;</span>, <span class="hljs-string">&#x27;--accessAuthCode=授权码&#x27;</span>]<br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">siyuan</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span><br>    <span class="hljs-attr">user:</span> <span class="hljs-string">&#x27;1000:1000&#x27;</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">6806</span><span class="hljs-string">:6806</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/siyuan/workspace:/siyuan/workspace</span><br></code></pre></td></tr></table></div></figure><p>保存退出后通过<code>docker-compose up -d</code>启动</p><p>随后就可以通过<code>http://&lt;your_ip:6806&gt;</code>查看服务</p><h2 id="自定义域名">自定义域名</h2><p>使用<code>docker</code>安装运行<code>Nginx Proxy Manager</code></p><p>在任意位置新建<code>docker-compose.yaml</code>文件并写入以下内容</p><figure class="highlight yaml"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-2v1eh6lu5obpg4"></i><span>yaml</span><div class="collapse show" id="collapse-2v1eh6lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">jc21/nginx-proxy-manager:latest</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">80</span><span class="hljs-string">:80</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">81</span><span class="hljs-string">:81</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">443</span><span class="hljs-string">:443</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">DB_MYSQL_HOST:</span> <span class="hljs-string">db</span><br>      <span class="hljs-attr">DB_MYSQL_PORT:</span> <span class="hljs-number">3306</span><br>      <span class="hljs-attr">DB_MYSQL_USER:</span> <span class="hljs-string">npm</span><br>      <span class="hljs-attr">DB_MYSQL_PASSWORD:</span> <span class="hljs-string">npm</span><br>      <span class="hljs-attr">DB_MYSQL_NAME:</span> <span class="hljs-string">npm</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data:/data</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./letsencrypt:/etc/letsencrypt</span><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">yobasystems/alpine-mariadb:latest</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">npm</span><br>      <span class="hljs-attr">MYSQL_DATABASE:</span> <span class="hljs-string">npm</span><br>      <span class="hljs-attr">MYSQL_USER:</span> <span class="hljs-string">npm</span><br>      <span class="hljs-attr">MYSQL_PASSWORD:</span> <span class="hljs-string">npm</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data/mysql:/var/lib/mysql</span><br></code></pre></td></tr></table></div></figure><p>保存退出后通过<code>docker-compose up -d</code>启动</p><p>随后就可以通过<code>http://&lt;your_ip:81&gt;</code>查看服务</p><h3 id="配置nginx-proxy-manager">配置Nginx Proxy Manager</h3><p>通过<code>http://&lt;your_ip:81&gt;</code>打开浏览器查看服务</p><p>输入默认账号密码登录服务</p><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-qgtig7lu5obpg4"></i><span>plain</span><div class="collapse show" id="collapse-qgtig7lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">账号：admin@example.com<br>密码：changeme<br></code></pre></td></tr></table></div></figure><p>登录后点击界面上的<code>SSL Certificates</code>给服务添加证书</p><p><imgsrc="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/97e847c93aa2cb06df372139aa314c716e699f.webp" /></p><p>随后依次点击<code>Add SSL Certificates</code> --&gt;<code>Let's Encrypt</code></p><p><imgsrc="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/71e3f0f25ef4da4e94b3582f94819dbfe9c242.webp" /></p><p>输入自己的域名并同意条款后点击<code>Save</code>等待几分钟即可</p><p><imgsrc="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/e128f87851b254bd1943900b3708b35dd30bb5.webp" /></p><p>随后点击<code>Hosts</code> --&gt; <code>Proxy Hosts</code></p><p><imgsrc="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/61571b806083cfc0474401d4d6f6de63220c19.webp" /></p><p>点击<code>Add Proxy Host</code></p><p><imgsrc="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/224784b392b7bf57bdd1724d0d6641f12a6e72.webp" /></p><p>根据自己的情况依次填入信息</p><p><imgsrc="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/d546ee5692d745a8fa5341161a9ec9b3c5701a.webp" /></p><p>其中<code>172.21.0.2</code>是容器IP 可以参考以下内容查看容器IP</p><figure class="highlight shell"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-aprd1zlu5obpg4"></i><span>shell</span><div class="collapse show" id="collapse-aprd1zlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker inspect [容器ID] | grep IPAddress<br></code></pre></td></tr></table></div></figure><p><imgsrc="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/41d033b249351c9c96d721a9525c7a3853aa9f.webp" /></p><p>随后点击<code>SSL</code>添加刚刚申请的证书并启用<code>Force SSL</code>与<code>HTTP/2 Support</code></p><p><imgsrc="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/0709b45547909dab5d903002d26bce5b801f6a.webp" /></p><p>再点击<code>Save</code>保存即可通过域名访问思源笔记</p><p>当然 前提是你的域名已经解析到了你的服务器</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络安全工具大全</title>
    <link href="/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%85%A8.html"/>
    <url>/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%85%A8.html</url>
    
    <content type="html"><![CDATA[<p><strong>资料来源 wx公众号：橘猫学安全</strong></p><h1 id="漏洞及渗透练习平台">漏洞及渗透练习平台</h1><h2 id="webgoat漏洞练习环境">WebGoat漏洞练习环境</h2><p>https://github.com/WebGoat/WebGoat</p><p>https://github.com/WebGoat/WebGoat-Legacy</p><h2 id="damn-vulnerable-web-application漏洞练习平台dvwa">Damn VulnerableWeb Application(漏洞练习平台)DVWA</h2><p>https://github.com/RandomStorm/DVWA</p><h2 id="数据库注入练习平台">数据库注入练习平台</h2><p>https://github.com/Audi-1/sqli-labs</p><h2id="用node编写的漏洞练习平台like-owasp-node-goat">用node编写的漏洞练习平台，likeOWASP Node Goat</h2><p>https://github.com/cr0hn/vulnerable-node</p><h1 id="花式扫描器">花式扫描器</h1><h2 id="端口扫描器nmap">端口扫描器Nmap</h2><p>https://github.com/nmap/nmap</p><h2 id="本地网络扫描器">本地网络扫描器</h2><p>https://github.com/SkyLined/LocalNetworkScanner</p><h2 id="子域名扫描器">子域名扫描器</h2><p>https://github.com/lijiejie/subDomainsBrute</p><h2 id="漏洞路由扫描器">漏洞路由扫描器</h2><p>https://github.com/jh00nbr/Routerhunter-2.0</p><h2 id="迷你批量信息泄漏扫描脚本">迷你批量信息泄漏扫描脚本</h2><p>https://github.com/lijiejie/BBScan</p><h2 id="waf类型检测工具">Waf类型检测工具</h2><p>https://github.com/EnableSecurity/wafw00f</p><h1 id="信息搜集工具">信息搜集工具</h1><h2id="社工插件可查找以emailphoneusername的注册的所有网站账号信息">社工插件，可查找以email、phone、username的注册的所有网站账号信息</h2><p>https://github.com/n0tr00t/Sreg</p><h2id="github信息搜集可实时扫描查询git最新上传有关邮箱账号密码信息">Github信息搜集，可实时扫描查询git最新上传有关邮箱账号密码信息</h2><p>https://github.com/sea-god/gitscan</p><h2 id="github-repo信息搜集工具">github Repo信息搜集工具</h2><p>https://github.com/metac0rtex/GitHarvester</p><h1 id="web工具">WEB工具</h1><h2 id="webshell大合集">webshell大合集</h2><p>https://github.com/tennc/webshell</p><h2 id="渗透以及web攻击脚本">渗透以及web攻击脚本</h2><p>https://github.com/brianwrf/hackUtils</p><h2 id="web渗透小工具大合集">web渗透小工具大合集</h2><p>https://github.com/rootphantomer/hacktoolsfor_me</p><h2 id="xss数据接收平台">XSS数据接收平台</h2><p>https://github.com/firesunCN/BlueLotus_XSSReceiver</p><h2 id="xss与csrf工具">XSS与CSRF工具</h2><p>https://github.com/evilcos/xssor</p><h2id="short-for-command-injection-exploiterweb向命令注入检测工具">Shortfor command injection exploiter，web向命令注入检测工具</h2><p>https://github.com/stasinopoulos/commix</p><h1 id="数据库注入工具">数据库注入工具</h1><h2 id="sqlmap">SQLmap</h2><p>https://github.com/sqlmapproject/sqlmap</p><h2id="web代理通过加载sqlmap-api进行sqli实时检测">Web代理，通过加载sqlmapapi进行sqli实时检测</h2><p>https://github.com/zt2/sqli-hunter</p><h2 id="新版中国菜刀">新版中国菜刀</h2><p>https://github.com/Chora10/Cknife</p><h2 id="git泄露利用exp">.git泄露利用EXP</h2><p>https://github.com/lijiejie/GitHack</p><h2 id="浏览器攻击框架">浏览器攻击框架</h2><p>https://github.com/beefproject/beef</p><h2 id="自动化绕过waf脚本">自动化绕过WAF脚本</h2><p>https://github.com/khalilbijjou/WAFNinja</p><h2id="http命令行客户端可以从命令行构造发送各种http请求类似于curl">http命令行客户端，可以从命令行构造发送各种http请求（类似于Curl）</h2><p>https://github.com/jkbrzt/httpie</p><h2 id="浏览器调试利器">浏览器调试利器</h2><p>https://github.com/firebug/firebug</p><h2 id="一款开源waf">一款开源WAF</h2><p>https://github.com/SpiderLabs/ModSecurity</p><h1 id="windows域渗透工具">windows域渗透工具</h1><h2 id="windows渗透神器">windows渗透神器</h2><p>https://github.com/gentilkiwi/mimikatz</p><h2 id="powershell渗透库合集">Powershell渗透库合集</h2><p>https://github.com/PowerShellMafia/PowerSploit</p><h2 id="powershell-tools合集">Powershell tools合集</h2><p>https://github.com/clymb3r/PowerShell</p><h1 id="fuzz">Fuzz</h1><h2 id="web向fuzz工具">Web向Fuzz工具</h2><p>https://github.com/xmendez/wfuzz</p><h2 id="http暴力破解撞库攻击脚本">HTTP暴力破解，撞库攻击脚本</h2><p>https://github.com/lijiejie/htpwdScan</p><h1 id="漏洞利用及攻击框架">漏洞利用及攻击框架</h1><h2 id="msf">msf</h2><p>https://github.com/rapid7/metasploit-framework</p><h2id="poc调用框架可加载pocsuitetangscanbeebeeto等">Poc调用框架，可加载Pocsuite,Tangscan，Beebeeto等</h2><p>https://github.com/erevus-cn/pocscan</p><h2 id="pocsuite">Pocsuite</h2><p>https://github.com/knownsec/Pocsuite</p><h2 id="beebeeto">Beebeeto</h2><p>https://github.com/n0tr00t/Beebeeto-framework</p><h1 id="漏洞pocexp">漏洞POC&amp;EXP</h1><h2 id="exploitdb官方git版本">ExploitDB官方git版本</h2><p>https://github.com/offensive-security/exploit-database</p><h2 id="php漏洞代码分析">php漏洞代码分析</h2><p>https://github.com/80vul/phpcodz</p><h2 id="simple-test-for-cve-2016-2107">Simple test forCVE-2016-2107</h2><p>https://github.com/FiloSottile/CVE-2016-2107</p><h2 id="cve-2015-7547-poc">CVE-2015-7547 POC</h2><p>https://github.com/fjserna/CVE-2015-7547</p><h2 id="java反序列化poc生成工具">JAVA反序列化POC生成工具</h2><p>https://github.com/frohoff/ysoserial</p><h2 id="java反序列化exp">JAVA反序列化EXP</h2><p>https://github.com/foxglovesec/JavaUnserializeExploits</p><h2 id="jenkins-commoncollections-exp">Jenkins CommonCollectionsEXP</h2><p>https://github.com/CaledoniaProject/jenkins-cli-exploit</p><h2 id="cve-2015-2426-exp-windows内核提权">CVE-2015-2426 EXP(windows内核提权)</h2><p>https://github.com/vlad902/hacking-team-windows-kernel-lpe</p><h2id="use-docker-to-show-web-attackphp本地文件包含结合phpinfo-getshell-以及ssrf结合curl的利用演示">usedocker to show web attack(php本地文件包含结合phpinfo getshell以及ssrf结合curl的利用演示)</h2><p>https://github.com/hxer/vulnapp</p><h2id="php7缓存覆写漏洞demo及相关工具">php7缓存覆写漏洞Demo及相关工具</h2><p>https://github.com/GoSecure/php7-opcache-override</p><h2 id="xcodeghost木马样本">XcodeGhost木马样本</h2><p>https://github.com/XcodeGhostSource/XcodeGhost</p><h1 id="中间人攻击及钓鱼">中间人攻击及钓鱼</h1><h2 id="中间人攻击框架">中间人攻击框架</h2><p>https://github.com/secretsquirrel/the-backdoor-factory</p><p>https://github.com/secretsquirrel/BDFProxy</p><p>https://github.com/byt3bl33d3r/MITMf</p><p>Inject code, jam wifi, and spy on wifi users</p><p>https://github.com/DanMcInerney/LANs.py</p><h2 id="可扩展的中间人代理工具">可扩展的中间人代理工具</h2><p>https://github.com/intrepidusgroup/mallory</p><h2 id="wifi钓鱼">wifi钓鱼</h2><p>https://github.com/sophron/wifiphisher</p><h1 id="密码破解">密码破解</h1><h2 id="密码破解工具">密码破解工具</h2><p>https://github.com/shinnok/johnny</p><h2 id="本地存储的各类密码提取利器">本地存储的各类密码提取利器</h2><p>https://github.com/AlessandroZ/LaZagne</p><h1 id="二进制及代码分析工具">二进制及代码分析工具</h1><h2 id="二进制分析工具">二进制分析工具</h2><p>https://github.com/devttys0/binwalk</p><h2id="系统扫描器用于寻找程序和库然后收集他们的依赖关系链接等信息">系统扫描器，用于寻找程序和库然后收集他们的依赖关系，链接等信息</h2><p>https://github.com/quarkslab/binmap</p><h2id="rp-is-a-full-cpp-written-tool-that-aims-to-find-rop-sequences-in-peelfmach-o-doesnt-support-the-fat-binaries-x86x64-binaries.">rp++is a full-cpp written tool that aims to find ROP sequences inPE/Elf/Mach-O (doesn't support the FAT binaries) x86/x64 binaries.</h2><p>https://github.com/0vercl0k/rp</p><h2 id="windows-exploit-development工具">Windows ExploitDevelopment工具</h2><p>https://github.com/lillypad/badger</p><h2 id="二进制静态分析工具python">二进制静态分析工具（python）</h2><p>https://github.com/bdcht/amoco</p><h2 id="python-exploit-development-assistance-for-gdb">Python ExploitDevelopment Assistance for GDB</h2><p>https://github.com/longld/peda</p><h2 id="对billgates-linux-botnet系木马活动的监控工具">对BillGates LinuxBotnet系木马活动的监控工具</h2><p>https://github.com/ValdikSS/billgates-botnet-tracker</p><h2 id="木马配置参数提取工具">木马配置参数提取工具</h2><p>https://github.com/kevthehermit/RATDecoders</p><h2id="shellphish编写的二进制分析工具ctf向">Shellphish编写的二进制分析工具（CTF向）</h2><p>https://github.com/angr/angr</p><h2 id="针对python的静态代码分析工具">针对python的静态代码分析工具</h2><p>https://github.com/yinwang0/pysonar2</p><h2id="一个自动化的脚本shell分析工具用来给出警告和建议">一个自动化的脚本（shell）分析工具，用来给出警告和建议</h2><p>https://github.com/koalaman/shellcheck</p><h2id="基于ast变换的简易javascript反混淆辅助工具">基于AST变换的简易Javascript反混淆辅助工具</h2><p>https://github.com/ChiChou/etacsufbo</p><h1 id="exp编写框架及工具">EXP编写框架及工具</h1><h2 id="二进制exp编写工具">二进制EXP编写工具</h2><p>https://github.com/t00sh/rop-tool</p><h2 id="ctf-pwn-类题目脚本编写框架">CTF Pwn 类题目脚本编写框架</h2><p>https://github.com/Gallopsled/pwntools</p><h2 id="an-easy-to-use-io-library-for-pwning-development">an easy-to-useio library for pwning development</h2><p>https://github.com/zTrix/zio</p><h2id="跨平台注入工具-inject-javascript-to-explore-native-apps-on-windows-mac-linux-ios-and-android.">跨平台注入工具（Inject JavaScript to explore native apps on Windows, Mac, Linux, iOS andAndroid.）</h2><p>https://github.com/frida/frida</p><h1 id="隐写相关工具">隐写相关工具</h1><h2 id="隐写检测工具">隐写检测工具</h2><p>https://github.com/abeluck/stegdetect</p><h1 id="各类安全资料">各类安全资料</h1><h2 id="域渗透教程">域渗透教程</h2><p>https://github.com/l3m0n/pentest_study</p><h2id="python-security教程原文链接httpwww.primalsecurity.nettutorialspython-tutorials">pythonsecurity教程（原文链接http://www.primalsecurity.net/tutorials/python-tutorials/）</h2><p>https://github.com/smartFlash/pySecurity</p><h2 id="data_hacking合集">data_hacking合集</h2><p>https://github.com/ClickSecurity/data_hacking</p><h2 id="mobile-security-wiki">mobile-security-wiki</h2><p>https://github.com/exploitprotocol/mobile-security-wiki</p><h2id="书籍reverse-engineering-for-beginners">书籍《reverse-engineering-for-beginners》</h2><p>https://github.com/veficos/reverse-engineering-for-beginners</p><h2 id="一些信息安全标准及设备配置">一些信息安全标准及设备配置</h2><p>https://github.com/luyg24/IT_security</p><h2 id="apt相关笔记">APT相关笔记</h2><p>https://github.com/kbandla/APTnotes</p><h2 id="kcon资料">Kcon资料</h2><p>https://github.com/knownsec/KCon</p><h2 id="ctf及黑客资源合集">ctf及黑客资源合集</h2><p>https://github.com/bt3gl/My-Gray-Hacker-Resources</p><h2 id="ctf和安全工具大合集">ctf和安全工具大合集</h2><p>https://github.com/zardus/ctf-tools</p><h2 id="do-not-fuck-with-a-hacker">《DO NOT FUCK WITH A HACKER》</h2><p>https://github.com/citypw/DNFWAH</p><h1 id="各类ctf资源">各类CTF资源</h1><h2 id="近年ctf-writeup大全">近年ctf writeup大全</h2><p>https://github.com/ctfs/write-ups-2016</p><p>https://github.com/ctfs/write-ups-2015</p><p>https://github.com/ctfs/write-ups-2014</p><h2 id="fbctf竞赛平台demo">fbctf竞赛平台Demo</h2><p>https://github.com/facebook/fbctf</p><h2 id="ctf-resources">ctf Resources</h2><p>https://github.com/ctfs/resources</p><h2 id="各类编程资源大礼包什么都有">各类编程资源大礼包（什么都有）</h2><p>https://github.com/bayandin/awesome-awesomeness</p><h2 id="bash-handbook">bash-handbook</h2><p>https://github.com/denysdovhan/bash-handbook</p><h2 id="python资源大全">python资源大全</h2><p>https://github.com/jobbole/awesome-python-cn</p><h2 id="git学习资料">git学习资料</h2><p>https://github.com/xirong/my-git</p><h2 id="安卓开源代码解析">安卓开源代码解析</h2><p>https://github.com/android-cn/android-open-project-analysis</p><h2 id="python框架库资源大合集">python框架，库，资源大合集</h2><p>https://github.com/vinta/awesome-python</p><h2 id="js-正则表达式库用于简化构造复杂的js正则表达式">JS正则表达式库（用于简化构造复杂的JS正则表达式）</h2><p>https://github.com/VerbalExpressions/JSVerbalExpressions</p><h1 id="python">Python</h1><h2 id="python-正则表达式库用于简化构造复杂的python正则表达式">python正则表达式库（用于简化构造复杂的python正则表达式）</h2><p>https://github.com/VerbalExpressions/PythonVerbalExpressions</p><h2 id="python任务管理以及命令执行库">python任务管理以及命令执行库</h2><p>https://github.com/pyinvoke/invoke</p><h2 id="python-exe打包库">python exe打包库</h2><p>https://github.com/pyinstaller/pyinstaller</p><h2 id="py3-爬虫框架">py3 爬虫框架</h2><p>https://github.com/orf/cyborg</p><h2id="一个提供底层接口数据包编程和网络协议支持的python库">一个提供底层接口数据包编程和网络协议支持的python库</h2><p>https://github.com/CoreSecurity/impacket</p><h2 id="python-requests-库">python requests 库</h2><p>https://github.com/kennethreitz/requests</p><h2 id="python-实用工具合集">python 实用工具合集</h2><p>https://github.com/mahmoud/boltons</p><h2 id="python爬虫系统">python爬虫系统</h2><p>https://github.com/binux/pyspider</p><h2 id="ctf向-python工具包">ctf向 python工具包</h2><p>https://github.com/P1kachu/v0lt</p><h1 id="科学上网">科学上网</h1><h2 id="科学上网工具">科学上网工具</h2><p>https://github.com/XX-net/XX-Net</p><h1 id="老司机福利">老司机福利</h1><h2 id="微信自动抢红包动态库">微信自动抢红包动态库</h2><p>https://github.com/east520/AutoGetRedEnv</p><h2 id="微信抢红包插件安卓版">微信抢红包插件（安卓版）</h2><p>https://github.com/geeeeeeeeek/WeChatLuckyMoney</p><h2 id="神器">神器</h2><p>https://github.com/yangyangwithgnu/hardseed</p><h1 id="其他">其他</h1><p>以下内容来自：https://github.com/We5ter/Scanners-Box/blob/master/README_CN.md</p><h2 id="子域名枚举类">子域名枚举类</h2><p>https://github.com/lijiejie/subDomainsBrute(经典的子域名爆破枚举脚本)</p><p>https://github.com/ring04h/wydomain (子域名字典穷举)</p><p>https://github.com/le4f/dnsmaper (子域名枚举与地图标记)</p><p>https://github.com/0xbug/orangescan (在线子域名信息收集工具)</p><p>https://github.com/TheRook/subbrute （根据DNS记录查询子域名)</p><p>https://github.com/We5ter/GoogleSSLdomainFinder(基于谷歌SSL透明证书的子域名查询脚本)</p><p>https://github.com/mandatoryprogrammer/cloudflare_enum（使用CloudFlare进行子域名枚举的脚本）</p><p>https://github.com/18F/domain-scan (A domain scanner）</p><p>https://github.com/Evi1CLAY/Cool ...Python/DomainSeeker（多方式收集目标子域名信息）</p><h2 id="数据库漏洞扫描类">数据库漏洞扫描类</h2><p>https://github.com/0xbug/SQLiScanner(一款基于SQLMAP和Charles的被动SQL注入漏洞扫描工具)</p><p>https://github.com/stamparm/DSSS(99行代码实现的sql注入漏洞扫描器)</p><p>https://github.com/LoRexxar/Feigong（针对各种情况自由变化的MySQL注入脚本）</p><p>https://github.com/youngyangyang04/NoSQLAttack(一款针对mongoDB的攻击工具)</p><p>https://github.com/Neohapsis/bbqsql（SQL盲注利用框架）</p><p>https://github.com/NetSPI/PowerUpSQL（攻击SQLSERVER的Powershell脚本框架）</p><h2 id="弱口令或信息泄漏扫描类">弱口令或信息泄漏扫描类</h2><p>https://github.com/lijiejie/htpwdScan(一个简单的HTTP暴力破解、撞库攻击脚本)</p><p>https://github.com/lijiejie/BBScan(一个迷你的信息泄漏批量扫描脚本)</p><p>https://github.com/lijiejie/GitHack (.git文件夹泄漏利用工具)</p><p>https://github.com/wilson9x1/fenghuangscanner_v3(端口及弱口令检测)</p><p>https://github.com/ysrc/F-Scrack (对各类服务进行弱口令检测的脚本)</p><p>https://github.com/Mebus/cupp（根据用户习惯生成弱口令探测字典脚本）</p><p>https://github.com/RicterZ/genpAss （中国特色的弱口令生成器）</p><p>https://github.com/netxfly/crack_ssh （go写的协程版的ssh）</p><h2 id="物联网设备扫描">物联网设备扫描</h2><p>https://github.com/rapid7/IoTSeeker（物联网设备默认密码扫描检测工具)</p><p>https://github.com/shodan-labs/iotdb (使用nmap扫描IoT设备)</p><h2 id="xss扫描器">xss扫描器</h2><p>https://github.com/shawarkhanethicalhacker/BruteXSS （Cross-SiteScripting Bruteforcer）</p><p>https://github.com/1N3/XSSTracer (A small python script to check forCross-Site Tracing)</p><p>https://github.com/0x584A/fuzzXssPHP (PHP版本的反射型xss扫描)</p><p>https://github.com/chuhades/xss_scan (批量扫描xss的python脚本）</p><h2 id="企业网络自检">企业网络自检</h2><p>https://github.com/sowish/LNScan （详细的内部网络信息扫描器）</p><p>https://github.com/ysrc/xunfeng (网络资产识别引擎，漏洞检测引擎）</p><p>https://github.com/SkyLined/LocalNetworkScanner(javascript实现的本地网络扫描器)</p><p>https://github.com/laramies/theHarvester（企业被搜索引擎收录敏感资产信息监控脚本：员工邮箱、子域名、Hosts）</p><p>https://github.com/x0day/Multisearch-v2(bing、google、360、zoomeye等搜索引擎聚合搜索，可用于发现企业被搜索引擎收录的敏感资产信息）</p><h2 id="webshell检测">webshell检测</h2><p>https://github.com/We5ter/Scanners-Box/tree/master/Find_webshell/（php后门检测，脚本较简单，因此存在误报高和效率低下的问题）</p><p>https://github.com/yassineaddi/BackdoorMan （A toolkit findmalicious, hidden and suspicious PHP scripts and shells in a chosendestination）</p><h2 id="内网渗透">内网渗透</h2><p>https://github.com/0xwindows/VulScritp（企业内网渗透脚本，包括banner扫描、端口扫描；phpmyadmin、jenkins等通用漏洞利用等）</p><p>https://github.com/lcatro/networkbackdoorscanner（基于网络流量的内网探测框架）</p><p>https://github.com/fdiskyou/hunter（调用 Windows API枚举用户登录信息）</p><h2 id="中间件扫描指纹识别类">中间件扫描、指纹识别类</h2><p>https://github.com/ring04h/wyportmap(目标端口扫描+系统服务指纹识别)</p><p>https://github.com/ring04h/weakfilescan(动态多线程敏感信息泄露检测工具)</p><p>https://github.com/EnableSecurity/wafw00f (WAF产品指纹识别)</p><p>https://github.com/rbsec/sslscan （ssl类型识别)</p><p>https://github.com/urbanadventurer/whatweb (web指纹识别)</p><p>https://github.com/tanjiti/FingerPrint (web应用指纹识别)</p><p>https://github.com/nanshihui/Scan-T （网络爬虫式指纹识别)</p><p>https://github.com/OffensivePython/Nscan (a fast Network scannerinspired by Masscan and Zmap)</p><p>https://github.com/ywolf/F-NAScan (网络资产信息扫描,ICMP存活探测,端口扫描，端口指纹服务识别）</p><p>https://github.com/ywolf/F-MiddlewareScan （中间件扫描）</p><p>https://github.com/maurosoria/dirsearch (Web path scanner)</p><p>https://github.com/x0day/bannerscan （C段Banner与路径扫描）</p><p>https://github.com/RASSec/RASscan (端口服务扫描)</p><p>https://github.com/3xp10it/bypass_waf （waf自动暴破）</p><p>https://github.com/3xp10it/mytools/blob/master/xcdn.py（获取cdn背后的真实ip）</p><p>https://github.com/Xyntax/BingC（基于Bing搜索引擎的C段/旁站查询，多线程，支持API）</p><p>https://github.com/Xyntax/DirBrute（多线程WEB目录爆破工具）</p><p>https://github.com/zer0h/httpscan（一个爬虫式的网段Web主机发现小工具）</p><p>https://github.com/lietdai/doom（thorn上实现的分布式任务分发的ip端口漏洞扫描器）</p><h2 id="专用扫描器">专用扫描器</h2><p>https://github.com/blackye/Jenkins(Jenkins漏洞探测、用户抓取爆破)</p><p>https://github.com/code-scan/dzscan (discuz扫描)</p><p>https://github.com/chuhades/CMS-Exploit-Framework (CMS攻击框架)</p><p>https://github.com/lijiejie/IISshortnameScanner (an IIS shortnameScanner)</p><p>https://github.com/We5ter/Scanne ... ter/FlashScanner.pl(flashxss扫描)</p><p>https://github.com/coffeehb/SSTIF（一个Fuzzing服务器端模板注入漏洞的半自动化工具）</p><h2 id="无线网络">无线网络</h2><p>https://github.com/savio-code/fern-wifi-cracker/(无线安全审计工具)</p><p>https://github.com/m4n3dw0lf/PytheM（Python网络/渗透测试工具）</p><p>https://github.com/P0cL4bs/WiFi-Pumpkin（无线安全渗透测试套件）</p><h2 id="综合类">综合类</h2><p>https://github.com/az0ne/AZScanner(自动漏洞扫描器，子域名爆破，端口扫描，目录爆破，常用框架漏洞检测)</p><p>https://github.com/blackye/lalascan(自主开发的分布式web漏洞扫描框架，集合owasptop10漏洞扫描和边界资产发现能力)</p><p>https://github.com/blackye/BkScanner (BkScanner分布式、插件化web漏洞扫描器)</p><p>https://github.com/ysrc/GourdScanV2 （被动式漏洞扫描)</p><p>https://github.com/alpha1e0/pentestdb (WEB渗透测试数据库)</p><p>https://github.com/netxfly/passive_scan(基于http代理的web漏洞扫描器)</p><p>https://github.com/1N3/Sn1per(自动化扫描器，包括中间件扫描以及设备指纹识别)</p><p>https://github.com/RASSec/pentestEr_Fully-automatic-scanner（定向全自动化渗透测试工具）</p><p>https://github.com/3xp10it/3xp10it （3xp10it自动化渗透测试框架）</p><p>https://github.com/Lcys/lcyscan（python插件化漏洞扫描器）</p><p>https://github.com/Xyntax/POC-T（渗透测试插件化并发框架）</p><p>CTF平台 http://www.shiyanbar.com/</p><p>http://oj.xctf.org.cn/</p><p>http://ctf.bugku.com/</p><p>http://rookiehacker.org/</p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>课表与进度表</title>
    <link href="/post/%E8%AF%BE%E8%A1%A8%E4%B8%8E%E8%BF%9B%E5%BA%A6%E8%A1%A8.html"/>
    <url>/post/%E8%AF%BE%E8%A1%A8%E4%B8%8E%E8%BF%9B%E5%BA%A6%E8%A1%A8.html</url>
    
    <content type="html"><![CDATA[<h1 id="课表">课表</h1><p><imgsrc="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/4c21a9ae60a1b086dd311b78cec092a1.jpg"alt="四天早八课表" />)</p><h1 id="进度表">进度表</h1><figure><imgsrc="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/%E6%95%99%E5%AD%A6%E8%BF%9B%E5%BA%A6%E4%BF%A1%E5%AE%892331.png"alt="进度表" /><figcaption aria-hidden="true">进度表</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言练习题</title>
    <link href="/post/C%E8%AF%AD%E8%A8%80%E7%BB%83%E4%B9%A0%E9%A2%98.html"/>
    <url>/post/C%E8%AF%AD%E8%A8%80%E7%BB%83%E4%B9%A0%E9%A2%98.html</url>
    
    <content type="html"><![CDATA[<h1 id="打印输出1-30之间的所有素数">打印输出1-30之间的所有素数</h1><h2 id="思路">思路</h2><p>这个程序的目标是打印出1到30之间的所有素数。为了实现这个目标，我们首先需要一个函数来判断一个数是否为素数。这就是<code>is_prime</code>函数的作用。它接受一个整数作为参数，然后通过一个for循环来检查这个数是否可以被2到它的平方根之间的任何整数整除。如果可以，那么这个数就不是素数，函数返回0；否则，这个数就是素数，函数返回1。</p><p>然后在<code>main</code>函数中，我们使用一个for循环来遍历1到30的所有整数。对于每一个整数，我们都调用<code>is_prime</code>函数来检查它是否为素数。如果是，我们就使用<code>printf</code>函数将它打印出来。</p><h2 id="代码">代码</h2><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-0uefzxlu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-0uefzxlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br>    <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= num; i++) &#123;<br>        <span class="hljs-keyword">if</span> (num % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (is_prime(i)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></div></figure><h1id="输入6个整数仅用指针法实现按由大到小的顺序输出">输入6个整数，仅用指针法实现按由大到小的顺序输出</h1><h2 id="思路-1">思路</h2><p>这个程序的目标是接收用户输入的6个整数，并按照由大到小的顺序输出这些整数。为了实现这个目标，我们首先需要一个函数来对数组进行排序。这就是<code>sort</code>函数的作用。它接受一个整数指针和一个整数作为参数，整数指针指向我们要排序的数组，整数表示数组的长度。<code>sort</code>函数使用了冒泡排序算法，通过两层循环来比较并交换数组中的元素，从而实现排序。</p><p>然后在<code>main</code>函数中，我们首先定义了一个长度为6的整数数组。然后，我们使用一个for循环和<code>scanf</code>函数来接收用户输入的6个整数，并将这些整数存储在数组中。接着，我们调用<code>sort</code>函数来对数组进行排序。最后，我们使用一个for循环和<code>printf</code>函数来按照由大到小的顺序输出这6个整数。</p><h2 id="代码-1">代码</h2><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-0hedk8lu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-0hedk8lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (*(arr + i) &lt; *(arr + j)) &#123;<br>                <span class="hljs-type">int</span> temp = *(arr + i);<br>                *(arr + i) = *(arr + j);<br>                *(arr + j) = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">6</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入6个整数：\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr + i);<br>    &#125;<br>    sort(arr, <span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;由大到小的顺序输出为：\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *(arr + i));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></div></figure><h1 id="解释">解释</h1><h2 id="section">1</h2><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-0qwwqolu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-0qwwqolu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br></code></pre></td></tr></table></div></figure><p>这行代码包含了<code>stdio.h</code>头文件，它是C语言中提供输入/输出功能的库。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-lkzwa7lu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-lkzwa7lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">is_prime</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> &#123;<br></code></pre></td></tr></table></div></figure><p>这行代码定义了一个名为<code>is_prime</code>的函数，它接受一个整数<code>num</code>作为参数。这个函数用于检查<code>num</code>是否为素数。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-vqtisglu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-vqtisglu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></div></figure><p>如果<code>num</code>小于或等于1，那么它就不是素数，所以我们返回0。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-8mkntulu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-8mkntulu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= num; i++) &#123;<br></code></pre></td></tr></table></div></figure><p>这行代码是一个for循环，用于检查<code>num</code>是否可以被2到<code>sqrt(num)</code>之间的任何整数整除。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-409lfflu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-409lfflu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (num % i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></div></figure><p>如果<code>num</code>可以被<code>i</code>整除，那么<code>num</code>就不是素数，所以我们返回0。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-hgvxxnlu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-hgvxxnlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></div></figure><p>如果<code>num</code>不能被2到<code>sqrt(num)</code>之间的任何整数整除，那么<code>num</code>就是素数，所以我们返回1。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-g9w1mllu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-g9w1mllu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br></code></pre></td></tr></table></div></figure><p>这行代码定义了程序的主函数<code>main</code>。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-dol8x3lu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-dol8x3lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">30</span>; i++) &#123;<br></code></pre></td></tr></table></div></figure><p>这行代码是一个for循环，用于遍历1到30的所有整数。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-o9yjn1lu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-o9yjn1lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (is_prime(i)) &#123;<br></code></pre></td></tr></table></div></figure><p>这行代码调用我们之前定义的<code>is_prime</code>函数，检查当前的整数<code>i</code>是否为素数。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-oeeuvjlu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-oeeuvjlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);<br></code></pre></td></tr></table></div></figure><p>如果<code>i</code>是素数，我们就打印出来。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-2qsbm3lu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-2qsbm3lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></div></figure><p>这些是闭合前面的if语句和for循环的大括号，以及表示<code>main</code>函数的结束，<code>return 0;</code>表示程序执行成功。</p><h2 id="section-1">2</h2><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-5ug2c0lu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-5ug2c0lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br></code></pre></td></tr></table></div></figure><p>这行代码包含了<code>stdio.h</code>头文件，它是C语言中提供输入/输出功能的库。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-tgv09wlu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-tgv09wlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> n)</span> &#123;<br></code></pre></td></tr></table></div></figure><p>这行代码定义了一个名为<code>sort</code>的函数，它接受一个整数指针<code>arr</code>和一个整数<code>n</code>作为参数。<code>arr</code>指向我们要排序的数组，<code>n</code>是数组的长度。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-4no0gblu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-4no0gblu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br></code></pre></td></tr></table></div></figure><p>这两行代码是两个嵌套的for循环，用于遍历数组中的每一对元素。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-7tqlzclu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-7tqlzclu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (*(arr + i) &lt; *(arr + j)) &#123;<br></code></pre></td></tr></table></div></figure><p>这行代码检查当前的两个元素是否满足我们的排序条件（即第一个元素是否小于第二个元素）。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-51sgyxlu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-51sgyxlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> temp = *(arr + i);<br>*(arr + i) = *(arr + j);<br>*(arr + j) = temp;<br></code></pre></td></tr></table></div></figure><p>如果满足排序条件，我们就交换这两个元素的位置。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-9om8uilu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-9om8uilu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></div></figure><p>这些是闭合前面的if语句和for循环的大括号。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-x7w7zdlu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-x7w7zdlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br></code></pre></td></tr></table></div></figure><p>这行代码定义了程序的主函数<code>main</code>。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-f50c7hlu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-f50c7hlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">6</span>];<br></code></pre></td></tr></table></div></figure><p>这行代码定义了一个长度为6的整数数组<code>arr</code>。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-4njm8glu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-4njm8glu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入6个整数：\n&quot;</span>);<br></code></pre></td></tr></table></div></figure><p>这行代码打印出提示信息，告诉用户需要输入6个整数。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ex6m8qlu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-ex6m8qlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr + i);<br>&#125;<br></code></pre></td></tr></table></div></figure><p>这两行代码是一个for循环，用于从用户那里读取6个整数并存储在数组<code>arr</code>中。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-c4wz2plu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-c4wz2plu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">sort(arr, <span class="hljs-number">6</span>);<br></code></pre></td></tr></table></div></figure><p>这行代码调用我们之前定义的<code>sort</code>函数，对数组<code>arr</code>进行排序。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ppqbvjlu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-ppqbvjlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;由大到小的顺序输出为：\n&quot;</span>);<br></code></pre></td></tr></table></div></figure><p>这行代码打印出提示信息，告诉用户接下来将按照由大到小的顺序输出这6个整数。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-bd7j39lu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-bd7j39lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *(arr + i));<br>&#125;<br></code></pre></td></tr></table></div></figure><p>这两行代码是一个for循环，用于按照由大到小的顺序打印出这6个整数。</p><figure class="highlight c"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-rmzntzlu5obpg4"></i><span>c</span><div class="collapse show" id="collapse-rmzntzlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></div></figure><p>这行代码表示<code>main</code>函数的结束，<code>return 0;</code>表示程序执行成功。</p>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eNSP配置三层交换机</title>
    <link href="/post/eNSP%E9%85%8D%E7%BD%AE%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA.html"/>
    <url>/post/eNSP%E9%85%8D%E7%BD%AE%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA.html</url>
    
    <content type="html"><![CDATA[<h1 id="拓扑图">拓扑图</h1><figure><imgsrc="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%8B%93%E6%89%91%E5%9B%BE.png"alt="拓扑图" /><figcaption aria-hidden="true">拓扑图</figcaption></figure><h1 id="配置过程">配置过程</h1><h2 id="sw1配置">SW1配置</h2><figure class="highlight pf"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-38sx45lu5obpg4"></i><span>pf</span><div class="collapse show" id="collapse-38sx45lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pf">system-view  <span class="hljs-comment"># 进入系统视图</span><br>vlan batch <span class="hljs-number">10</span>  <span class="hljs-comment"># 创建vlan10</span><br>interface GigabitEthernet <span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">2</span>  <span class="hljs-comment"># 进入与PC1相连的接口</span><br><span class="hljs-keyword">port</span> link-type access <span class="hljs-comment"># 开启访问模式</span><br><span class="hljs-keyword">port</span> <span class="hljs-keyword">default</span> vlan <span class="hljs-number">10</span>  <span class="hljs-comment"># 分配vlan</span><br>interface GigabitEthernet <span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>  <span class="hljs-comment"># 进入与SW2相连的接口</span><br><span class="hljs-keyword">port</span> link-type trunk <span class="hljs-comment"># 开启trunk模式</span><br><span class="hljs-keyword">port</span> trunk allow-pass vlan <span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-comment"># 允许vlan10、20通过这个trunk端口</span><br></code></pre></td></tr></table></div></figure><h2 id="sw2配置">SW2配置</h2><figure class="highlight apache"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-qjfa5hlu5obpg4"></i><span>apache</span><div class="collapse show" id="collapse-qjfa5hlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">system</span>-view  # 进入系统视图<br><span class="hljs-attribute">vlan</span> batch <span class="hljs-number">10</span> <span class="hljs-number">20</span> # 创建vlan10、<span class="hljs-number">20</span><br><span class="hljs-attribute">interface</span> GigabitEthernet <span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">1</span> # 进入与SW1相连的接口<br><span class="hljs-attribute">port</span> link-type trunk # 开启trunk模式<br><span class="hljs-attribute">port</span> trunk <span class="hljs-literal">allow</span>-pass vlan <span class="hljs-number">10</span> <span class="hljs-number">20</span> # 允许vlan10、<span class="hljs-number">20</span>通过这个trunk端口<br><span class="hljs-attribute">interface</span> GigabitEthernet <span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">2</span> # 进入与SW3相连的接口<br><span class="hljs-attribute">port</span> link-type trunk # 开启trunk模式<br><span class="hljs-attribute">port</span> trunk <span class="hljs-literal">allow</span>-pass vlan <span class="hljs-number">10</span> <span class="hljs-number">20</span> # 允许vlan10、<span class="hljs-number">20</span>通过这个trunk端口<br><span class="hljs-attribute">interface</span> Vlanif <span class="hljs-number">10</span>  # 进入vlan10<br><span class="hljs-attribute">ip</span> address <span class="hljs-number">192.168.3.1</span> <span class="hljs-number">24</span> # 为vlan10设置IP<br><span class="hljs-attribute">interface</span> Vlanif <span class="hljs-number">20</span>  # 进入vlan20<br><span class="hljs-attribute">ip</span> address <span class="hljs-number">192.168.6.1</span> <span class="hljs-number">24</span> # 为vlan20设置IP<br></code></pre></td></tr></table></div></figure><h2 id="sw3配置">SW3配置</h2><figure class="highlight pf"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-liv730lu5obpg4"></i><span>pf</span><div class="collapse show" id="collapse-liv730lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pf">system-view  <span class="hljs-comment"># 进入系统视图</span><br>vlan batch <span class="hljs-number">20</span>  <span class="hljs-comment"># 创建vlan10</span><br>interface GigabitEthernet <span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">2</span>  <span class="hljs-comment"># 进入与PC1相连的接口</span><br><span class="hljs-keyword">port</span> link-type access <span class="hljs-comment"># 开启访问模式</span><br><span class="hljs-keyword">port</span> <span class="hljs-keyword">default</span> vlan <span class="hljs-number">20</span>  <span class="hljs-comment"># 分配vlan</span><br>interface GigabitEthernet <span class="hljs-number">0</span>/<span class="hljs-number">0</span>/<span class="hljs-number">1</span>  <span class="hljs-comment"># 进入与SW2相连的接口</span><br><span class="hljs-keyword">port</span> link-type trunk <span class="hljs-comment"># 开启trunk模式</span><br><span class="hljs-keyword">port</span> trunk allow-pass vlan <span class="hljs-number">10</span> <span class="hljs-number">20</span> <span class="hljs-comment"># 允许vlan10、20通过这个trunk端口</span><br></code></pre></td></tr></table></div></figure><h1 id="测试">测试</h1><figure><imgsrc="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/ping.png"alt="ping" /><figcaption aria-hidden="true">ping</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>网络设备</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eNSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络练习题</title>
    <link href="/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%83%E4%B9%A0%E9%A2%98.html"/>
    <url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%83%E4%B9%A0%E9%A2%98.html</url>
    
    <content type="html"><![CDATA[<h1 id="一填空题">一、填空题</h1><ol type="1"><li>按照网络覆盖的地理范围，计算机网络可以分为<strong>局域网</strong>、<strong>城域网</strong>和<strong>广域网</strong>。</li><li>广播网络传输方式有<strong>单播</strong>、<strong>广播</strong>和<strong>多播</strong>。</li><li>从功能上来看将计算机网路逻辑划分为<strong>客户端</strong>和<strong>服务器端</strong>。</li><li>从组网的层次角度来看，网络的组成结构是一个典型的三层网络机构，最上层称为<strong>核心层</strong>，中间层称为<strong>汇聚层</strong>，最下层称为<strong>接入层</strong>。</li><li>影响网络的因素有<strong>带宽</strong>、<strong>延迟</strong>、<strong>抖动</strong>和<strong>丢包</strong>。</li><li>OSI模型将网络分为<strong>物理层</strong>、<strong>数据链路层</strong>、<strong>网络层</strong>、<strong>传输层</strong>、<strong>会话层</strong>、<strong>表示层</strong>和<strong>应用层</strong>。</li><li>TCP/IP协议有四层，由下往上分别为<strong>网络接口层</strong>、<strong>网络层</strong>、<strong>传输层</strong>和<strong>应用层</strong>。</li><li>在TCP/IP协议中，网络层主要协议有<strong>IP</strong>、<strong>ICMP</strong>、<strong>ARP</strong>和<strong>RARP</strong>。</li><li>在TCP/IP协议中，传输层主要协议有<strong>TCP</strong>和<strong>UDP</strong>。</li><li>双绞线按结构可分为<strong>屏蔽双绞线</strong>和<strong>非屏蔽双绞线</strong>。</li><li>按传输模式分，光纤可分为<strong>单模光纤</strong>和<strong>多模光纤</strong>两类。</li><li>双绞线水晶头的制作标准有<strong>T568A</strong>和<strong>T568B</strong>两种。</li><li>交换机的互联方式主要有<strong>串行互联</strong>、<strong>并行互联</strong>、<strong>总线互联</strong>和<strong>星型互联</strong>。</li><li>局域网的体系结构涉及到了OSI模型的<strong>物理层</strong>和<strong>数据链路层</strong>两层。</li><li>802标准把局域网的数据链路层分为<strong>LLC子层</strong>和<strong>MAC子层</strong>两个子层。</li><li>常用的介质访问控制协议有三种：<strong>CSMA/CD</strong>、<strong>CSMA/CA</strong>和<strong>令牌环</strong>。</li><li>令牌环介质访问控制方法，是通过在环型网上传输<strong>令牌</strong>的方式来实现对介质的访问控制的。</li><li>IP地址由<strong>网络地址</strong>和<strong>主机地址</strong>两部分组成，前者用于该主机所在的网络，后者表示该主机在网络中的特定位置。</li><li>IPv6由<strong>128</strong>位二进制数组成。</li><li>以太网利用<strong>ARP</strong>协议获得主机IP地址与MAC地址的映射关系。</li><li>TCP连接包括<strong>三次握手</strong>、<strong>数据传输</strong>和<strong>四次挥手</strong>三个过程。</li><li>TCP采用<strong>滑动窗口</strong>机制实现流量控制功能。</li><li>Telnet服务系统采用<strong>C/S</strong>工作模式，主要由<strong>Telnet服务器</strong>、<strong>Telnet客户端</strong>和<strong>网络</strong>组成。</li><li>复用技术主要有<strong>频分复用</strong>、<strong>时分复用</strong>和<strong>码分复用</strong>三种。</li><li>交换技术主要有<strong>电路交换</strong>、<strong>报文交换</strong>和<strong>分组交换</strong>三种。</li><li>IPv6地址为2005：0610：0000：0001：0000：0000：0000：67ff，可压缩表示为<strong>2005:610::1:0:0:67ff</strong>。</li></ol><h1 id="二选择题">二、选择题</h1><ol type="1"><li>一座大楼内的计算机网络系统属于（<strong>B．LAN</strong>）。</li><li>世界上第一个计算机网络是（<strong>A．ARPANET</strong>）。</li><li>计算机互联的主要目的是（<strong>D．资源共享</strong>）。</li><li>计算机资源主要指计算机（<strong>C．硬件、软件与数据</strong>）。</li><li>在一台计算机上向另一台计算机发送电子邮件信息时，下面哪一项正确的描述了数据封装的五个步骤？（<strong>A．DataSegment Packet Frame Bit</strong>）。</li><li>将双绞线制作成交叉线，该双绞线连接的两个设备可为（<strong>A．网卡与网卡</strong>）。</li><li>采用5类双绞线所连接的以太网，理论上任意两台PC机的最大间隔距离是多少？（<strong>A．100m</strong>）。</li><li>以太网交换机根据（<strong>B．MAC地址</strong>）转发数据包。</li><li>MAC地址通常存储在计算机的（<strong>A．网卡上</strong>）。</li><li>在以太网中，冲突（<strong>C．是一种正常现象</strong>）。</li><li>以下IP地址中，属于B类地址的是（<strong>B．166.166.166.166</strong>）。</li><li>一个局域网中某台主机的IP地址为192.168.160.13，使用22位作为网络地址，那么该局域网的子网掩码为（<strong>D．255.255.240.0</strong>）。</li><li>下列地址属于单播地址的是（<strong>C．192.168.25.59/30</strong>）。</li><li>三次握手方法用于（<strong>A．传输层连接的建立</strong>）。</li><li>TCP是因特网中的（<strong>可靠的</strong>）协议，使用（<strong>三</strong>）次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答（<strong>SYN+ACK</strong>）。这种建立连接的方法可以防止（<strong>重复连接</strong>）。TCP使用的流量控制协议是（<strong>滑动窗口</strong>）。</li><li>在右图网络中，共有（ <strong>3</strong> ）个广播域，（<strong>3</strong> ）个冲突域。</li></ol><figure><imgsrc="https://picst.sunbangyan.cn/2023/12/24/ecdd0352d5b1b1b140be364ace1aab00.jpeg"alt="右图网络" /><figcaption aria-hidden="true">右图网络</figcaption></figure><h1 id="三简答题">三、简答题</h1><ol type="1"><li>OSI的七层模型及每一层的数据形式：</li></ol><figure class="highlight asciidoc"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-4nlo3zlu5obpg4"></i><span>asciidoc</span><div class="collapse show" id="collapse-4nlo3zlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>应用层（Application）：数据单位是报文（Message）<br><span class="hljs-bullet">- </span>表示层（Presentation）：数据单位是报文（Message）<br><span class="hljs-bullet">- </span>会话层（Session）：数据单位是报文（Message）<br><span class="hljs-bullet">- </span>传输层（Transport）：数据单位是段（Segment）<br><span class="hljs-bullet">- </span>网络层（Network）：数据单位是包（Packet）<br><span class="hljs-bullet">- </span>数据链路层（Data Link）：数据单位是帧（Frame）<br><span class="hljs-bullet">- </span>物理层（Physical）：数据单位是比特流（Bit）<br></code></pre></td></tr></table></div></figure><ol start="2" type="1"><li>TCP/IP的四层模型及上三层主要协议：</li></ol><figure class="highlight asciidoc"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-dr5vu1lu5obpg4"></i><span>asciidoc</span><div class="collapse show" id="collapse-dr5vu1lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>应用层：HTTP、FTP、SMTP、DNS等<br><span class="hljs-bullet">- </span>传输层：TCP、UDP<br><span class="hljs-bullet">- </span>网络层：IP、ICMP、ARP、RARP<br><span class="hljs-bullet">- </span>网络接口层<br></code></pre></td></tr></table></div></figure><ol start="3" type="1"><li><p><strong>FTTH</strong>（Fiber To TheHome）是一种光纤直接到户的宽带接入方式，它提供了极高的带宽，可以满足用户对高速互联网、数字电视、电话等多种业务的需求。<strong>ADSL</strong>（Asymmetric Digital SubscriberLine）是一种非对称数字用户线路，它利用电话线提供宽带接入服务，但上行和下行的带宽不对称。</p></li><li><p><strong>HTTP</strong>（HyperText TransferProtocol）是一种用于传输超文本的协议，主要用于网页浏览。<strong>DNS</strong>（Domain NameSystem）是一种用于将域名转换为IP地址的服务。 <strong>FTP</strong>（FileTransfer Protocol）是一种用于在网络上进行文件传输的协议。<strong>DHCP</strong>（Dynamic Host ConfigurationProtocol）是一种动态主机配置协议，用于自动分配IP地址。</p></li><li><p><strong>基带传输</strong>是指信号在传输过程中保持原始的形式和频率，通常用于短距离、高数据率的传输，如局域网。<strong>频带传输</strong>是指信号在传输过程中被调制到较高的频率，通常用于长距离、低数据率的传输，如电视广播。</p></li><li><p><strong>DNS</strong>有两种域名查询方式：<strong>递归查询</strong>和<strong>迭代查询</strong>。递归查询是指客户端向DNS服务器发出请求后，DNS服务器必须给出一个明确的回答。如果DNS服务器不知道答案，它会向其他服务器查询，直到得到一个明确的答案。迭代查询是指客户端向DNS服务器发出请求后，如果DNS服务器不知道答案，它会告诉客户端去向哪个服务器查询。</p></li><li><p><strong>VLAN</strong>的划分方式主要有以下几种：<strong>按端口划分</strong>、<strong>按MAC地址划分</strong>、<strong>按IP地址划分</strong>、<strong>按协议类型划分</strong>。</p></li></ol><h1 id="四计算题">四、计算题</h1><ol type="1"><li><p>一个主机的IP地址是202.112.14.137，掩码为255.255.255.224，求这个主机所在网络的网络地址和广播地址。</p><figure class="highlight dns"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-3nzo7elu5obpg4"></i><span>dns</span><div class="collapse show" id="collapse-3nzo7elu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns">IP地址：<span class="hljs-number">202.112.14.137</span> = <span class="hljs-number">11001010</span>.<span class="hljs-number">01110000</span>.<span class="hljs-number">00001110</span>.<span class="hljs-number">10001001</span><br>子网掩码：<span class="hljs-number">255.255.255.224</span> = <span class="hljs-number">11111111</span>.<span class="hljs-number">11111111</span>.<span class="hljs-number">11111111</span>.<span class="hljs-number">11100000</span><br>网络地址：将IP地址和子网掩码进行按位与运算，得到：<br><span class="hljs-number">11001010</span>.<span class="hljs-number">01110000</span>.<span class="hljs-number">00001110</span>.<span class="hljs-number">10000000</span> = <span class="hljs-number">202.112.14.128</span><br>广播地址：将网络地址的主机位全部置为<span class="hljs-number">1</span>，得到：<br><span class="hljs-number">11001010</span>.<span class="hljs-number">01110000</span>.<span class="hljs-number">00001110</span>.<span class="hljs-number">10011111</span> = <span class="hljs-number">202.112.14.159</span><br></code></pre></td></tr></table></div></figure></li></ol><p><strong>这个主机所在网络的网络地址是202.112.14.128，广播地址是202.112.14.159。</strong></p><ol start="2" type="1"><li>如下图，通过设置静态路由实现主机A能ping通主机B，则在路由器R1、R2、R3上分别要设置怎样的静态路由。</li></ol><figure><imgsrc="https://picss.sunbangyan.cn/2023/12/24/77d7eb09d59f96cbcfaa7a8d7108aace.jpeg"alt="拓扑图" /><figcaption aria-hidden="true">拓扑图</figcaption></figure><p>R1</p><table><thead><tr class="header"><th style="text-align: left;">Dest</th><th>Mask</th><th>GW</th><th>Interface</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">192.168.3.0</td><td>255.255.255.0</td><td>192.168.4.2</td><td>e1_1</td></tr></tbody></table><p>R2</p><table><thead><tr class="header"><th>Dest</th><th>Mask</th><th>GW</th><th>Interface</th></tr></thead><tbody><tr class="odd"><td>192.168.2.0</td><td>255.255.255.0</td><td>192.168.4.1</td><td>e1_1</td></tr><tr class="even"><td>192.168.3.0</td><td>255.255.255.0</td><td>192.168.6.2</td><td>e1_2</td></tr></tbody></table><p>R3</p><table><thead><tr class="header"><th>Dest</th><th>Mask</th><th>GW</th><th>Interface</th></tr></thead><tbody><tr class="odd"><td>192.168.2.0</td><td>255.255.255.0</td><td>192.168.6.1</td><td>e1_1</td></tr></tbody></table><h1 id="计算题解释">计算题解释</h1><h2 id="计算网络地址和广播地址">1、计算网络地址和广播地址</h2><ol type="1"><li><strong>计算网络地址</strong>：网络地址是通过将IP地址和子网掩码进行按位与运算得到的。按位与运算的规则是，如果两个对应的二进制位都为1，则结果为1，否则为0。因此，我们将IP地址和子网掩码对应的二进制位进行比较，如果都是1，则结果为1，否则为0。这样我们就得到了网络地址。</li><li><strong>计算广播地址</strong>：广播地址是通过将网络地址的主机位全部置为1得到的。在子网掩码中，网络位对应的是1，主机位对应的是0。因此，我们将网络地址中，对应子网掩码中0的那些位，全部置为1，就得到了广播地址。</li></ol><h2 id="配置静态路由">2、配置静态路由</h2><p>静态路由的设置是基于网络的拓扑结构和IP地址配置。在你的网络中，主机A需要通过路由器R1、R2、R3来访问主机B。因此，我们需要在每个路由器上设置适当的静态路由，以便数据包能够正确地从主机A路由到主机B。</p><p>对于路由器R1，我们需要设置一个静态路由，使得所有目标为主机B所在网络的数据包都会被发送到下一跳路由器R2。因此，我们将目标网络设置为主机B所在的网络，子网掩码设置为主机B所在网络的子网掩码，网关设置为R1到R2的接口IP，接口设置为R1到R2的接口。</p><p>对于路由器R2，我们需要设置两个静态路由。一个是使得所有目标为主机B所在网络的数据包都会被发送到下一跳路由器R3，另一个是使得所有目标为主机A所在网络的数据包都会被发送到下一跳路由器R1。因此，我们将目标网络设置为主机B和主机A所在的网络，子网掩码设置为主机B和主机A所在网络的子网掩码，网关设置为R2到R3和R2到R1的接口IP，接口设置为R2到R3和R2到R1的接口。</p><p>对于路由器R3，我们需要设置一个静态路由，使得所有目标为主机A所在网络的数据包都会被发送到下一跳路由器R2。因此，我们将目标网络设置为主机A所在的网络，子网掩码设置为主机A所在网络的子网掩码，网关设置为R3到R2的接口IP，接口设置为R3到R2的接口。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/post/hello-world.html"/>
    <url>/post/hello-world.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-itnqh9lu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-itnqh9lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></div></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ax7ufwlu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-ax7ufwlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></div></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ust8ealu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-ust8ealu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></div></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-b0y374lu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-b0y374lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></div></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开始</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何正确的食用Docker</title>
    <link href="/post/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%A3%9F%E7%94%A8Docker.html"/>
    <url>/post/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%A3%9F%E7%94%A8Docker.html</url>
    
    <content type="html"><![CDATA[<h1 id="docker简介">Docker简介</h1><h2 id="什么是docker">什么是Docker？</h2><p>Docker 是一个开源的应用容器引擎，基于 <ahref="https://www.runoob.com/go/go-tutorial.html">Go 语言</a> 并遵从Apache2.0 协议开源。</p><p>Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的app）,更重要的是容器性能开销极低。</p><h2 id="docker能干嘛">Docker能干嘛？</h2><p>软件开发最大的麻烦事之一，就是环境配置。而Docker可以十分方便的配置它们。</p><p>传统的虚拟机技术启动应用服务往往需要数分钟，而 <code>Docker</code>容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p><h2 id="docker的三个基本概念">Docker的三个基本概念</h2><p>Docker 包括三个基本概念：</p><ul><li><strong>镜像（image）</strong>：Docker镜像（image），相当于是一个root文件系统。例如官方镜像 Ubuntu: 16.04就包含了完整的一套 Ubuntu 16.04 最小系统的root文件系统。</li><li><strong>容器（Container）</strong>：容器（Container）<strong>由</strong>Docker 镜像（image）生成。一旦容器生成，就会同时存在两个文件： image文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</li><li><strong>仓库（Repository）</strong>：镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<ahref="https://docker-practice.github.io/zh-cn/repository/registry.html">DockerRegistry</a> 就是这样的服务。</li></ul><h1 id="安装docker">安装Docker</h1><p>Docker 分为 <code>stable</code> <code>test</code> 和<code>nightly</code> 三个更新频道。</p><p><a href="https://docs.docker.com/get-docker/">Get Docker | DockerDocumentation</a></p><h2 id="在ubuntu安装docker">在Ubuntu安装Docker</h2><p>Docker 支持以下版本的 <a href="https://ubuntu.com/server">Ubuntu</a>操作系统：</p><ul><li>Ubuntu Hirsute 21.04</li><li>Ubuntu Groovy 20.10</li><li>Ubuntu Focal 20.04 (LTS)</li><li>Ubuntu Bionic 18.04 (LTS)</li></ul><p>Docker 可以安装在 64 位的 x86 平台或 ARM 平台上。Ubuntu发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS版本。</p><h3 id="卸载旧版本docker">卸载旧版本Docker</h3><p>旧版本的 Docker 称为 <code>docker</code> 或者<code>docker-engine</code>，使用以下命令卸载旧版本：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-r2qgyvlu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-r2qgyvlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get remove docker \<br>             docker-engine \<br>             docker.io<br></code></pre></td></tr></table></div></figure><h3 id="使用-apt-安装">使用 APT 安装</h3><p>由于 <code>apt</code> 源使用 HTTPS以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS传输的软件包以及 CA 证书。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-m60hr5lu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-m60hr5lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get udate<br><br>sudo apt-get install \<br>apt-transport-https \<br>    ca-certificates \<br>    curl \<br>    gnupg \<br>    lsb-release<br></code></pre></td></tr></table></div></figure><p>为了确认所下载软件包的合法性，需要添加软件源的 <code>GPG</code>密钥。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-wk64c8lu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-wk64c8lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br><br><span class="hljs-comment"># 官方源</span><br>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg<br></code></pre></td></tr></table></div></figure><p>向<code>sources.list</code>中添加 Docker 软件源</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-bpjleylu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-bpjleylu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> \<br>  <span class="hljs-string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \</span><br><span class="hljs-string">  <span class="hljs-subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null<br><br><span class="hljs-comment"># 官方源</span><br><span class="hljs-comment"># $ echo \</span><br><span class="hljs-comment">#   &quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span><br><span class="hljs-comment">#   $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></code></pre></td></tr></table></div></figure><h3 id="安装-docker">安装 Docker</h3><p>更新 apt 软件包缓存，并安装 <code>docker-ce</code>：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-dywnhclu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-dywnhclu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br>sudo apt-get install docker-ce docker-ce-cli containerd.io docker-compose-plugin<br></code></pre></td></tr></table></div></figure><h3 id="启动-docker">启动 Docker</h3><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ctdlhqlu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-ctdlhqlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> docker<br>sudo systemctl start docker<br></code></pre></td></tr></table></div></figure><h3 id="建立-docker-用户组">建立 Docker 用户组</h3><p>默认情况下，<code>docker</code> 命令会使用 <ahref="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a>与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code>组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用<code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立<code>docker</code>组：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-oapxx4lu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-oapxx4lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo groupadd docker<br></code></pre></td></tr></table></div></figure><p>将当前用户加入<code>docker</code>组：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-you528lu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-you528lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo usermod -aG docker <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></div></figure><h2 id="在centos安装docker">在CentOS安装Docker</h2><p>切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker</p><p>Docker 支持 64 位版本 CentOS 7/8，并且要求内核版本不低于 3.10。CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如<code>overlay2</code>存储层驱动）无法使用，并且部分功能可能不太稳定。</p><h3 id="卸载旧版本docker-1">卸载旧版本Docker</h3><p>旧版本的 Docker 称为 <code>docker</code> 或者<code>docker-engine</code>，使用以下命令卸载旧版本：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-kp6s0qlu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-kp6s0qlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum remove docker \<br>                docker-client \<br>                docker-client-latest \<br>                docker-common \<br>                docker-latest \<br>                docker-latest-logrotate \<br>                docker-logrotate \<br>                docker-selinux \<br>                docker-engine-selinux \<br>                docker-engine<br></code></pre></td></tr></table></div></figure><h3 id="使用-yum-安装">使用 yum 安装</h3><p>安装依赖包：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-xf4kjulu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-xf4kjulu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install -y yum-utils<br></code></pre></td></tr></table></div></figure><p>添加<code>yum</code>软件源：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-qob2ntlu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-qob2ntlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum-config-manager \<br>--add-repp \<br>https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br>sudo sed -i <span class="hljs-string">&#x27;s/download.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27;</span> /etc/yum.repos.d/docker-ce.repo<br><br><span class="hljs-comment"># 官方源</span><br>sudo yum-config-manager \<br>--add-repp<br>https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></div></figure><p>如需测试版本的Docker：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ikhy4nlu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-ikhy4nlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum-config-manager --<span class="hljs-built_in">enable</span> docker-ce-test<br></code></pre></td></tr></table></div></figure><h3 id="安装-docker-1">安装 Docker</h3><p>更新 <code>yum</code> 软件源缓存，并安装 <code>docker-ce</code>。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-tc7jh1lu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-tc7jh1lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin<br></code></pre></td></tr></table></div></figure><h3 id="centos8的额外设置">CentOS8的额外设置</h3><p>由于 CentOS8 防火墙使用了 <code>nftables</code>，但 Docker 尚未支持<code>nftables</code>， 我们可以使用如下设置使用<code>iptables</code>：</p><p>更改 <code>/etc/firewalld/firewalld.conf</code></p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-rd3d21lu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-rd3d21lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># FirewallBackend=nftables</span><br>FirewallBackend=iptables<br></code></pre></td></tr></table></div></figure><p>或执行以下命令：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-sa7dwslu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-sa7dwslu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">firewall-cmd --permanent --zone=trusted --add-interface=docker0<br>firewall-cmd --reload<br></code></pre></td></tr></table></div></figure><h3 id="启动-docker-1">启动 Docker</h3><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-iwx5mqlu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-iwx5mqlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl <span class="hljs-built_in">enable</span> docker<br>sudo systemctl start docker<br></code></pre></td></tr></table></div></figure><h3 id="建立-docker-用户组-1">建立 Docker 用户组</h3><p>默认情况下，<code>docker</code> 命令会使用 <ahref="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a>与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code>组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用<code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-nlm8ahlu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-nlm8ahlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo groupadd docker<br></code></pre></td></tr></table></div></figure><p>将当前用户加入<code>docker</code>组：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-uwmwrnlu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-uwmwrnlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo usermod -aG docekr <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></div></figure><h3 id="添加内核参数">添加内核参数</h3><p>如果在 CentOS 使用 Docker 看到下面的这些警告信息：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-8nz8a2lu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-8nz8a2lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">WARNING: bridge-nf-call-iptables is disabled<br>WARNING: bridge-nf-call-ip6tables is disabled<br></code></pre></td></tr></table></div></figure><p>添加内核配置参数以启用这些功能</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-mlr5xylu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-mlr5xylu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">tee</span> -a /etc/sysctl.conf &lt;&lt;-<span class="hljs-string">EOF</span><br><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="hljs-string">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></div></figure><p>重新加载<code>sysctl.conf</code>即可</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-5uzh57lu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-5uzh57lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo sysctl -p<br></code></pre></td></tr></table></div></figure><h1 id="docker食用指南">Docker食用指南</h1><h2 id="镜像使用指南">镜像使用指南</h2><p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker会从镜像仓库下载该镜像。</p><h3 id="获取镜像">获取镜像</h3><p>从 Docker 镜像仓库获取镜像的命令是<code>docker pull</code>。命令格式是：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-2d4xd7lu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-2d4xd7lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull [OPTIONS] NAME[:TAG|@DIGEST]<br></code></pre></td></tr></table></div></figure><p><strong>参数说明：</strong></p><ul><li>TAG：标签（版本）</li><li>DIGEST：摘要</li><li>OPTIONS：<ul><li>-a ：下载镜像仓库中所有的指定镜像；</li><li>–disable-content-trust：跳过镜像验证（默认值是true）；</li><li>–platform： 如果服务具有多平台功能，则设置平台；</li><li>-q：一直详细输出；</li></ul></li></ul><p>具体选项可以通过<code>docker pull --help</code>命令查看。</p><p><strong>例子如下：</strong></p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-jbbg3qlu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-jbbg3qlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker pull ubuntu:18.04<br>18.04: Pulling from library/ubuntu<br>92dc2a97ff99: Pull complete<br>be13a9d27eb8: Pull complete<br>c8299583700a: Pull complete<br>Digest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26<br>Status: Downloaded newer image <span class="hljs-keyword">for</span> ubuntu:18.04<br>docker.io/library/ubuntu:18.04<br></code></pre></td></tr></table></div></figure><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub（<code>docker.io</code>）获取镜像。而镜像名称是<code>ubuntu:18.04</code>，因此将会获取官方镜像<code>library/ubuntu</code> 仓库中标签为 <code>18.04</code>的镜像。<code>docker pull</code>命令的输出结果最后一行给出了镜像的完整名称，即：<code>docker.io/library/ubuntu:18.04</code>。</p><ul><li>Docker镜像仓库地址：地址的格式一般是<code>域名/IP[:端口号]</code>。默认地址是Docker Hub（<code>docker.io</code>）。</li><li>仓库名：仓库名是两段式名称，即<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于DockerHub，如果没有指定用户名，则默认是<code>library</code>，也就是官方镜像。</li></ul><h4 id="运行">运行</h4><p>有了镜像后，可以以这个镜像为基础启动并运行一个容器。以上面的<code>Ubuntu:18.04</code>为例，如果打算启动里面的<code>bash</code>并且进行交互式操作的话，可以执行以下命令：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-uch6yslu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-uch6yslu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -it --<span class="hljs-built_in">rm</span> ubuntu:18:04 bash<br><br><span class="hljs-comment"># 以下是容器内操作</span><br>root@e7009c6ce357:/<span class="hljs-comment"># cat /etc/os-release</span><br>NAME=<span class="hljs-string">&quot;Ubuntu&quot;</span><br>VERSION=<span class="hljs-string">&quot;18.04.1 LTS (Bionic Beaver)&quot;</span><br>ID=ubuntu<br>ID_LIKE=debian<br>PRETTY_NAME=<span class="hljs-string">&quot;Ubuntu 18.04.1 LTS&quot;</span><br>VERSION_ID=<span class="hljs-string">&quot;18.04&quot;</span><br>HOME_URL=<span class="hljs-string">&quot;https://www.ubuntu.com/&quot;</span><br>SUPPORT_URL=<span class="hljs-string">&quot;https://help.ubuntu.com/&quot;</span><br>BUG_REPORT_URL=<span class="hljs-string">&quot;https://bugs.launchpad.net/ubuntu/&quot;</span><br>PRIVACY_POLICY_URL=<span class="hljs-string">&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;</span><br>VERSION_CODENAME=bionic<br>UBUNTU_CODENAME=bionic<br></code></pre></td></tr></table></div></figure><p><code>docker run</code>就是要运行容器的命令，这里简单说明一下上面用到的参数</p><ul><li><code>-it</code>：这是两个参数，一个是<code>-i</code>：交互式操作，一个是 <code>-t</code>终端。我们这里打算进入 <code>bash</code>执行一些命令并查看返回结果，因此我们需要交互式终端。</li><li><code>--rm</code>：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动<code>docker rm</code>。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用<code>--rm</code> 可以避免浪费空间。</li><li><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code>镜像为基础来启动容器。</li><li><code>bash</code>：放在镜像名后的是<strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是<code>bash</code>。</li></ul><p>进入容器后就可以在 Shell下操作执行任何所需的命令。例如，上面就执行了<code>cat /etc/os-release</code>，这是Linux常用的查看当前系统版本的命令，从返回的结果可以看到容器内是<code>Ubuntu 18.04.1 LTS</code>系统。</p><p>最后可以通过<code>exit</code>退出这个容器。</p><h3 id="列出镜像">列出镜像</h3><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code>命令。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-fgweh3lu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-fgweh3lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span><br>REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE<br>redis                latest              5f515359c7f8        5 days ago          183 MB<br>nginx                latest              05a60462f8ba        5 days ago          181 MB<br>mongo                3.2                 fe9198c04d62        5 days ago          342 MB<br>&lt;none&gt;               &lt;none&gt;              00285df0df87        5 days ago          342 MB<br>ubuntu               18.04               329ed837d508        3 days ago          63.3MB<br>ubuntu               bionic              329ed837d508        3 days ago          63.3MB<br></code></pre></td></tr></table></div></figure><p>列表包含了<code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code>以及 <code>所占用的空间</code>。</p><p>其中仓库名、标签在之前的基础概念章节已经介绍过了。<strong>镜像ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个<strong>标签</strong>。因此，在上面的例子中，我们可以看到<code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的ID，因为它们对应的是同一个镜像。</p><h4 id="镜像体积">镜像体积</h4><p>DockerHub上显示的镜像体积是压缩后的体积大小，在镜像上传和下载的过程中镜像是保持压缩状态的。而使用命令<code>docker image ls</code>显示的是镜像下载到本地后展开的大小，准确说，是展开后的各层所占空间的总和。</p><p>另外一个需要注意的问题是，<code>docker image ls</code>列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。相同的层只需要保存一份即可。</p><p>通过<code>docker system df</code>命令来查看镜像、容器、数据卷所占用的空间。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-jk33tmlu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-jk33tmlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker system <span class="hljs-built_in">df</span><br>TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE<br>Images          2         1         390.2MB   390.2MB (99%)<br>Containers      1         0         0B        0B<br>Local Volumes   0         0         0B        0B<br>Build Cache     18        0         789B      789B<br></code></pre></td></tr></table></div></figure><h4 id="列出部分镜像">列出部分镜像</h4><p>不加任何参数的情况下，<code>docker image ls</code>会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code>有好几个参数可以帮助做到这个事情。</p><p>根据仓库名列出仓库</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ssxcc4lu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-ssxcc4lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span> ubuntu<br>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE<br>ubuntu       latest    ba6acccedd29   23 months ago   72.8MB<br>ubuntu       18.04     5a214d77f5d7   23 months ago   63.1MB<br></code></pre></td></tr></table></div></figure><p>列出特定的某个镜像，也就是说指定仓库名和标签</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-t7i84flu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-t7i84flu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">ls</span> ubuntu:18.04<br>REPOSITORY   TAG       IMAGE ID       CREATED         SIZE<br>ubuntu       18.04     5a214d77f5d7   23 months ago   63.1MB<br></code></pre></td></tr></table></div></figure><h3 id="删除本地镜像">删除本地镜像</h3><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code>命令，其格式为：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-g1nwvklu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-g1nwvklu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker image <span class="hljs-built_in">rm</span> [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]<br></code></pre></td></tr></table></div></figure><p>其中，<code>&lt;镜像&gt;</code> 可以是<code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者<code>镜像摘要</code>。</p><p>我们可以用镜像的完整 ID，也称为<code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code>来删除镜像。<code>docker image ls</code> 默认列出的就已经是短 ID了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p><h2 id="操作容器">操作容器</h2><h4 id="启动容器">启动容器、</h4><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p><p>因为 Docker的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><h1 id="未完待续">未完待续</h1><h1 id="参考文章">参考文章</h1><p>更多详细教程请参考 <ahref="https://docker-practice.github.io/zh-cn/">前言 · Docker --从入门到实践 (docker-practice.github.io)</a></p><p><ahref="https://blog.csdn.net/zhuzicc/article/details/118066353">Docker“pull“命令获取镜像，讲道理你真的会吗？_dockerpull_zhuzicc的博客-CSDN博客</a></p><p><a href="https://www.runoob.com/docker/docker-tutorial.html">Docker教程 | 菜鸟教程 (runoob.com)</a></p><p><ahref="https://zhuanlan.zhihu.com/p/435605760">全面的Docker快速入门教程 -知乎 (zhihu.com)</a></p><p><ahref="https://ruanyifeng.com/blog/2018/02/docker-tutorial.html">Docker入门教程 - 阮一峰的网络日志 (ruanyifeng.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用tmux（终端工具）</title>
    <link href="/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tmux%EF%BC%88%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%EF%BC%89.html"/>
    <url>/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tmux%EF%BC%88%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%EF%BC%89.html</url>
    
    <content type="html"><![CDATA[<h1 id="什么是tmux">什么是tmux</h1><p>Tmux 是一个终端复用器（terminal multiplexer）</p><p>tmux 有主要两个用途：</p><ol type="1"><li>分屏。既可以同时使用多个命令行；</li><li>会话与窗口解绑。当窗口意外关闭时，会话并不会终止，后面需要的时候，会话可以再次绑定窗口。尤其当使用SSH远程登录计算机时，可以不受断网的影响。</li></ol><h1 id="基本使用">基本使用</h1><h2 id="安装tmux">安装tmux</h2><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-5su29slu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-5su29slu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ubantu or Debian</span><br>sudo apt-get install tmux<br><br><span class="hljs-comment"># Centos or Fedora</span><br>sudo yum install tmux<br><br><span class="hljs-comment"># Mac</span><br>brew install tmux<br></code></pre></td></tr></table></div></figure><h2 id="启动退出">启动、退出</h2><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-ga1xuflu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-ga1xuflu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmux<br></code></pre></td></tr></table></div></figure><p>在终端输入以上命令即可启动tmux，启动后终端底部会显示一个状态栏。</p><p>左侧是窗口信息（编号和名称），右侧是系统信息。</p><figure><imgsrc="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tmux%EF%BC%88%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%EF%BC%89/image-20230606181115946.png"alt="image-20230606181115946" /><figcaption aria-hidden="true">image-20230606181115946</figcaption></figure><p>按下<code>Ctrl + d</code>或者在终端输入<code>exit</code>即可退出tmux。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-5fstwklu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-5fstwklu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></div></figure><h2 id="tmux术语">tmux术语</h2><p>tmux 采用 client/server模型，主要有四个模块：</p><ul><li>server：服务。tmux运行的基础服务，以下模块均依赖于此服务；</li><li>session：会话。一个服务可以包含多个会话；</li><li>window：窗口。一个会话可以包含多个窗口；</li><li>panel：窗格/面板。一个窗口可以包含多个窗格。</li></ul><p>执行 tmux命令时，即开启了一个服务，并创建了一个会话、窗口和窗格。</p><h2 id="前缀键">前缀键</h2><p>Tmux窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是<code>Ctrl+b</code>，即先按下<code>Ctrl+b</code>，快捷键才会生效。</p><p>举例来说，帮助命令的快捷键是<code>Ctrl+b ?</code>。它的用法是，在Tmux窗口中，先按下<code>Ctrl+b</code>，再按下<code>?</code>，就会显示帮助信息。</p><p>然后，按下 ESC 键或<code>q</code>键，就可以退出帮助。</p><h1 id="tmux会话管理">Tmux会话管理</h1><h2 id="新建会话">新建会话</h2><p>第一个启动的 Tmux 窗口，编号是 <code>0</code>，第二个窗口的编号是<code>1</code>，以此类推。这些窗口对应的会话，就是 0 号会话、1号会话。</p><p>使用编号区分会话，不太直观，更好的方法是为会话起名。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-loc6lrlu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-loc6lrlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmux new -s &lt;your-session-name&gt;<br></code></pre></td></tr></table></div></figure><p>上面命令新建一个指定名称的会话。</p><h2 id="分离会话">分离会话</h2><p>在 Tmux 窗口中，按下 <code>Ctrl+b d</code> 或者输入<code>tmux detach</code> 命令，就会将当前会话与窗口分离。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-nu3jiulu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-nu3jiulu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmux detach<br></code></pre></td></tr></table></div></figure><p>上面命令执行后，就会退出当前 Tmux窗口，但是会话和里面的进程仍然在后台运行。</p><p><code>tmux ls</code> 命令可以查看当前所有的 Tmux 会话。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-rlqv6ilu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-rlqv6ilu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmux <span class="hljs-built_in">ls</span><br><span class="hljs-comment"># or</span><br>tmux list-session<br></code></pre></td></tr></table></div></figure><figure><imgsrc="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tmux%EF%BC%88%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%EF%BC%89/image-20230606182214934.png"alt="image-20230606182214934" /><figcaption aria-hidden="true">image-20230606182214934</figcaption></figure><h2 id="接入会话">接入会话</h2><p>在终端输入<code>tmux attach</code>用于重新接入某个已存在的会话。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-r26nm4lu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-r26nm4lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用会话编号接入会话</span><br>tmux attach -t 0<br><br><span class="hljs-comment"># 使用会话名称接入会话</span><br>tmux attach -t &lt;your-session-name&gt;<br></code></pre></td></tr></table></div></figure><h2 id="kill会话">kill会话</h2><p>在终端输入<code>tmux kill-session</code>用于杀死某个已存在的会话。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-c4fdrelu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-c4fdrelu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用会话编号结束会话</span><br>tmux kill-sesion -t 0<br><br><span class="hljs-comment"># 使用会话名称结束会话</span><br>tmux kill-sesion -t &lt;your-session-name&gt;<br></code></pre></td></tr></table></div></figure><h2 id="切换会话">切换会话</h2><p>在终端输入<code>tmux switch</code>以切换会话。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-04u7lalu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-04u7lalu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用会话编号切换会话</span><br>tmux switch -t 0<br><br><span class="hljs-comment"># 使用会话名称切换会话</span><br>tmux switch -t &lt;session-name&gt;<br></code></pre></td></tr></table></div></figure><h2 id="重命名会话">重命名会话</h2><p>在终端输入<code>tmux rename-session</code>以重命名会话。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-69tks9lu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-69tks9lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmux rename-session -t 0 &lt;new-name&gt;<br></code></pre></td></tr></table></div></figure><p>以上命令会将<code>0</code>号会话重命名。</p><h1 id="快捷键">快捷键</h1><p>tmux大部分操作都可以用快捷键来代替。</p><p>使用快捷键的前提是先按下了<code>Ctrl + b</code></p><p>使用<code>tmux list-keys</code>可以列出所有快捷键。</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-3vj172lu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-3vj172lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tmux list-keys<br></code></pre></td></tr></table></div></figure><h2 id="会话快捷键">会话快捷键</h2><ul><li>s ：列出所有会话，也可以在列表中用鼠标或上下键切换会话</li><li>d ：离开当前会话</li><li>$ ：重命名当前会话</li></ul><h2 id="窗口快捷键">窗口快捷键</h2><ul><li>c ： 创建一个新窗口</li><li>n ： 切换到下一个窗口</li><li>w ： 从列表中选择窗口</li><li>&lt;0~9&gt; ： 切换到指定标号的窗口，编号显示在状态栏</li><li>,（这是一个英文逗号） : 将窗口重命名</li></ul><p>一个<code>session</code>中可以有很多个窗口，可以在状态栏中查看，如：</p><figure><imgsrc="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8tmux%EF%BC%88%E7%BB%88%E7%AB%AF%E5%B7%A5%E5%85%B7%EF%BC%89/image-20230606184635853.png"alt="image-20230606184635853" /><figcaption aria-hidden="true">image-20230606184635853</figcaption></figure><p>其中：</p><p><code>[key]</code>表示的是当前会话的名称。</p><p><code>0：zsh-</code>表示的是0号窗口，<code>zsh</code>是窗口的名字。</p><p>窗口名字后的<code>*</code>号代表当前显示的窗口。</p><p>而右侧显示的是用户名、当前时间、当前日期。</p><h2 id="窗格快捷键">窗格快捷键</h2><ul><li>% ： 将窗口分成<strong>左右</strong>两个窗格。</li><li>"（这是一个英文双引号）：将窗口分成<strong>上下</strong>两个窗格。</li><li>z ： 将当前窗格<strong>全屏显示</strong>，再按一次恢复。</li><li>q ： 显示窗格编号。</li><li>t ： 再当前窗格显示时间。</li><li>o ： 将光标切换到下个一个窗格。</li><li>&lt;arrow key&gt; ：将光标切换到其他窗格。使用<strong>上下左右方向键</strong>进行切换</li><li>{ ： 将当前窗格<strong>左移</strong>。</li><li>} ： 将当前窗格<strong>右移</strong>。</li><li>Ctrl + o ： 将当前窗格<strong>上移</strong>。</li><li>Alt + o ： 将当前窗格<strong>下移</strong>。</li><li>space（空格键） ： 切换窗格布局。</li><li>x ： 删除当前窗格。</li></ul><h1 id="配置tmux支持鼠标">配置tmux支持鼠标</h1><p>鼠标支持的内容：</p><ul><li>用鼠标点击窗格来激活该窗格；</li><li>用鼠标拖动调节窗格的大小（拖动位置是窗格之间的分隔线）；</li><li>用鼠标点击来切换活动窗口（点击位置是状态栏的窗口名称）；</li><li>开启窗口/窗格里面的鼠标支持，用鼠标回滚显示窗口内容，按下shift的同时用鼠标选取文本，使用ctrl+shift+c、ctrl+shift+v 的方式进行复制粘贴。</li></ul><p>配置方式为在 ~/.tmux.conf 文件中，增加：</p><figure class="highlight bash"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-0dty26lu5obpg4"></i><span>bash</span><div class="collapse show" id="collapse-0dty26lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">set-option -g mouse on<br></code></pre></td></tr></table></div></figure><h1 id="参考文章">参考文章</h1><ol type="1"><li><ahref="https://zhuanlan.zhihu.com/p/137715607">https://zhuanlan.zhihu.com/p/137715607</a></li><li><ahref="https://www.cnblogs.com/niuben/p/15983908.html">https://www.cnblogs.com/niuben/p/15983908.html</a></li><li><ahref="https://www.ruanyifeng.com/blog/2019/10/tmux.html">https://www.ruanyifeng.com/blog/2019/10/tmux.html</a></li><li><ahref="https://blog.csdn.net/CSSDCC/article/details/121231906">https://blog.csdn.net/CSSDCC/article/details/121231906</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>地毯模组（Carpet）的使用教程</title>
    <link href="/post/%E5%9C%B0%E6%AF%AF%E6%A8%A1%E7%BB%84%EF%BC%88Carpet%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html"/>
    <url>/post/%E5%9C%B0%E6%AF%AF%E6%A8%A1%E7%BB%84%EF%BC%88Carpet%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html</url>
    
    <content type="html"><![CDATA[<p>Carpet中文百科</p><p><a href="https://www.mcmod.cn/class/2361.html">Carpet -MC百科|最大的Minecraft中文MOD百科 (mcmod.cn)</a></p><p>本文仅从以上链接中的教程总结出较为常用的命令</p><h1 id="player">/player</h1><p>/player命令可以控制在线玩家或者假玩家。</p><h2 id="生成与清除">生成与清除</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-bpftw5lu5obpg4"></i><span>MC-CMD</span><div class="collapse show" id="collapse-bpftw5lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; spawn<br></code></pre></td></tr></table></div></figure><p>该命令会在玩家所在位置生成一个名为<target>的玩家，无论是否真实存在，并且保持与执行者一样的视角和游戏模式。</p><p>如果生成的玩家真实存在，则该玩家上线时将顶替掉生成的假玩家，并恢复原先的游戏模式。</p><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-qrtc1ilu5obpg4"></i><span>MC-CMD</span><div class="collapse show" id="collapse-qrtc1ilu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; kill<br></code></pre></td></tr></table></div></figure><p>该命令会使假玩家退出当前存档或者服务器，同时保留他身上的物品。</p><p>该命令只对假玩家有效。</p><p>如果原版游戏规则keepInventory设为false，击杀生存模式的假玩家会使该玩家掉落身上的所有物品。</p><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-fvjg5rlu5obpg4"></i><span>MC-CMD</span><div class="collapse show" id="collapse-fvjg5rlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; shadow<br></code></pre></td></tr></table></div></figure><p>该命令会将目标玩家踢出存档或服务器，并在他的相同位置生成一个名称相同的假玩家。</p><p>该命令只对当前正在游玩的真玩家有效。</p><h2 id="移动">移动</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-gxfx6jlu5obpg4"></i><span>MC-CMD</span><div class="collapse show" id="collapse-gxfx6jlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; look &lt;direction&gt;<br></code></pre></td></tr></table></div></figure><p>该命令会让玩家看向一定的方向。&lt;direction&gt;可以是：</p><ul><li>north（北）、south（南）、west（西）、east（东）、up（上）、down（下）；</li><li>at：让玩家看向某个位置。后面还需要跟玩家要看向的位置的坐标。</li></ul><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-3y3vc6lu5obpg4"></i><span>MC-CMD</span><div class="collapse show" id="collapse-3y3vc6lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; move &lt;direction&gt;<br></code></pre></td></tr></table></div></figure><p>该命令会让玩家按照指定的方向持续移动。&lt;direction&gt;可以是backward（后），forward（前），left（左），right（右）。</p><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-hda3tclu5obpg4"></i><span>MC-CMD</span><div class="collapse show" id="collapse-hda3tclu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; jump [&lt;option&gt;]<br></code></pre></td></tr></table></div></figure><p>该命令会让玩家跳跃一次。</p><p>可以使用[&lt;option&gt;]参数指定跳跃模式。[&lt;option&gt;]可以是：</p><ul><li>continuous：让玩家连续跳跃。</li><li>interval：让玩家每隔一定游戏刻跳跃一次。该参数要求后面再跟一个参数，指定跳跃间隔的游戏刻数。</li><li>once：让玩家跳跃一次，与默认情况相同。</li></ul><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-0ezi6nlu5obpg4"></i><span>MC-CMD</span><div class="collapse show" id="collapse-0ezi6nlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; sneak<br>/player &lt;target&gt; unsneak<br></code></pre></td></tr></table></div></figure><p>这两个命令可以分别让玩家潜行和取消潜行。</p><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-jjshqolu5obpg4"></i><span>MC-CMD</span><div class="collapse show" id="collapse-jjshqolu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; sprint<br>/player &lt;target&gt; unsprint<br></code></pre></td></tr></table></div></figure><p>这两个命令可以分别让玩家疾跑和停止疾跑。</p><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-od6z1plu5obpg4"></i><span>MC-CMD</span><div class="collapse show" id="collapse-od6z1plu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs MC-CMD">/player &lt;target&gt; turn &lt;option&gt;<br></code></pre></td></tr></table></div></figure><p>该命令可以让玩家的视角旋转。&lt;option&gt;可以是：</p><ul><li>back（转向身后），left（左转90°），right（右转90°）。</li><li>两个浮点数：具体控制旋转的角度。第一个数字控制视角的俯仰（正为俯视，负为仰视），第二个数字控制视角的水平角度（正为右转，负为左转）。例如，/player &lt;target&gt; turn -45 90 会让玩家的视角上扬45°并右转90°。</li></ul><p>更多教程看</p><p><a href="https://www.mcmod.cn/item/list/2361-10.html">游戏设定 -Carpet - MC百科|最大的Minecraft中文MOD百科 (mcmod.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>Minecraft</category>
      
    </categories>
    
    
    <tags>
      
      <tag>我的世界mod教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为交换机基础配置</title>
    <link href="/post/%E5%8D%8E%E4%B8%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE.html"/>
    <url>/post/%E5%8D%8E%E4%B8%BA%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE.html</url>
    
    <content type="html"><![CDATA[<h1 id="基础配置命令">基础配置命令</h1><p>启动后进入交换机</p><h2 id="设置中文提示">设置中文提示</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-z0zviolu5obpg4"></i><span>switch</span><div class="collapse show" id="collapse-z0zviolu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs switch">language-mode Chinese<br></code></pre></td></tr></table></div></figure><h2 id="进入系统视图">进入系统视图</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-03hynolu5obpg4"></i><span>switch</span><div class="collapse show" id="collapse-03hynolu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs switch">system-view<br></code></pre></td></tr></table></div></figure><h2 id="用户权限">用户权限</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-7gz5xilu5obpg4"></i><span>switch</span><div class="collapse show" id="collapse-7gz5xilu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs switch">user privilege level 15<br></code></pre></td></tr></table></div></figure><h2 id="进入console配置">进入console配置</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-isxn8clu5obpg4"></i><span>switch</span><div class="collapse show" id="collapse-isxn8clu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs switch">user-interface console 0<br></code></pre></td></tr></table></div></figure><h2 id="设置console密码">设置console密码</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-trnl59lu5obpg4"></i><span>switch</span><div class="collapse show" id="collapse-trnl59lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs switch">authentication-mode password<br>set authentication password simple Huawei<br></code></pre></td></tr></table></div></figure><h2 id="设置登录前后标语">设置登录前后标语</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-wrrn8zlu5obpg4"></i><span>switch</span><div class="collapse show" id="collapse-wrrn8zlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs switch">header login information &quot;This is SW1&quot;<br>header shell information &quot;login succeed&quot;<br></code></pre></td></tr></table></div></figure><h2 id="创建与划分vlan">创建与划分vlan</h2><h3 id="创建vlan">创建vlan</h3><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-olyjcklu5obpg4"></i><span>switch</span><div class="collapse show" id="collapse-olyjcklu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs switch">vlan batch 10 20<br></code></pre></td></tr></table></div></figure><h3 id="进入端口并划分vlan">进入端口并划分vlan</h3><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-54y9trlu5obpg4"></i><span>switch</span><div class="collapse show" id="collapse-54y9trlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs switch">interface GigabitEthernet 0/0/1<br>port link-type access<br>port default vlan 10<br></code></pre></td></tr></table></div></figure><h2 id="设置vlan-ip">设置vlan IP</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-wey5nblu5obpg4"></i><span>switch</span><div class="collapse show" id="collapse-wey5nblu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs switch">interface vlanif 10<br>ip address 192.168.10.1 24<br></code></pre></td></tr></table></div></figure><h2 id="查看配置结果">查看配置结果</h2><figure class="highlight plaintext"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-wb456tlu5obpg4"></i><span>switch</span><div class="collapse show" id="collapse-wb456tlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs switch">display current-configuration<br></code></pre></td></tr></table></div></figure>]]></content>
    
    
    <categories>
      
      <category>网络设备</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eNSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>imgTP图床测试</title>
    <link href="/post/imgTP%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95.html"/>
    <url>/post/imgTP%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95.html</url>
    
    <content type="html"><![CDATA[<p>我是OP</p><figure><img src="imgTP%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95/EOFNREpH.jpg"alt="二次元图片" /><figcaption aria-hidden="true">二次元图片</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这是一篇用来测试的文章</title>
    <link href="/post/%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E7%94%A8%E6%9D%A5%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%87%E7%AB%A0.html"/>
    <url>/post/%E8%BF%99%E6%98%AF%E4%B8%80%E7%AF%87%E7%94%A8%E6%9D%A5%E6%B5%8B%E8%AF%95%E7%9A%84%E6%96%87%E7%AB%A0.html</url>
    
    <content type="html"><![CDATA[<p>此篇文章用来记录一些hexo的基本操作（纯新手）</p><h1 id="插入图片">插入图片</h1><h2 id="第一种方法">第一种方法</h2><p><del>此时我在<strong>source</strong>文件夹下新建了一个名为“Article_Picture” 的文件夹用来存放图片。</del><del>此时只需要按照以下格式在.md文件中写入即可。</del></p><p>不用看以上方法了，没用。</p><p>首先在hexo的配置文件<code>config.yaml</code>更改一下配置：</p><figure class="highlight yaml"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-7h2irolu5obpg4"></i><span>yaml</span><div class="collapse show" id="collapse-7h2irolu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></div></figure><p>随后使用命令新建一篇文章时，hexo会在<code>_posts</code>中生成相同名字的文件夹，此时将图片放在该文件夹下，而后按照以下格式进行插入即可。</p><figure class="highlight markdown"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-xgfyirlu5obpg4"></i><span>markdown</span><div class="collapse show" id="collapse-xgfyirlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![<span class="hljs-string">图片加载失败时的描述</span>](<span class="hljs-link">图片链接</span>)<br></code></pre></td></tr></table></div></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/%E6%B5%8B%E8%AF%95%E6%88%AA%E5%9B%BE2.png"alt="这其实是一张图片" /><figcaption aria-hidden="true">这其实是一张图片</figcaption></figure><h2 id="第二种方法">第二种方法</h2><p>略</p><h1 id="插件的查看与卸载">插件的查看与卸载</h1><h2 id="查看已安装插件">查看已安装插件</h2><p>在blog目录下输入以下命令即可查看已安装插件 <figure class="highlight powershell"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-o2gi7tlu5obpg4"></i><span>powershell</span><div class="collapse show" id="collapse-o2gi7tlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm <span class="hljs-built_in">ls</span> <span class="hljs-literal">-dept</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></div></figure> <imgsrc="https://cdn.jsdelivr.net/gh/lxqingfeng/Object_storage@master/PicGO/mingling.png"alt="这其实是一张图片" /></p><h2 id="卸载插件">卸载插件</h2><p>在blog目录下输入以下命令即可卸载已安装插件 <figure class="highlight powershell"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-j7ulnolu5obpg4"></i><span>powershell</span><div class="collapse show" id="collapse-j7ulnolu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm uninstall hexo<span class="hljs-literal">-asset-image</span>@<span class="hljs-number">0.0</span>.<span class="hljs-number">5</span> <span class="hljs-literal">--save</span><br></code></pre></td></tr></table></div></figure> 其中<strong>hexo-asset-image@0.0.5</strong> 为要卸载的插件的名称</p><p>最后还需前往 <strong>node_modules</strong>文件夹删除相关配置和文件</p><h1 id="插入数学公式">插入数学公式</h1><h2 id="安装所需插件">安装所需插件</h2><p>卸载 Hexo 自带的 renderer，安装 Pandoc renderer <ahref="https://github.com/jgm/pandoc">下载pandoc并安装</a><figure class="highlight powershell"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-rhkgutlu5obpg4"></i><span>powershell</span><div class="collapse show" id="collapse-rhkgutlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">npm uninstall hexo<span class="hljs-literal">-renderer-marked</span> <span class="hljs-literal">--save</span><br>npm install hexo<span class="hljs-literal">-renderer-pandoc</span> <span class="hljs-literal">--save</span><br></code></pre></td></tr></table></div></figure></p><h2 id="如何使用">如何使用</h2><p><ahref="https://corner430.github.io/2021/07/02/%E7%94%A8markdown%E4%B9%A6%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/#:~:text=%E8%A1%8C%E5%86%85%E5%85%AC%E5%BC%8F%EF%BC%9A%E5%B0%86%E5%85%AC%E5%BC%8F%E6%8F%92%E5%85%A5%E5%88%B0%E6%9C%AC%E8%A1%8C%E5%86%85%EF%BC%8C%E7%AC%A6%E5%8F%B7%EF%BC%9A%20%24%E5%85%AC%E5%BC%8F%E5%86%85%E5%AE%B9%24%20%EF%BC%8C%E5%A6%82%EF%BC%9A%20xyz,%E7%8B%AC%E8%A1%8C%E5%85%AC%E5%BC%8F%EF%BC%9A%E5%B0%86%E5%85%AC%E5%BC%8F%E6%8F%92%E5%85%A5%E5%88%B0%E6%96%B0%E7%9A%84%E4%B8%80%E8%A1%8C%E5%86%85%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%B1%85%E4%B8%AD%EF%BC%8C%E7%AC%A6%E5%8F%B7%EF%BC%9A%20%24%24%E5%85%AC%E5%BC%8F%E5%86%85%E5%AE%B9%24%24%20%EF%BC%8C%E5%A6%82%EF%BC%9A%20xyz">具体请参考这篇文章</a></p><p>所有公式都应该包括在一对 “$” 符号中，例如： <figure class="highlight markdown"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-6lsdv0lu5obpg4"></i><span>markdown</span><div class="collapse show" id="collapse-6lsdv0lu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$里面是公式内容$<br></code></pre></td></tr></table></div></figure> <spanclass="math inline">\(5^5-ads\)</span></p><h1 id="如何使用-emoji-表情">如何使用 Emoji 表情</h1><h2 id="使用表情符号简码">使用表情符号简码</h2><p>一些Markdown应用程序允许您通过键入表情符号短代码来插入表情符号。这些以冒号开头和结尾，并包含表情符号的名称。<figure class="highlight markdown"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-fn6vxnlu5obpg4"></i><span>markdown</span><div class="collapse show" id="collapse-fn6vxnlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown">去露营了！ :tent: 很快回来。<br>真好笑！ :joy:<br></code></pre></td></tr></table></div></figure> 呈现的输出如下所示： 去露营了！ :tent: 很快回来。 真好笑！:joy:</p><p><ahref="https://markdown.com.cn/extended-syntax/emoji.html">请参考Markdown的官方教程</a></p><p><ahref="https://gist.github.com/rxaviers/7360908">这是表情符号简码列表</a></p><h1 id="插入表格">插入表格</h1><h2 id="markdown默认方法">Markdown默认方法</h2><p>表头内容默认居中对齐，单元格内容默认左对齐，Markdown 代码:<figure class="highlight markdown"><i class="iconfont icon-icon-down" type="button" data-toggle="collapse" data-target="#collapse-i24jgjlu5obpg4"></i><span>markdown</span><div class="collapse show" id="collapse-i24jgjlu5obpg4"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">| 标题1 | 标题2 | 标题3 |<br>| ------ | ------ | ------ |<br>| 文本好短 | 文本不短也不长 | 文本好长文本好长文本好长 |<br>| 文本好长文本好长文本好长 | 文本好短 | 文本不短也不长 |<br></code></pre></td></tr></table></div></figure> 显示效果：</p><table><thead><tr class="header"><th>标题1</th><th>标题2</th><th>标题3</th></tr></thead><tbody><tr class="odd"><td>123</td><td>123</td><td>123</td></tr><tr class="even"><td>123</td><td>123</td><td>123</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
